<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>雀渣——国标麻将</title>
    <style>*{padding:0; margin:0}</style>
    <meta name="viewport" content="user-scalable=no, initial-scale=.4, maximum-scale=.4, minimum-scale=.4, width=device-width, height=device-height"/>
</head>
<body>
    <canvas>你的浏览器不支持此游戏</canvas>
    <script src="js/pixi.min.js"></script>
    <script src="js/Tween.min.js"></script>
    <script src="js/PIXI.TextInput.min.js"></script>
    <script src="js/pixi-sound.js"></script>
    <script>
        const all_tiles = [
            0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
            3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5,
            6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
            16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
            19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,
            22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24,
            32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34,
            35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37,
            38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40,
            48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50,
            51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53,
            54, 54, 54, 54, 64, 65, 66, 67, 68, 69, 70, 71
        ];

        function pack_get_type(p) { return (p >> 8) & 3; }
        function pack_get_tile(p) { return (p & 0x3F) << 2; }
        function pack_get_offer(p) { return (p >> 6) & 3; }
        function is_promoted_kong(p) { return (p & 0x0300) == 0x0300; }
        function lo_byte(w) { return w & 0xFF; }
        function hi_byte(w) { return (w >> 8) & 0xFF; }
        function shuffle_array(arr, beg, end) {
            for (let i = beg, len = arr.length; i < end && i < len; ++i) {
                let j = Math.floor(Math.random() * (end - beg)) + beg;
                if (i != j) {
                    let t = arr[i];
                    arr[i] = arr[j];
                    arr[j] = t;
                }
            }
        }
        var plus_sign = (x)=>(x >= 0 ? `+${x}` : x);
        var pad2 = (x)=>(x < 10 ? `0${x}` : x);

        console.log('location.search', location.search);

        let app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            view: document.querySelector('canvas')
        });

        //PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;

        app.renderer.view.style.display = 'block';
        window.onresize = ()=>{
            app.renderer.resize(window.innerWidth, window.innerHeight);
        };

        //function animate(time) {
        //    window.requestAnimationFrame(animate);
        //    app.renderer.render(app.stage);
        //    TWEEN.update();
        //}
        //animate(performance.now());

        setInterval(()=>{
            app.renderer.render(app.stage);
            TWEEN.update();
        }, 33.333);

        let loadingText = new PIXI.Text('0%', {
            fontFamily: 'Arial,Helvetica,sans-serif',
            fontSize: 40,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
        });
        app.stage.addChild(loadingText);
        loadingText.anchor.set(.5);
        loadingText.x = window.innerWidth * .5;
        loadingText.y = window.innerHeight * .5;
        window.onresize = ()=>{
            app.renderer.resize(window.innerWidth, window.innerHeight);
            loadingText.x = window.innerWidth * .5;
            loadingText.y = window.innerHeight * .5;
        };

        let mutecd = parseInt(localStorage.getItem('mutecd'));
        let lobby, game, ws, hbt;

        function reenter() {
            ws.send('{"m":4}');
        }

        function play_snd(s) {
            try {
                PIXI.loader.resources[s].sound.play();
            }
            catch (e) {
                console.log(e);
            }
        }

        PIXI.loader.add([
            'img/ui/checkbox_normal.png',
            'img/ui/checkbox_tick.png',

            'img/tiles/standing1.png',
            'img/tiles/standing3.png',
            'img/tiles/pool0.png',
            'img/tiles/pool1.png',
            'img/tiles/pool2.png',
            'img/tiles/pool3.png',
            'img/tiles/standing0.png',

            'img/dice/1.png',
            'img/dice/2.png',
            'img/dice/3.png',
            'img/dice/4.png',
            'img/dice/5.png',
            'img/dice/6.png',

            'fnt/SourceHanSansBold.png',
            'fnt/SourceHanSansBold.fnt',
            'fnt/STXingkai.png',
            'fnt/STXingkai.fnt',

            'snd/01-start.wav',
            'snd/02-dice.wav',
            'snd/03-cd.wav',
            'snd/05-draw.wav',
            'snd/06-discard.wav',
            'snd/08-inquire.wav',
            'snd/09-cpk.wav',
            'snd/10-win.wav',
            'snd/12-flower-m.wav',
            'snd/13-flower-f.wav',
            'snd/14-chow-m.wav',
            'snd/15-chow-f.wav',
            'snd/16-pung-m.wav',
            'snd/17-pung-f.wav',
            'snd/18-kong-m.wav',
            'snd/19-kong-f.wav',
            'snd/20-win-m.wav',
            'snd/21-win-f.wav',
            'snd/24-dingdong.wav'
        ])
        .on('progress', (e)=>{
            console.log('loading progress:', e.progress);
            loadingText.text = e.progress.toFixed(2) + '%';
        })
        .load(()=>{
            app.stage.removeChild(loadingText);
            delete loadingText;

            lobby = new LobbyView();
            app.stage.addChild(lobby);

            game = new GameView();
            app.stage.addChild(game);

            game.visible = false;

            document.oncontextmenu = ()=>false;

            lobby.adapt();
            game.adapt();
            window.onresize = ()=>{
                app.renderer.resize(window.innerWidth, window.innerHeight);
                lobby.adapt();
                game.adapt();
            };

            let volume = localStorage.getItem('volume');
            volume = (volume != undefined) ? Math.max(0, Math.min(100, parseFloat(volume))) : 100;
            PIXI.sound.volumeAll = volume / 100;

            ws = new WebSocket('ws://127.0.0.1:40080/ws');
            ws.onopen = ()=>{
                console.log('open');
                // 测试直接创建桌子/坐下
                // let idx = location.search.substr(1);
                // if (idx == undefined) idx = 0;
                // if (idx == 0) {
                //     ws.send('{"m":1,"r":3}');
                // }
                // else {
                //     ws.send(`{"m":1,"r":4,"v":10001,"s":${idx}}`);
                // }
                // ws.send('{"m":1,"r":6}');
                ws.send('{"m":1,"r":2}');
                let ck = document.cookie;
                if (ck) {
                    var pt = ck.split('=');
                    if (pt[1]) {
                        ws.send(`{"m":1,"r":11,"t":"${pt[1]}"}`);
                    }
                }
                else {
                    let un = localStorage.getItem('username'), pw = localStorage.getItem('password');
                    if (un && pw) {
                        ws.send(`{"m":1,"r":9,"u":"${un}","p":"${pw}"}`);
                    }
                }

                hbt = 0;
                window.setInterval(()=>{
                    if (++hbt == 30) {
                        hbt = 0;
                        ws.send('');
                    }
                }, 1000);
            };
            ws.onerror = (e)=>{
                console.log('error',e);
            };
            ws.onclose = ()=>{
                console.log('close');
            };
            ws.onmessage = (e)=>{
                let resp = JSON.parse(e.data);
                console.log(resp);
                let m = resp['m'];
                switch (m) {
                case 1:
                    lobby.onmessage(resp);
                    break;
                case 2:
                    game.onmessage(resp);
                    break;
                case 3:
                    lobby.visible = false;
                    game.visible = true;
                    break;
                case 4:
                    lobby.visible = false;
                    game.reconnect(resp);
                    game.visible = true;
                    break;
                default:
                    break;
                }
                hbt = 0;
            };

            // {
            // let pool = game.pool_;
            // // 15个番的测试用例
            // let ht = {"p":[0x21B],"s":[69,70,75,76,81,97,104,105,106,107]};
            // let ft = {"44":8,"46":8,"55":4,"56":4,"58":4,"60":2,"61":2,"64":2,"66":2,"67":2,"72":1,"73":1,"75":1,"78":1,"81":0x101};
            // let dt = {"r":0,"f":44,"p":0x0000,"t":[156,-52,-52,-52],"s":[156,-52,-52,-52],"n":[0,0,0,0]};
            // let nl = ['玩家1','玩家2','玩家3','玩家4'];
            // let vi = 1;
            // let view = new SettleView(ht, 100, ft, dt, nl, vi);
            // pool.addChild(view);

            // view.x = (pool.width / pool.scale.x - view.width) * .5;
            // view.y = (pool.height / pool.scale.x - view.height) * .5;
            // }
            //pool.rp_ = [{"n":"名字1","l":0,"s":100},{"n":"名字2","l":0,"s":50},{"n":"名字3","l":0,"s":-50},{"n":"名字4","l":0,"s":-100}];
        });

        class GameView extends PIXI.Container {
            constructor() {
                super();

                let title = this.title_ = new PIXI.Text('', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 28,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(title);

                let subtitle = this.subtitle_ = new PIXI.Text('', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 16,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(subtitle);
                subtitle.y = 30;

                // 加这个布局才正常
                // 加了标题之后，可以不要这个了
                //let bg = new PIXI.Graphics();
                //this.addChild(bg);

                let pool = new Pool();
                this.pool_ = pool;
/*
                pool.roundText_.text = '东风东';
                pool.remainText_.text = '牌墙剩余：144';

                pool.windTexts_[0].text = '东 1000';
                //pool.windTexts_[0].style.fill = 'black';
                //pool.windTexts_[0].style.stroke = '#ffffff';
                pool.windTexts_[1].text = '南 1000';
                pool.windTexts_[2].text = '西 1000';
                pool.windTexts_[3].text = '北 1000';

                pool.infoPanels_[0].setName('东家昵称长长长长');
                pool.infoPanels_[1].setName('南家昵称长长长长长');
                pool.infoPanels_[2].setName('西家昵称长长长长长长');
                pool.infoPanels_[3].setName('北家昵称长长长长长长长');
*/
                // //pool.removeChildren();
                // pool.setupPool([
                //     [0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36],
                //     [0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x44, 0x45, 0x46, 0x47],
                //     [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18],
                //     [0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28]
                // ]);
                pool.clear();

                this.addChild(pool);

                let panel = new OptionPanel();
                this.addChild(panel);
                pool.option_ = panel;

                pool.y = 50;
                panel.x = 10;
                panel.y = pool.height + 70;
                panel.scale.set(pool.width / (panel.width + 20));
                this.containerWidth_ = this.width;
                this.containerHeight_ = this.height;

                let piano = new Piano(pool.width, pool.standing_[0]);
                this.addChild(piano);
                piano.visible = false;
                pool.piano_ = piano;

                this.interactive = true;
                this.on('rightclick', this.rightclick);
            }

            adapt() {
                let pool = this.pool_;
                let panel = pool.option_;
                let piano = pool.piano_;

                let containerWidth = this.containerWidth_;
                let containerHeight = this.containerHeight_;

                let sx = window.innerWidth / containerWidth;
                let sy = window.innerHeight / containerHeight;
                let ss = Math.min(sx, sy);

                this.scale.set(ss);
                let ch = Math.round(containerHeight * ss);
                if (window.innerHeight <= ch) {
                    this.x = (window.innerWidth - containerWidth * ss) * .5;
                    if (piano.visible) {
                        piano.visible = false;
                        piano.y = 0;
                        panel.y = pool.height + 70;
                    }
                } else {
                    this.x = 0;

                    let space = window.innerHeight / ss - containerHeight;
                    //console.log('space = ', space);
                    if (space > 400 + 20) {
                        if (!piano.visible) {
                            piano.visible = true;
                            piano.y = pool.height + 55;
                            panel.y = pool.height + 75 + 400;
                        }
                    } else {
                        if (piano.visible) {
                            piano.visible = false;
                            piano.y = 0;
                            panel.y = pool.height + 70;
                        }
                    }
                }
            }

            onmessage(resp) {
                let pool = this.pool_;
                let r = resp['r'];

                switch (r) {
                case 1:  // 初始化桌子
                    let cfg = pool.cfg_ = resp['g'];
                    this.setTitle(cfg);
                    pool.step_ = 0;
                    break;
                case 2: { // 起手
                    pool.clear();
                    pool.option_.reset();
                    pool.seat_ = parseInt(resp['p']);
                    let h = pool.rd_ = resp['h'];
                    pool.roundText_.text = WIND[h >> 2] + '风' + WIND[h & 3];
                    if (h & 3) {
                        pool.sendHandTiles(resp['d'], resp['v']);
                    }
                    else {
                        pool.sendHandTiles2(resp['d'], resp['v']);
                    }
                    pool.isDiscarding_ = false;
                    pool.step_ = 3;
                    break;
                }
                case 3: {  // 询问补花
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    pool.setTurn(v);
                    if (v != pool.seat_) {
                        pool.removeCD();
                        pool.removeBtns();
                    }
                    else {
                        if (resp['f']) {
                            pool.addBtns([0x10000]);
                            pool.addCD(pool.cfg_['r12']);
                        }
                        else {
                            pool.removeCD();
                            pool.removeBtns();
                        }
                    }
                    break;
                }
                case 4: {  // 补花
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    play_snd(!pool.players_[v]['g'] ? 'snd/12-flower-m.wav' : 'snd/13-flower-f.wav');
                    pool.turn_ = v;
                    if (v != pool.seat_) {
                        pool.flower123((v + 4 - pool.seat_) & 3, resp['h']);
                        pool.removeCD();
                    } else {
                        let t = resp['t'];
                        pool.flower0(lo_byte(t), hi_byte(t), resp['h']);
                        pool.addCD(pool.cfg_[pool.isDiscarding_ ? 'r30' : 'r12']);
                        pool.addBtns(resp['a']);
                    }
                    break;
                }
                case 5: {  // 开始出牌
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    pool.isDiscarding_ = true;
                    pool.setTurn(0);
                    if (pool.seat_ != 0) {
                        pool.removeCD();
                        pool.removeBtns();
                    }
                    else {
                        pool.addCD(pool.cfg_['r30']);
                        pool.addBtns(resp['a']);
                    }
                    break;
                }
                case 6: {  // 抓牌
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    let t = resp['t'];
                    pool.turn_ = v;
                    pool.draw((v + 4 - pool.seat_) & 3, hi_byte(t), lo_byte(t), resp['h']);
                    if (pool.seat_ == v) {
                        pool.addCD(pool.cfg_['r30']);
                        pool.addBtns(resp['a']);
                    }
                    break;
                }
                case 7: {  // 出牌
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    pool.discard((v + 4 - pool.seat_) & 3, resp['t'], resp['h']);
                    let a = resp['a'];
                    if (a && a.length > 0) {
                        pool.addCD(pool.cfg_[(((pool.turn_ + 1) & 3) == pool.seat_) ? 'r30' : 'r12']);
                        pool.addBtns(a);
                    }
                    break;
                }
                case 8:  // 吃
                case 9:  // 碰
                {
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    play_snd(!pool.players_[v]['g'] ? (r == 8 ? 'snd/14-chow-m.wav' : 'snd/16-pung-m.wav') : (r == 8 ? 'snd/15-chow-f.wav' : 'snd/17-pung-f.wav'));
                    let idx = (v + 4 - pool.seat_) & 3;
                    pool.showCallText(idx, r == 8 ? '吃' : '碰');

                    let p = resp['p'];
                    if (p != undefined) {
                        pool['cpk' + idx].call(pool, p);
                    }
                    else {
                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                    }
                    break;
                }
                case 10: {  // 明杠
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    play_snd(!pool.players_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
                    let idx = (v + 4 - pool.seat_) & 3;
                    pool.showCallText(idx, '杠');

                    let p = resp['p'];
                    if (p == undefined) {
                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                    }
                    else if (!is_promoted_kong(p)) {
                        pool['cpk' + idx].call(pool, p);
                    }
                    else {
                        pool['pk' + idx].call(pool, p, false);
                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                    }
                    break;
                }
                case 11: {  // 暗杠
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    play_snd(!pool.players_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
                    let idx = (v + 4 - pool.seat_) & 3;
                    pool.showCallText(idx, '杠');
                    pool['ck' + idx].call(pool, resp['p'], false);
                    break;
                }
                case 12: {  // 和
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    let wp = hi_byte(v);
                    let cp = lo_byte(v);
                    let n = (wp + 4 - pool.seat_) & 3;

                    play_snd(!pool.players_[wp]['g'] ? 'snd/20-win-m.wav' : 'snd/21-win-f.wav');
                    let detail = resp['d'];
                    if (detail == undefined) {
                        pool.showCallText(n, '和');
                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                        break;
                    }

                    let succeed = detail['w'];

                    let tiles = resp['t'];
                    pool.openHand(tiles, succeed, wp, cp, resp['w']);
                    if (!succeed) {
                        pool.falseWin_[n] = true;
                        pool.infoPanels_[n].setFalseWin(true);
                        console.log('错和');
                        if (wp == pool.seat_) {
                            pool.showFalseWin(detail['f'], resp['p']);
                        }
                        break;
                    }
                    pool.removeCD();
                    pool.removeBtns();
                    pool.showSettleView(tiles[wp], resp['w'], resp['p'], detail);
                    break;
                }
                case 13: {  // 流局
                    pool.openHand(resp['t'], true);
                    pool.showSettleView(null, 0, null, resp['d']);
                    break;
                }
                case 14: {  // 换位
                    pool.step_ = 1;
                    let p = resp['p'];
                    let v = parseInt(resp['v']);
                    pool.seat_ = v;
                    for (let i = 0; i < 4; ++i) {
                        let idx = (i + 4 - v) & 3;
                        let pi = p[i];
                        pool.infoPanels_[idx].setName(pi['n']);
                        pool.infoPanels_[idx].setConnection(!pi['o']);
                    }
                    pool.players_ = p;
                    break;
                }
                case 15: {  // 延时
                    break;
                }
                case 16: {  // 准备
                    break;
                }
                case 17: {  // 对局结束
                    pool.rp_ = resp['p'];
                    pool.rpt_ = resp['t'];
                    break;
                }
                case 18: {  // 离线/上线
                    let v = resp['v'];
                    let idx = (resp['v'] + 4 - pool.seat_) & 3;
                    pool.infoPanels_[idx].setConnection(resp['c']);
                    break;
                }
                case 19: // 超时
                    pool.timeout_.visible = true;
                    break;
                default:
                    break;
                }
            }

            setTitle(cfg) {
                this.title_.text = cfg['t'];
                this.subtitle_.text = fmt_cfg(cfg);
            }

            rightclick() {
                let pool = this.pool_;
                if (pool.actionBtns_[0].visible) {
                    pool.removeBtns();
                    ws.send('{"m":2,"r":9,"v":0}');
                    pool.removeCD();
                }
            }

            reconnect(resp) {
                let pool = this.pool_;
                let cfg = pool.cfg_ = resp['g'];
                this.setTitle(cfg);
                pool.reconnect(resp);
            }
        }

        let showWall = true, openWall = false;

        const OVERLAP = 18, HEIGHT_02F = 78, HEIGHT_13F = 64, GAP_T = 5, GAP_W = 10;
        const WIDTH_02 = 52, HEIGHT_02 = 60,/*78-18=60*/ WIDTH_13 = 70, HEIGHT_13 = 46;/*64-18=46*/
        const WIDTH_13S = 36, HEIGHT_13SF = 83;

        const HAND_WIDTH_02 = WIDTH_02 * 14 + WIDTH_13 * 4 + GAP_T * 5;
        const HAND_HEIGHT_02 = HEIGHT_13 * 2 + OVERLAP;

        const HAND_WIDTH_13 = WIDTH_02 * 2;
        const HAND_HEIGHT_13 = HEIGHT_13 * 14 + HEIGHT_02 * 4 + GAP_T * 5 + OVERLAP;

        const HAND_SCALE = 1.7;//1 + (WIDTH_13 + GAP_T) / (WIDTH_02 * 3);

        const WIND = ['东', '南', '西', '北'];
        const ACTION = ['吃', '碰', '杠', '和', '花', '过'];

        const EXT_CP_02 = (WIDTH_13 + GAP_T - WIDTH_02) * .5; // (WIDTH_02 * 2 + WIDTH_13 + GAP_T - WIDTH_02 * 3) * .5
        const EXT_DK_02 = (WIDTH_13 + GAP_T) * .5;  // (WIDTH_02 * 3 + WIDTH_13 + GAP_T - WIDTH_02 * 3) * .5
        const EXT_CK_02 = (WIDTH_02 + GAP_T) * .5;

        const EXT_CP_13 = (HEIGHT_02 + GAP_T - HEIGHT_13) * .5; // (HEIGHT_13 * 2 + HEIGHT_02 + GAP_T - HEIGHT_13 * 3) * .5
        const EXT_DK_13 = (HEIGHT_02 + GAP_T) * .5;  //  (HEIGHT_13 * 3 + HEIGHT_02 + GAP_T - HEIGHT_13 * 3) * .5
        const EXT_CK_13 = (HEIGHT_13 + GAP_T) * .5;

        const DOX = [10, 10, -10, -10];
        const DOY = [10, -10, -10, 10];

/*
        const MPO = [
            [PoolTile1, PoolTile0, PoolTile3],
            [PoolTile2, PoolTile1, PoolTile0],
            [PoolTile3, PoolTile2, PoolTile1],
            [PoolTile0, PoolTile3, PoolTile2]
        ];
*/
        const DRAW_DT = 100;
        const SORT_DT = 200;
        const DISCARD_DT = 150;

        class PoolTile extends PIXI.Sprite {
            constructor(tex, t) {
                super(tex);
                this.t_ = t;
            }
        }

        class PoolTile0 extends PoolTile {
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PIXI.loader.resources['img/tiles/pool0.png'].texture.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                super(tex, t);
            }

            update(t) {
                updatePool02Tile(this, t);
            }
        }

        class PoolTile1 extends PoolTile {
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PIXI.loader.resources['img/tiles/pool1.png'].texture.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_13 + 2) * (ti & 0xF) + 2, (HEIGHT_13F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_13, HEIGHT_13F);
                super(tex, t);
            }

            update(t) {
                updatePool13Tile(this, t);
            }
        }

        class PoolTile2 extends PoolTile {
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PIXI.loader.resources['img/tiles/pool2.png'].texture.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                super(tex, t);
            }

            update(t) {
                updatePool02Tile(this, t);
            }
        }

        class PoolTile3 extends PoolTile {
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PIXI.loader.resources['img/tiles/pool3.png'].texture.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_13 + 2) * (ti & 0xF) + 2, (HEIGHT_13F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_13, HEIGHT_13F);
                super(tex, t);
            }

            update(t) {
                updatePool13Tile(this, t);
            }
        }

        const CTOR_PT = [PoolTile0, PoolTile1, PoolTile2, PoolTile3];

        class Pool extends PIXI.Container {
            constructor() {
                super();

                const MAX_WIDTH = HAND_WIDTH_13 * 2 + GAP_W * 2 + HAND_WIDTH_02;
                const MAX_HEIGHT = HAND_HEIGHT_02 * 2 + GAP_W * 2 + HAND_HEIGHT_13 + OVERLAP * 2;

                const CENTER_WIDTH = MAX_WIDTH - HAND_WIDTH_13 * 2 - GAP_W * 4 - WIDTH_02 * 14;
                const CENTER_HEIGHT = MAX_HEIGHT - HAND_HEIGHT_02 * 2 - GAP_W * 4 - HEIGHT_13 * 14 - OVERLAP * 4;

                this.width = this.width_ = MAX_WIDTH;
                this.height = this.height_ = MAX_HEIGHT;

                this.callTextPos_ = [
                    {'x':MAX_WIDTH * .5, 'y':MAX_HEIGHT - 120, 'ax':.5, 'ay':1},
                    {'x':MAX_WIDTH - 80, 'y':MAX_HEIGHT * .5, 'ax':1, 'ay':.5},
                    {'x':MAX_WIDTH * .5, 'y':80, 'ax':.5, 'ay':0},
                    {'x':80, 'y':MAX_HEIGHT * .5, 'ax':0, 'ay':.5}
                ];

                {
                let graph = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0x89A4C7, .5);
                graph.drawRect(0, 0, MAX_WIDTH, MAX_HEIGHT);
                graph.endFill();
                this.addChild(graph);
                }

                // 中间的面板
                let graph = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0, .5);
                graph.drawRect(0, 0, CENTER_WIDTH, CENTER_HEIGHT);
                graph.endFill();
                this.addChild(graph);
                graph.pivot.x = CENTER_WIDTH * .5;
                graph.pivot.y = CENTER_HEIGHT * .5;
                graph.x = MAX_WIDTH * .5;
                graph.y = MAX_HEIGHT * .5;

                // 当前打：X风X
                let text = this.roundText_ = new PIXI.extras.BitmapText('', { font: '80px SourceHanSansBold' });
                text.anchor.set(.5);
                text.x = CENTER_WIDTH * .5;
                text.y = CENTER_HEIGHT * .5 - 25;
                graph.addChild(text);

                // 牌墙剩余
                text = this.remainText_ = new PIXI.Text('', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 26,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                text.anchor.set(.5);
                text.x = CENTER_WIDTH * .5;
                text.y = CENTER_HEIGHT * .5 + 40;
                graph.addChild(text);

                // 四家方位及得分
                let windTexts = [null, null, null, null];

                // 人名等信息
                let infoPanels = [null, null, null, null];

                for (let i = 0; i < 4; ++i) {
                    text = new PIXI.Text('', {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 32,
                        fill: '#dedede',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    text.anchor.set(.5);
                    graph.addChild(text);
                    windTexts[i] = text;

                    let panel = infoPanels[i] = new InfoPanel();
                    this.addChild(panel);
                }

                const WIND_OFFSET = 25;

                windTexts[0].x = CENTER_WIDTH * .5;
                windTexts[0].y = CENTER_HEIGHT - WIND_OFFSET;

                windTexts[1].x = CENTER_WIDTH - WIND_OFFSET;
                windTexts[1].y = CENTER_HEIGHT * .5;
                windTexts[1].rotation = -Math.PI * .5;

                windTexts[2].x = CENTER_WIDTH * .5;
                windTexts[2].y = WIND_OFFSET;
                windTexts[2].rotation = Math.PI;

                windTexts[3].x = WIND_OFFSET;
                windTexts[3].y = CENTER_HEIGHT * .5;
                windTexts[3].rotation = Math.PI * .5;

                this.windTexts_ = windTexts;

                const INFO_OFFSET_X_02 = (MAX_WIDTH - CENTER_WIDTH) * .5 - 25;
                const INFO_OFFSET_Y_02 = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - 50;
                const INFO_OFFSET_X_13 = (MAX_WIDTH - CENTER_WIDTH) * .5 - 50 - OVERLAP;
                const INFO_OFFSET_Y_13 = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - 25;

                infoPanels[0].x = INFO_OFFSET_X_02;
                infoPanels[0].y = MAX_HEIGHT - INFO_OFFSET_Y_02;

                infoPanels[1].x = MAX_WIDTH - INFO_OFFSET_X_13;
                infoPanels[1].y = MAX_HEIGHT - INFO_OFFSET_Y_13;
                infoPanels[1].rotation = -Math.PI * .5;

                infoPanels[2].x = MAX_WIDTH - INFO_OFFSET_X_02;
                infoPanels[2].y = INFO_OFFSET_Y_02;
                infoPanels[2].rotation = Math.PI;

                infoPanels[3].x = INFO_OFFSET_X_13;
                infoPanels[3].y = INFO_OFFSET_Y_13;
                infoPanels[3].rotation = Math.PI * .5;

                this.infoPanels_ = infoPanels;

                {
                    // 四家牌墙
                    let walls = [new Array(36), new Array(36), new Array(36), new Array(36)];
                    let x, y;

                    // 上家
                    if (!openWall) {
                        x = HAND_WIDTH_13 + GAP_W;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 - OVERLAP - HEIGHT_13 * 18;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let realIdx = (17 - pier) * 2 + (1 - down);

                            let t = createWall13Tile();
                            this.addChild(t);
                            walls[3][realIdx] = t;
                            t.x = x;
                            t.y = y + HEIGHT_13 * pier - OVERLAP * down;
                        }
                    }
                    else {
                        x = HAND_WIDTH_13 + GAP_W + WIDTH_13;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 * 2 + OVERLAP - HEIGHT_13 * 18;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = 1 - (i & 1);
                            let realIdx = (17 - pier) * 2 + down;

                            let t = createWall13Tile();
                            this.addChild(t);
                            walls[3][realIdx] = t;
                            t.x = x - WIDTH_13 * down;
                            t.y = y + HEIGHT_13 * pier;
                        }
                    }

                    // 对家
                    if (!openWall) {
                        x = HAND_WIDTH_13 + GAP_W + WIDTH_13;
                        y = HAND_HEIGHT_02 + GAP_W + OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let realIdx = pier * 2 + (1 - down);

                            let t = createWall02Tile();
                            this.addChild(t);
                            walls[2][realIdx] = t;
                            t.x = x + WIDTH_02 * pier;
                            t.y = y - OVERLAP * down;
                        }
                    }
                    else {
                        x = HAND_WIDTH_13 + GAP_W + WIDTH_13 * 2;
                        y = HAND_HEIGHT_02 + GAP_W + HEIGHT_02 - OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = 1 - (i & 1);
                            let realIdx = pier * 2 + down;

                            let t = createWall02Tile();
                            this.addChild(t);
                            walls[2][realIdx] = t;
                            t.x = x + WIDTH_02 * pier;
                            t.y = y - HEIGHT_02 * down;
                        }
                    }

                    // 下家
                    if (!openWall) {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13;
                        y = HAND_HEIGHT_02 + GAP_W + HEIGHT_02 + OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let realIdx = pier * 2 + (1 - down);

                            let t = createWall13Tile();
                            this.addChild(t);
                            walls[1][realIdx] = t;
                            t.x = x;
                            t.y = y + HEIGHT_13 * pier - OVERLAP * down;
                        }
                    }
                    else {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13 * 2;
                        y = HAND_HEIGHT_02 + GAP_W + HEIGHT_02 * 2 - OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);

                            let t = createWall13Tile();
                            this.addChild(t);
                            walls[1][i] = t;
                            t.x = x + WIDTH_13 * down;
                            t.y = y + HEIGHT_13 * pier;
                        }
                    }

                    // 自己
                    if (!openWall) {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13 - WIDTH_02;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 - OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = 1 - (i & 1);
                            let realIdx = pier * 2 + down;

                            let t = createWall02Tile();
                            this.addChild(t);
                            walls[0][realIdx] = t;
                            t.x = x - WIDTH_02 * pier;
                            t.y = y + OVERLAP * (down-1);
                        }
                    }
                    else {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13 * 2 - WIDTH_02;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 * 2 + OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let t = createWall02Tile();
                            this.addChild(t);
                            walls[0][i] = t;
                            t.x = x - WIDTH_02 * pier;
                            t.y = y + HEIGHT_02 * down;
                        }
                    }

                    // 测试顺序
                    //for (let i = 0; i < 4; ++i) {
                    //    for (let n = 0; n < 15; ++n) {
                    //        walls[i][n].visible = false;
                    //    }
                    //}

                    this.walls_ = walls;

                    if (!showWall) {
                        for (let i = 0; i < 36; ++i) {
                            walls[0][i].visible = false;
                            walls[1][i].visible = false;
                            walls[2][i].visible = false;
                            walls[3][i].visible = false;
                        }
                    }
                }

                // 四家牌池
                let pools = [new Array(24), new Array(24), new Array(24), new Array(24)];
                let x, y;

                // 下家
                x = (MAX_WIDTH + CENTER_WIDTH) * .5;
                y = (MAX_HEIGHT + CENTER_HEIGHT) * .5 - HEIGHT_13 * 6;
                for (let i = 0; i < 24; ++i) {
                    let col = Math.floor(i / 6), row = (i % 6);
                    let realIdx = col * 6 + (5 - row);

                    let t = new PoolTile1(0);
                    this.addChild(t);
                    pools[1][realIdx] = t;
                    t.x = x + WIDTH_13 * col;
                    t.y = y + HEIGHT_13 * row;
                    t.visible = false;
                }

                // 对家
                x = (MAX_WIDTH + CENTER_WIDTH) * .5 - WIDTH_02;
                y = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - HEIGHT_02 * 4 - OVERLAP;
                for (let i = 0; i < 24; ++i) {
                    let col = (i % 6), row = Math.floor(i / 6);
                    let realIdx = (3 - row) * 6 + col;

                    let t = new PoolTile2(0);
                    this.addChild(t);
                    pools[2][realIdx] = t;
                    t.x = x - WIDTH_02 * col;
                    t.y = y + HEIGHT_02 * row;
                    t.visible = false;
                }

                // 上家
                x = (MAX_WIDTH - CENTER_WIDTH) * .5 - WIDTH_13;
                y = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - OVERLAP;
                for (let i = 0; i < 24; ++i) {
                    let t = new PoolTile3(0);
                    this.addChild(t);
                    pools[3][i] = t;
                    t.x = x - WIDTH_13 * Math.floor(i / 6);
                    t.y = y + HEIGHT_13 * (i % 6);
                    t.visible = false;
                }

                // 自己
                x = (MAX_WIDTH - CENTER_WIDTH) * .5;
                y = (MAX_HEIGHT + CENTER_HEIGHT) * .5;
                for (let i = 0; i < 24; ++i) {
                    let t = new PoolTile0(0);
                    this.addChild(t);
                    pools[0][i] = t;
                    t.x = x + WIDTH_02 * (i % 6);
                    t.y = y + HEIGHT_02 * Math.floor(i / 6);
                    t.visible = false;
                }

                this.pools_ = pools;

                // 测试顺序
                //for (let i = 0; i < 4; ++i) {
                //    for (let n = 0; n < 15; ++n) {
                //        pools[i][n].visible = true;
                //    }
                //}

                // 四家手牌
                let standing = [new Array(14), new Array(14), new Array(14), new Array(14)];
                let origin = [new Array(14), new Array(14), new Array(14), new Array(14)];

                // 上家
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect(0, (MAX_HEIGHT - HAND_HEIGHT_13) * .5, HAND_WIDTH_13, HAND_HEIGHT_13);
                    graph.endFill();
                    this.addChild(graph);

                    y = (MAX_HEIGHT - HAND_HEIGHT_13) * .5;
                    for (let i = 0; i < 4; ++i) {
                        for (let k = 0; k < 3; ++k) {
                            let t = new PoolTile3(0x41 + i);
                            t.y = y;
                            y += HEIGHT_13;
                            this.addChild(t);
                        }

                        let t = new PoolTile0(0x41 + i);
                        t.y = y;
                        y += HEIGHT_02 + GAP_T;
                        this.addChild(t);
                    }

                    let t = new PoolTile3(0x45);
                    t.y = y;
                    y += HEIGHT_13 + GAP_T;
                    this.addChild(t);

                    t = new PoolTile3(0x45);
                    t.y = y;
                    this.addChild(t);
*/

                    y = MAX_HEIGHT * .5 - (HEIGHT_13 * 13 + HEIGHT_13SF + GAP_T) * .5;
                    for (let i = 0; i < 14; ++i) {
                        let sp = createStandingTile3();
                        this.addChild(sp);
                        let yy = y + HEIGHT_13 * i + ((i != 13) ? 0 : GAP_T);
                        origin[3][i] = yy;
                        sp.y = yy;
                        standing[3][i] = sp;
                    }
                }

                // 对家
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect((MAX_WIDTH - HAND_WIDTH_02) * .5, 0, HAND_WIDTH_02, HAND_HEIGHT_02);
                    graph.endFill();
                    this.addChild(graph);

                    x = (MAX_WIDTH + HAND_WIDTH_02) * .5;
                    for (let i = 0; i < 4; ++i) {
                        for (let k = 0; k < 3; ++k) {
                            let t = new PoolTile2(0x41 + i);
                            x -= WIDTH_02;
                            t.x = x;
                            this.addChild(t);
                        }

                        let t = new PoolTile3(0x41 + i);
                        x -= WIDTH_13;
                        t.x = x;
                        x -= GAP_T;
                        this.addChild(t);
                    }

                    let t = new PoolTile2(0x45);
                    x -= WIDTH_02;
                    t.x = x;
                    x -= GAP_T;
                    this.addChild(t);

                    t = new PoolTile2(0x45);
                    x -= WIDTH_02;
                    t.x = x;
                    this.addChild(t);
*/

                    x = MAX_WIDTH * .5 + (WIDTH_02 * 14 + GAP_T) * .5;
                    for (let i = 0; i < 14; ++i) {
                        let sp = createStandingTile2();
                        this.addChild(sp);
                        let xx = x - WIDTH_02 * (i + 1) - ((i != 13) ? 0 : GAP_T);
                        origin[2][i] = xx;
                        sp.x = xx;
                        standing[2][i] = sp;
                    }
                }

                // 下家
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect(MAX_WIDTH - HAND_WIDTH_13, (MAX_HEIGHT - HAND_HEIGHT_13) * .5, HAND_WIDTH_13, HAND_HEIGHT_13);
                    graph.endFill();
                    this.addChild(graph);

                    y = (MAX_HEIGHT - HAND_HEIGHT_13) * .5;

                    let t = new PoolTile1(0x45);
                    t.x = MAX_WIDTH - WIDTH_13;
                    t.y = y;
                    y += HEIGHT_13 + GAP_T;
                    this.addChild(t);

                    t = new PoolTile1(0x45);
                    t.x = MAX_WIDTH - WIDTH_13;
                    t.y = y;
                    y += HEIGHT_13 + GAP_T;
                    this.addChild(t);

                    for (let i = 0; i < 4; ++i) {
                        for (let k = 0; k < 3; ++k) {
                            let t = new PoolTile1(0x41 + i);
                            t.x = MAX_WIDTH - WIDTH_13;
                            t.y = y;
                            y += HEIGHT_13;
                            this.addChild(t);
                        }

                        let t = new PoolTile0(0x41 + i);
                        t.x = MAX_WIDTH - WIDTH_02;
                        t.y = y;
                        y += HEIGHT_02 + GAP_T;
                        this.addChild(t);
                    }
*/

                    y = MAX_HEIGHT * .5 - (HEIGHT_13 * 13 + HEIGHT_13SF + GAP_T) * .5 + GAP_T;
                    for (let i = 0; i < 14; ++i) {
                        let sp = createStandingTile1();
                        this.addChild(sp);
                        sp.x = MAX_WIDTH - WIDTH_13S;
                        let yy = y + ((i != 0) ? HEIGHT_13 * i : -GAP_T);
                        origin[1][13 - i] = yy;
                        sp.y = yy;
                        standing[1][13 - i] = sp;
                    }
                }

                // 自己
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect((MAX_WIDTH - HAND_WIDTH_02) * .5, MAX_HEIGHT - HAND_HEIGHT_02, HAND_WIDTH_02, HAND_HEIGHT_02);
                    graph.endFill();
                    this.addChild(graph);
*/

                    x = (MAX_WIDTH - (WIDTH_02 * 14 + GAP_T) * HAND_SCALE) * .5;
                    for (let i = 0; i < 14; ++i) {
                        let sp = new StandingTile(i, (sp)=>{ this._click(sp); });
                        this.addChild(sp);
                        sp.scale.set(HAND_SCALE);
                        sp.anchor.y = 1;
                        sp.y = MAX_HEIGHT;
                        let xx = x + (WIDTH_02 * i + ((i != 13) ? 0 : GAP_T)) * HAND_SCALE;
                        origin[0][i] = xx;
                        sp.x = xx;
                        standing[0][i] = sp;
                    }
                }

                this.players_ = [{}, {}, {}, {}];
                this.origin_ = origin;
                this.standing_ = standing;
                this.packs_ = [[], [], [], []];
                this.packData_ = [[], [], [], []];
                this.flowers_ = [0, 0, 0, 0];
                this.falseWin_ = [false, false, false, false];
                this.seat_ = 0;
                this.turn_ = 0;
                this.activeTile_ = null;
                this.openTiles_ = [[], [], [], []];
                this.openPos_ = [0, 0, 0, 0];
                this.step_ = 0;
                this.stopFlower_ = false;
                this.rdfsh_ = false;

                let btn = this.settleBtn_ = new TextButton('结算面板', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 50, ()=>{ if (this.settleView_) { this.settleView_.visible = true; } });
                this.addChild(btn);
                btn.x = MAX_WIDTH - 120;
                btn.visible = false;

/*
                // TODO:
                btn = new TextButton('请求退出', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{ console.log('请求退出'); });
                this.addChild(btn);
*/

                btn = new TextButton('设置', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    if (this.sv_) {
                        this.removeChild(this.sv_);
                        this.sv_.removeChildren();
                    }

                    let sv = this.sv_ = new SettingView(()=>{
                        this.removeChild(this.sv_);
                        this.sv_.removeChildren();
                        delete this.sv_;
                    });
                    this.addChild(sv);
                    sv.x = (MAX_WIDTH - sv.width) * .5;
                    sv.y = (MAX_HEIGHT - sv.height) * .5;

                });
                this.addChild(btn);

                btn = new TextButton('计分表', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    this.toggleHistory();
                });
                this.addChild(btn);
                btn.y = MAX_HEIGHT - 220;

                btn = new TextButton('追分策略', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    this.toggleChase();
                });
                this.addChild(btn);
                btn.x = MAX_WIDTH - 120;
                btn.y = MAX_HEIGHT - 220;

                graph = this.cd_ = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0, .5);
                graph.drawCircle(25, 25, 50);
                graph.endFill();
                this.addChild(graph);
                graph.pivot.x = CENTER_WIDTH * .5;
                graph.pivot.y = CENTER_HEIGHT * .5;
                graph.x = MAX_WIDTH * .5;
                graph.y = MAX_HEIGHT * .5;
                this.addChild(graph);
                graph.x = MAX_WIDTH;
                graph.y = MAX_HEIGHT - 200;

                text = graph.text_ = new PIXI.Text('', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 48,
                    fill: '#dedede',
                    //stroke: '#0066ff',
                    //strokeThickness: 2,
                });
                text.anchor.set(.5);
                graph.addChild(text);
                text.x = 25;
                text.y = 25;
                graph.visible = false;

                // 吃碰杠和花过按钮，最多同时亮5个（吃碰杠和过）
                // 此处从右往左排
                let actionBtns = new Array(5);
                for (let i = 0; i < 5; ++i) {
                    let ab = actionBtns[i] = new ActionButton();
                    this.addChild(ab);
                    ab.x = MAX_WIDTH - 200 * i - 330;
                    ab.y = MAX_HEIGHT - 320;
                    ab.visible = false;
                }
                this.actionBtns_ = actionBtns;

                let view = this.historyView_ = new HistoryView();
                this.addChild(view);
                view.x = (MAX_WIDTH - view.width) * .5;
                view.y = (MAX_HEIGHT - view.height) * .5;
                view.visible = false;

                view = this.chaseView_ = new ChaseView();
                this.addChild(view);
                view.x = (MAX_WIDTH - view.width) * .5;
                view.y = (MAX_HEIGHT - view.height) * .5;
                view.visible = false;

                text = this.timeout_ = new PIXI.Text('你已超时，服务器自动托管，刷新页面可解除', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 50,
                    fill: '#dedede',
                    //stroke: '#0066ff',
                    //strokeThickness: 2,
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = MAX_WIDTH * .5;
                text.y = MAX_HEIGHT - 200;
                text.visible = false;
            }

            setupPool(t) {
                for (let i = 0; i < 4; ++i) {
                    let ti = t[(this.seat_ + i) & 3];
                    for (let k = 0; k < 24 && k < ti.length; ++k) {
                        let spk = this.pools_[i][k];
                        spk.visible = true;
                        spk.update(ti[k]);
                    }
                    for (let k = ti.length; k < 24; ++k) {
                        this.pools_[i][k].visible = false;
                    }
                }
            }

            clear() {
                for (let i = 0; i < 4; ++i) {
                    for (let k = 0; k < 24; ++k) {
                        let sp = this.pools_[i][k];
                        sp.visible = false;
                    }

                    if (showWall) {
                        for (let k = 0; k < 36; ++k) {
                            this.walls_[i][k].visible = true;
                        }
                    }

                    this.flowers_[i] = 0;
                    this.falseWin_[i] = false;
                    this.infoPanels_[i].reset();

                    let sp;
                    while (sp = this.packs_[i].pop()) {
                        this.removeChild(sp);
                    }

                    while (sp = this.openTiles_[i].pop()) {
                        this.removeChild(sp);
                    }

                    this.openPos_[i] = this.origin_[i][0];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[0][k];
                    sp.visible = false;
                    sp.x = this.origin_[0][k];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[1][k];
                    sp.visible = false;
                    sp.y = this.origin_[1][k];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[2][k];
                    sp.visible = false;
                    sp.x = this.origin_[2][k];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[3][k];
                    sp.visible = false;
                    sp.y = this.origin_[3][k];
                }

                if (this.activeTile_) {
                    this.activeTile_.visible = false;
                    this.removeChild(this.activeTile_);
                    this.activeTile_ = null;
                }

                this.packData_ = [[], [], [], []];
                this.stopFlower_ = false;
                this.timeout_.visible = false;
            }

            sendHandTiles(d, h) {
                this.rdfsh_ = false;
                this.closeSettleView();

                this.remainText_.text = '牌墙剩余：144';

                let seat = this.seat_;
                for (let i = 0; i < 4; ++i) {
                    let k = (seat + i) & 3;
                    this.windTexts_[i].text = WIND[k] + ' ' + this.players_[k]['s'];
                }
                this.setTurn(0);

                let dir = (d[0] + d[1] - 1 + 4 - seat) & 3;
                let off = d[0] + d[1] + d[2] + d[3];
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                this.backPier_ = off > 0 ? {'dir':dir,'off':off - 1,'down':false} : {'dir':(dir+1)&3,'off':17,'down':false};
                this.openPier_ = {'dir':dir, 'off':off, 'down':false};
                this.remainCnt_ = 144;

                // 骰子
                let dss = [null, null], zz = this.getChildIndex(this.windTexts_[0].parent) + 1;
                for (let i = 0; i < 2; ++i) {
                    let ds = createDice(d[i]);
                    this.addChildAt(ds, zz);
                    ds.x = 600 - 25 + i * 50;
                    ds.y = 450 - 25 + i * 50;
                    dss[i] = ds;
                }

                play_snd('snd/02-dice.wav');
                let dir2 = (d[0] + d[1] - 1 + 4) & 3;
                setTimeout(()=>{
                    this.removeChild(dss[0]);
                    this.removeChild(dss[1]);
                    this.setTurn(dir2);
                    play_snd('snd/02-dice.wav');

                    for (let i = 0; i < 2; ++i) {
                        let ds = createDice(d[i + 2]);
                        this.addChildAt(ds, zz);
                        ds.x = 600 - 25 + i * 50;
                        ds.y = 450 - 25 + i * 50;
                        dss[i] = ds;
                    }
                }, 1000);
                setTimeout(()=>{
                    this.removeChild(dss[0]);
                    this.removeChild(dss[1]);
                    this.setTurn(0);
                }, 2000);

                const DICE_TIME = 2000;

                // 每人3手*4张
                for (let i = 0; i < 12; ++i) {
                    for (let k = 0; k < 2; ++k) {
                        let sp1 = this.walls_[dir][off * 2];
                        setTimeout(()=>{
                            this.setTurn(i & 3);
                            --this.remainCnt_;
                            this._drawEffect((i + 4 - seat) & 3, sp1, (i & 0xFC) + k * 2);
                        }, DICE_TIME + i * DRAW_DT);

                        let sp2 = this.walls_[dir][off * 2 + 1];
                        setTimeout(()=>{
                            --this.remainCnt_;
                            this._drawEffect((i + 4 - seat) & 3, sp2, (i & 0xFC) + k * 2 + 1);
                        }, DICE_TIME + i * DRAW_DT);

                        ++off;
                        if (off >= 18) {
                            off -= 18;
                            dir = (dir + 3) & 3;
                        }
                    }
                }

                // 跳牌
                let sp1 = this.walls_[dir][off * 2];
                setTimeout(()=>{
                    this.setTurn(0);
                    --this.remainCnt_;
                    this._drawEffect((4 - seat) & 3, sp1, 12);
                }, DICE_TIME + 12 * DRAW_DT);

                let sp2 = this.walls_[dir][off * 2 + 1];
                setTimeout(()=>{
                    this.setTurn(1);
                    --this.remainCnt_;
                    this._drawEffect((5 - seat) & 3, sp2, 12);
                }, DICE_TIME + 13 * DRAW_DT);

                ++off;
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                let sp3 = this.walls_[dir][off * 2];
                setTimeout(()=>{
                    this.setTurn(2);
                    --this.remainCnt_;
                    this._drawEffect((6 - seat) & 3, sp3, 12);
                }, DICE_TIME + 14 * DRAW_DT);

                let sp4 = this.walls_[dir][off * 2 + 1];
                setTimeout(()=>{
                    this.setTurn(3);
                    --this.remainCnt_;
                    this._drawEffect((7 - seat) & 3, sp4, 12);
                }, DICE_TIME + 15 * DRAW_DT);

                ++off;
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                let sp5 = this.walls_[dir][off * 2];
                setTimeout(()=>{
                    --this.remainCnt_;
                    this._drawEffect((4 - seat) & 3, sp5, 13);
                }, DICE_TIME + 12 * DRAW_DT);

                this.frontPier_ = {'dir':dir,'off':off,'down':true};

                // 理牌
                for (let i = 0; i < 13; ++i) {
                    let sp = this.standing_[0][i];
                    sp.update(h[i]);
                }
                if (this.seat_ == 0) {
                    this.standing_[0][13].update(h[13]);
                }
                else {
                    this.standing_[0][13].t_ = 0xFF;
                }

                setTimeout(()=>{
                    this.setTurn(0);

                    let standing, origin, z;

                    // 上家
                    origin = this.origin_[3];
                    standing = this.standing_[3];
                    z = this.getChildIndex(standing[0]);
                    //for (let i = 0; i < 14; ++i) { console.log('bs 3 z', i, this.getChildIndex(standing[i])); }

                    shuffle_array(standing, 0, 13);
                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z + i);
                        if (sp.y != origin[i]) {
                            (new TWEEN.Tween(sp)).to({y:origin[i]}, SORT_DT).start();
                        }
                    }
                    //for (let i = 0; i < 14; ++i) { console.log('as 3 z', i, this.getChildIndex(standing[i])); }

                    // 对家
                    origin = this.origin_[2];
                    standing = this.standing_[2];
                    z = this.getChildIndex(standing[0]);
                    //for (let i = 0; i < 14; ++i) { console.log('bs 2 z', i, this.getChildIndex(standing[i])); }

                    shuffle_array(standing, 0, 13);
                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z + i);
                        if (sp.x != origin[i]) {
                            (new TWEEN.Tween(sp)).to({x:origin[i]}, SORT_DT).start();
                        }
                    }
                    //for (let i = 0; i < 14; ++i) { console.log('as 2 z', i, this.getChildIndex(standing[i])); }

                    // 下家
                    origin = this.origin_[1];
                    standing = this.standing_[1];
                    z = this.getChildIndex(standing[0]);
                    //for (let i = 0; i < 14; ++i) { console.log('bs 1 z', i, this.getChildIndex(standing[i])); }

                    shuffle_array(standing, 0, 13);
                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z - i);
                        if (sp.y != origin[i]) {
                            (new TWEEN.Tween(sp)).to({y:origin[i]}, SORT_DT).start();
                        }
                    }
                    //for (let i = 0; i < 14; ++i) { console.log('as 1 z', i, this.getChildIndex(standing[i])); }

                    // 自己
                    origin = this.origin_[0];
                    standing = this.standing_[0];
                    z = this.getChildIndex(standing[0]);
                    //for (let i = 0; i < 14; ++i) { console.log('bs 0 z', i, this.getChildIndex(standing[i])); }

                    standing.sort(function(a, b) { return a.t_ - b.t_; });
                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z + i);
                        if (sp.x != origin[i]) {
                            (new TWEEN.Tween(sp)).to({x:origin[i]}, SORT_DT).start();
                        }
                    }
                    //for (let i = 0; i < 14; ++i) { console.log('as 0 z', i, this.getChildIndex(standing[i])); }
                }, DICE_TIME + 18 * DRAW_DT);

                if (this.option_.status()[0] && this.seat_ == 0) {
                    setTimeout(()=>{
                        ws.send('{"m":2,"r":1,"v":0}');
                    }, DICE_TIME + 18 * DRAW_DT + SORT_DT + 100);
                }
            }

            sendHandTiles2(d, h) {
                let ww = this.width_, hh = this.height_, w2 = 500, h2 = 400;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.beginFill(0, 0);
                bg.drawRect(0, 0, ww, hh);
                bg.endFill();

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect((ww - w2) * .5, (hh - h2) * .5, w2, h2);
                bg.endFill();

                let text = new PIXI.Text(WIND[this.rd_ >> 2] + '风圈', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 128,
                    fill: '#ffffff',
                    fontWeight:'bold',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                text.anchor.set(.5);
                text.x = ww * .5;
                text.y = hh * .5;
                bg.addChild(text);

                (new TWEEN.Tween(bg)).to({alpha:0}, 200).delay(1800).start();

                setTimeout(()=>{ this.removeChild(bg); this.sendHandTiles(d, h); }, 2000);
                play_snd(this.rd_ ? 'snd/24-dingdong.wav' : 'snd/01-start.wav');
            }

            setTurn(t) {
                this.turn_ = t;
                let n = (t + 4 - this.seat_) & 3;
                for (let i = 0; i < 4; ++i) {
                    this.windTexts_[i].style.fill = (i != n) ? '#dedede' : '#ff6a6a';
                }
            }

            addCD(sec) {
                let cd = this.cd_;
                let t = cd.text_;
                if (t.timer_) {
                    clearInterval(t.timer_);
                    delete t.timer_;
                }
                t.text = sec;

                t.end_ = new Date().getTime() + sec * 1000;
                t.timer_ = setInterval(()=>{
                    let n = (t.end_ - new Date().getTime());
                    let s = Math.round(n / 1000);
                    if (s > 0) {
                        let tt = parseInt(t.text);
                        if (tt != s) {
                            t.text = s;
                            if (!mutecd && s <= 3) {
                                play_snd('snd/03-cd.wav');
                            }
                        }
                    }
                    else {
                        cd.visible = false;
                        clearInterval(t.timer_);
                        delete t.timer_;
                    }
                });
                cd.visible = true;
            }

            removeCD() {
                let cd = this.cd_;
                let t = cd.text_;
                if (t.timer_) {
                    clearInterval(t.timer_);
                    delete t.timer_;
                }
                cd.visible = false;
            }

            addBtns(actions) {
                let status = this.option_.status();

                if (!actions) {
                    if (status[6] && this.turn_ == this.seat_) {  // 自动摸打
                        setTimeout(()=>{
                            this._discard(this.standing_[0][13]);
                        }, DISCARD_DT + 1000);
                    }
                    return;
                }

                let dict = {}, size = 0;
                for (let i = 0, len = actions.length; i < len; ++i) {
                    let ac = actions[i];
                    let type = (ac >> 16) & 0xFFFF, data = (ac & 0xFFFF);
                    if (dict[type] == undefined) {
                        dict[type] = [data];
                        ++size;
                    } else {
                        dict[type].push(data);
                    }
                }
                if (size == 0) {
                    return;
                }

                if (status[0] && dict[1] && !this.stopFlower_ ) {  // 自动补花
                    setTimeout(()=>{
                        ws.send('{"m":2,"r":1,"v":0}');
                        this.removeCD();
                    }, DISCARD_DT * 2);
                    return;
                }

                if (status[1] && dict[3]) {  // 不吃
                    --size;
                    delete dict[3];
                }
                if (status[2] && dict[4]) {  // 不碰
                    --size;
                    delete dict[4];
                }
                if (status[3] && dict[5]) {  // 不杠
                    --size;
                    delete dict[5];
                }

                if (dict[6]) {
                    let skp = false;
                    if (status[4] && this.turn_ != this.seat_) {  // 只和自摸
                        --size;
                        delete dict[6];
                        skp = true;
                    }

                    if (!skp && status[5]) {  // 自动和牌
                        setTimeout(()=>{
                            ws.send('{"m":2,"r":6,"v":0}');
                            this.removeCD();
                        }, DISCARD_DT * 2);
                        return;
                    }
                }

                if (status[6]) {  // 自动摸打
                    if (!dict[6] && !dict[5] &&!dict[1] && this.turn_ == this.seat_) {
                        setTimeout(()=>{
                            this._discard(this.standing_[0][13]);
                        }, DISCARD_DT + 1000);
                        return;
                    }
                }

                if (size == 0) {
                    ws.send('{"m":2,"r":9,"v":0}');
                    this.removeCD();
                    return;
                }

                // 插入“过”
                dict[9] = [];
                ++size;

                const types = [9, 1, 6, 5, 4, 3];
                let cnt = 0;
                for (let i = 0; i < 6; ++i) {
                    let val = dict[types[i]];
                    if (val) {
                        let ab = this.actionBtns_[cnt];
                        ab.visible = true;
                        ab.setup(5 - i, (ab)=>{
                            //console.log(ab.data_);
                            switch (ab.data_.length) {
                            case 0:
                                this.removeBtns();
                                ws.send('{"m":2,"r":9,"v":0}');
                                this.removeCD();
                                break;
                            case 1:
                                this.removeBtns();
                                ws.send(`{"m":2,"r":${types[i]},"v":65535}`);
                                this.removeCD();
                                break;
                            default: {
                                let view = this.selectionView_;
                                if (view) {
                                    this.removeChild(view);
                                }
                                view = new SelectionView(types[i], ab.data_, (a)=>{
                                    ws.send(`{"m":2,"r":${types[i]},"v":${a}}`);
                                    this.removeBtns();
                                    this.removeCD();
                                });
                                this.addChild(view);
                                view.y = this.height_ - 450;
                                view.x = (this.width_ - view.width) * .5;
                                this.selectionView_ = view;
                                break;
                            }
                            }
                        });
                        ab.data_ = val;
                        ++cnt;
                    }
                }

                // 轮到自己打牌时，隐藏“过”
                if (this.turn_ == this.seat_ && this.isDiscarding_) {
                    this.actionBtns_[0].visible = false;
                    --cnt;
                }

                if (cnt > 0) {
                    play_snd('snd/08-inquire.wav');
                }
            }

            removeBtns() {
                let v = this.selectionView_;
                if (v) {
                    this.removeChild(v);
                    delete this.selectionView_;
                }

                for (let i = 0; i < 5; ++i) {
                    this.actionBtns_[i].visible = false;
                }
            }

            // 抓牌效果
            _drawEffect(n, wall, idx) {
                play_snd('snd/05-draw.wav');

                wall.visible = false;
                let sp = (n % 2 == 0) ? createWall02Tile() : createWall13Tile();
                this.addChild(sp);
                sp.anchor.set(.5);
                sp.x = wall.x + wall.width * .5;
                sp.y = wall.y + wall.height * .5;
                let dst = this.standing_[n][idx];
                let x = dst.x + dst.width * .5;
                let y = dst.y + dst.height * .5;

                switch (n) {
                case 0:
                    y = dst.y - dst.height * .5;
                    (new TWEEN.Tween(sp.scale)).to({x:HAND_SCALE, y:HAND_SCALE}, DRAW_DT).start();
                    break;
                case 1: x -= (WIDTH_13 - WIDTH_13S) * .5; break;
                case 3: x += (WIDTH_13 - WIDTH_13S) * .5; break;
                }

                (new TWEEN.Tween(sp)).to({x:x,y:y}, DRAW_DT).delay(10).onComplete(()=>{
                    this.removeChild(sp);
                    dst.visible = true;
                    this.remainText_.text = '牌墙剩余：' + this.remainCnt_;
                }).start();
            }

            _discardEffect(n, o, p) {
                let a = (n & 1) ? 'y' : 'x';
                let sgn = (n != 1) ? 1 : -1;
                let standing = this.standing_[n];
                let dp = new Array(14);
                for (let i = 0; i < 14; ++i) {
                    dp[i] = standing[i][a];
                }
                let z = this.getChildIndex(standing[0]);

                if (o < p) {
                    let tmp = standing[o];
                    for (let i = o; i < p; ++i) {
                        standing[i] = standing[i + 1];
                    }
                    standing[p] = standing[13];
                    standing[13] = tmp;
                } else if (o > p) {
                    let tmp = standing[o];
                    for (let i = o; i > p; --i) {
                        standing[i] = standing[i - 1];
                    }
                    standing[p] = standing[13];
                    standing[13] = tmp;
                } else {
                    let tmp = standing[o];
                    standing[o] = standing[13];
                    standing[13] = tmp;
                }

                for (let i = 0; i < 14; ++i) {
                    let sp = standing[i];
                    this.setChildIndex(sp, z + sgn * i);
                    if (sp[a] != dp[i]) {
                        let dst = {};
                        dst[a] = dp[i];
                        (new TWEEN.Tween(sp)).to(dst, DISCARD_DT).start();
                    }
                }
            }

            _findPoolDest(n) {
                for (let k = 0; k < 24; ++k) {
                    let sp = this.pools_[n][k];
                    if (!sp.visible) {
                        return sp;
                    }
                }
                return null;
            }

            _randomIdx(n) {
                let hd = this.packData_[n].length * 3;
                if (hd < 12) {
                    return Math.floor(Math.random() * (13 - hd)) + hd;
                }
                return 12;
            }

            _findIdx(b, t) {
                let standing = this.standing_[0];
                for (let i = b, len = standing.length; i < len; ++i) {
                    let sp = standing[i];
                    if (sp.visible && sp.t_ == t) {
                        return i;
                    }
                }
                return -1;
            }

            _findIdxA(b, t) {
                let standing = this.standing_[0];
                for (let i = b, len = standing.length; i < len; ++i) {
                    let sp = standing[i];
                    if (sp.visible && (sp.t_ & 0xFC) == (t & 0xFC)) {
                        return i;
                    }
                }
                return -1;
            }

            _findIdxN(b, t) {
                let standing = this.standing_[0];
                for (let i = b, len = standing.length; i < len; ++i) {
                    let sp = standing[i];
                    if (sp.visible && (sp.t_ & 0xFC) == (t & 0xFC) && (sp.t_ != t)) {
                        return i;
                    }
                }
                return -1;
            }

            discard(n, t, h) {
                play_snd('snd/06-discard.wav');
                this.removeCD();
                this.removeBtns();

                this.removeActive();

                let standing = this.standing_[n];
                if (!standing[13].visible) {
                    console.log('standing 13 is not visible', n);
                    standing[13].visible = true;
                }

                let dst = this._findPoolDest(n);
                if (dst == null) {
                    console.log('dst is null', n);
                    return;
                }

                let idx;
                if (n) {
                    idx = h ? this._randomIdx(n) : 13;
                }
                else {
                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        if (sp.visible && sp.t_ == t) {
                            idx = i;
                            break;
                        }
                    }
                }
                let src = standing[idx];
                if (src == undefined) {
                    console.log('ui error');
                    reenter();
                    return;
                }
                src.visible = false;

                dst.update(t);

                let sp = new (CTOR_PT[n])(t);
                sp.x = src.x;
                sp.y = src.y;
                if (n == 1) sp.x -= (WIDTH_13 - WIDTH_13S);
                else if (n == 0) sp.y -= src.height;
                this.activeTile_ = sp;
                this.addChildAt(sp, this.getChildIndex(dst));
                sp.dst_ = dst;
                (new TWEEN.Tween(sp)).to({x:(dst.x + DOX[n]),y:(dst.y + DOY[n])}, DISCARD_DT).start();
                if (n == 0) {
                    sp.scale.set(HAND_SCALE);
                    (new TWEEN.Tween(sp.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    this.stopFlower_ = false;
                }

                if (idx != 13) {
                    // 插入手牌的动画
                    if (n) {
                        setTimeout(()=>{
                            this._discardEffect(n, idx, 12);
                            standing[idx].visible = true;
                            standing[13].visible = false;
                        }, DISCARD_DT);
                    }
                    else {
                        let z = this.getChildIndex(standing[0]);
                        let dp = new Array(14);
                        for (let i = 0; i < 14; ++i) {
                            dp[i] = standing[i].x;
                        }

                        src.t_ = 0xFF;
                        src.visible = false;
                        standing.sort(function(a, b) { return a.t_ - b.t_; });

                        for (let i = 0; i < 14; ++i) {
                            let sp = standing[i];
                            this.setChildIndex(sp, z + i);
                            if (sp.x != dp[i]) {
                                (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                            }
                        }
                    }
                }
            }

            _discard(sp) {
                //this.discard(0, sp);
                let t = sp.t_;
                if (t != 0xFF && this.standing_[0][13].visible) {
                    ws.send(`{"m":2,"r":2,"v":${t}}`);
                    this.removeCD();
                }
            }

            _click(sp) {
                let standing = this.standing_[0];
                if (sp.isHighlight()) {
                    this._discard(sp);
                    sp.setHighlight(false);
                }
                else {
                    for (let i = 0; i < 14; ++i) {
                        let st = standing[i];
                        st.setHighlight(st == sp);
                    }
                }

                if (this.piano_.visible) {
                    this.piano_.refresh();
                }
            }

            _drawTileF(n) {
                let pier = this.frontPier_;
                let dir = pier['dir'];
                let off = pier['off'];

                let pierB = this.backPier_;
                if (!pier['down']) {
                    let wt = this.walls_[dir][off * 2];
                    if (n != undefined) {
                        this._drawEffect(n, wt, 13);
                    }
                    else {
                        wt.visible = false;
                    }

                    this.frontPier_['down'] = true;
                    if (pierB['dir'] == pier['dir'] && pierB['off'] == pier['off']) {
                        this.backPier_['down'] = true;
                    }
                }
                else {
                    let wt = this.walls_[dir][off * 2 + 1];
                    if (n != undefined) {
                        this._drawEffect(n, wt, 13);
                    }
                    else {
                        wt.visible = false;
                    }

                    ++off;
                    if (off >= 18) {
                        off -= 18;
                        dir = (dir + 3) & 3;
                    }
                    this.frontPier_ = {
                        'dir':dir,
                        'off':off,
                        'down':((pierB['dir'] != dir || pierB['off'] != off) ? false : pierB['down'])
                    };
                }
            }

            _drawTileB(n, idx) {
                let pier = this.backPier_;
                let dir = pier['dir'];
                let off = pier['off'];

                let pierF = this.frontPier_;
                if (!pier['down']) {
                    let wt = this.walls_[dir][off * 2];
                    if (n != undefined) {
                        this._drawEffect(n, wt, idx);
                    }
                    else {
                        wt.visible = false;
                    }

                    this.backPier_['down'] = true;
                    if (pierF['dir'] == pier['dir'] && pierF['off'] == pier['off']) {
                        this.frontPier_['down'] = true;
                    }
                }
                else {
                    let wt = this.walls_[dir][off * 2 + 1];
                    if (n != undefined) {
                        this._drawEffect(n, wt, idx);
                    }
                    else {
                        wt.visible = false;
                    }

                    if (off > 0) {
                        --off;
                    }
                    else {
                        off = 17;
                        dir = (dir + 1) & 3;
                    }
                    this.backPier_ = {
                        'dir':dir,
                        'off':off,
                        'down':((pierF['dir'] != dir || pierF['off'] != off) ? false : pierF['down'])
                    };
                }
            }

            draw(n, b, t, rm) {
                this.removeBtns();

                this.setTurn((this.seat_ + n) & 3);
                this.remainCnt_ = rm;

                let sp = this.activeTile_;
                if (sp) {
                    let dst = sp.dst_;
                    if (dst) {
                        // 普通打牌
                        (new TWEEN.Tween(sp)).to({x:dst.x,y:dst.y}, DISCARD_DT).onComplete(()=>{
                            dst.visible = true;
                            this.removeChild(sp);
                            this.activeTile_ = null;
                        }).start();
                    }
                    else {
                        // 加杠
                        (new TWEEN.Tween(sp)).to({x:sp.dstx_,y:sp.dsty_}, DISCARD_DT).onComplete(()=>{
                            this.activeTile_ = null;
                        }).start();
                    }
                }

                // 摸牌动画
                if (!this.standing_[n][13].visible) {
                    if (n == 0) {
                        this.standing_[n][13].update(t);
                    }
                    !b ? this._drawTileF(n) : this._drawTileB(n, 13);
                }
            }

            removeActive() {
                let sp = this.activeTile_;
                if (sp) {
                    console.log('active tile is not null');

                    let dst = sp.dst_;
                    if (dst) {
                        // 普通打牌
                        sp.visible = false;
                        dst.visible = true;
                        this.removeChild(sp);
                    }
                    else {
                        // 加杠
                        sp.x = sp.dstx_;
                        sp.y = sp.dsty_;
                    }
                    this.activeTile_ = null;
                }
            }

            showCallText(n, s) {
                let pos = this.callTextPos_[n];
                let text = new PIXI.extras.BitmapText(s, { font:'128px STXingkai' });
                text.anchor.x = pos['ax'];
                text.anchor.y = pos['ay'];
                text.x = pos['x'];
                text.y = pos['y'];
                this.addChild(text);

                text.scale.set(2);
                (new TWEEN.Tween(text)).to({alpha:1}, 100).start();
                (new TWEEN.Tween(text.scale)).to({x:1,y:1}, 100).onComplete(()=>{
                    (new TWEEN.Tween(text)).to({alpha:0}, 100).delay(1200).start();
                    (new TWEEN.Tween(text.scale)).to({x:2,y:2}, 100).delay(1200).onComplete(()=>{
                        this.removeChild(text);
                    }).start();
                }).start();
            }

            flower123(n, rm) {
                this.showCallText(n, '花');
                this.infoPanels_[n].setFlower(++this.flowers_[n]);
                this.remainCnt_ = rm;

                let standing = this.standing_[n];
                if (standing[13].visible) {
                    standing[13].visible = false;
                    this._drawTileB(n, 13);
                }
                else {
                    let idx = this._randomIdx(n);
                    this._drawTileB(n, idx);

                    // 动画
                    let dp = new Array(14);
                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        dp[i] = {'x':sp.x, 'y':sp.y};
                    }

                    let pos = this._randomIdx(n);
                    if (pos > idx) {
                        for (let i = idx; i < pos; ++i) {
                            standing[i].x = dp[i + 1]['x'];
                            standing[i].y = dp[i + 1]['y'];
                            (new TWEEN.Tween(standing[i])).to(dp[i], DISCARD_DT).delay(DISCARD_DT).start();
                        }
                    }
                    else if (pos < idx) {
                        for (let i = pos + 1; i < idx; ++i) {
                            standing[i].x = dp[i + 1]['x'];
                            standing[i].y = dp[i + 1]['y'];
                            (new TWEEN.Tween(standing[i])).to(dp[i], DISCARD_DT).delay(DISCARD_DT).start();
                        }
                    }

                    standing[idx].visible = false;
                }
            }

            flower0(ot, nt, rm) {
                this.showCallText(0, '花');
                this.infoPanels_[0].setFlower(++this.flowers_[0]);
                this.remainCnt_ = rm;

                let idx = this._findIdx(0, ot);
                if (idx == -1) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[0];
                let dp = new Array(14);
                for (let i = 0; i < 14; ++i) {
                    dp[i] = standing[i].x;
                }
                let z = this.getChildIndex(standing[0]);

                let src = standing[idx];
                src.t_ = 0xFF;
                src.visible = false;

                this.stopFlower_ = false;

                if (idx == 13) {
                    this._drawTileB(0, 13);
                    standing[13].update(nt);
                }
                else if (standing[13].visible) {
                    standing[idx].t_ = 0xFF;
                    standing.sort(function(a, b) { return a.t_ - b.t_; });

                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z + i);
                        if (sp.x != dp[i]) {
                            (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                        }
                    }

                    this._drawTileB(0, 13);
                    standing[13].update(nt);
                }
                else {
                    standing[13].t_ = 0xFF;

                    this._drawTileB(0, idx);
                    standing[idx].update(nt);
                    standing.sort(function(a, b) { return a.t_ - b.t_; });

                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z + i);
                        if (sp.x != dp[i]) {
                            (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                        }
                    }
                }
            }

            _shrink(n, ext, hidden, indices) {
                let a = (n & 1) ? 'y' : 'x';
                let sgn = (n==1) ? -1 : 1;
                let standing = this.standing_[n];
                let z = this.getChildIndex(standing[0]);

                // 移动余下立牌
                let dp = new Array(14);
                for (let i = 0; i < 14; ++i) {
                    dp[i] = standing[i][a] + ext;
                }

                for (let i = 0; i < 3; ++i) {
                    let tmp = standing[indices[i]];
                    for (let k = indices[i]; k > 0; --k) {
                        standing[k] = standing[k - 1];
                    }
                    standing[0] = tmp;
                    tmp.t_ = -1;
                }

                if (indices.length == 4) {
                    let tmp = standing[indices[3]];
                    for (let k = indices[3]; k < 13; ++k) {
                        standing[k] = standing[k + 1];
                    }
                    standing[13] = tmp;
                    tmp.t_ = -1;
                }

                for (let i = 0; i < 14; ++i) {
                    let sp = standing[i];
                    this.setChildIndex(sp, z + sgn * i);
                    if (i < hidden) {
                        sp.visible = false;
                        sp[a] = dp[i];
                    }
                    else {
                        sp.visible = true;
                        let dst = {};
                        dst[a] = dp[i];
                        (new TWEEN.Tween(sp)).to(dst, DISCARD_DT).start();
                    }
                }
            }

            cpk3(pack) {
                let type = pack_get_type(pack);
                let tile = pack_get_tile(pack);

                this.removeBtns();
                this.removeCD();

                let hidden = this.packData_[3].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[3];
                let ext = (type != 2) ? EXT_CP_13 : EXT_DK_13;

                // 立牌往下，已有的副露往上
                this.openPos_[3] += ext;
                let prev = this.packs_[3];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y - ext)}, DISCARD_DT).start();
                }

                let idx1 = this._randomIdx(3);
                let idx2, idx3;
                do { idx2 = this._randomIdx(3); } while (idx1 == idx2);

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0:
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default: t0 = new PoolTile0(tile - 4); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile + 4); break;
                    case 2: t0 = new PoolTile0(tile); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile + 4); break;
                    case 3: t0 = new PoolTile0(tile + 4); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile); break;
                    }
                    break;
                case 1:
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t2.pr_ = true; break;
                    }
                    break;
                case 2:
                    do { idx3 = this._randomIdx(1); } while (idx1 == idx3 || idx2 == idx3);
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                    case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                    case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile2(tile); break;
                    }
                    break;
                }

                let z = this.getChildIndex(standing[0]);

                this.addChildAt(t0, z);
                this.addChildAt(t1, z + 1);
                this.addChildAt(t2, z + 2);
                if (type == 2) this.addChildAt(t3, z + 3);

                this.packs_[3].push(t0);
                this.packs_[3].push(t1);
                this.packs_[3].push(t2);
                if (type == 2) this.packs_[3].push(t3);

                // 动画
                let yy = standing[hidden + 3].y + ext - GAP_T;

                // 来源牌
                let req = this.activeTile_;
                this.activeTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.y = standing[idx1].y;
                    t2.y = standing[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 2 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    else {
                        t3.y = standing[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 3 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 * 3)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.y = standing[idx1].y;
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.y = standing[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 2 - HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    else {
                        t3.y = standing[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 3 - HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 * 2 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.y = standing[idx1].y;
                    t1.y = standing[idx2].y;
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_02 - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_02 - HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_02),x:0}, DISCARD_DT).start();
                    }
                    else {
                        t2.y = standing[idx3].y;
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_02 - HEIGHT_13 * 3)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_02 - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_02 - HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy - HEIGHT_02),x:0}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.visible = false;
                    this.removeChild(req);
                }

                this.packData_[3].push(pack);

                this._shrink(3, ext, hidden + 3, [idx1, idx2, idx3]);
                if (type == 2) standing[13].visible = false;
                else this.setTurn((this.seat_ + 3) & 3);

                play_snd('snd/09-cpk.wav');
            }

            ck3(h) {
                let hidden = this.packData_[3].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[3];
                let ext = EXT_CK_13;

                // 立牌往下，已有的副露往上
                this.openPos_[3] += ext;
                let prev = this.packs_[3];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y - ext)}, DISCARD_DT).start();
                }

                let idx = [this._randomIdx(3), 0, 0, 13];
                do { idx[1] = this._randomIdx(3); } while (idx[1] == idx[0]);
                do { idx[2] = this._randomIdx(3); } while (idx[2] == idx[0] || idx[2] == idx[1]);
                if (h) do { idx[3] = this._randomIdx(3); } while (idx[3] == idx[0] || idx[3] == idx[1] || idx[3] == idx[2]);

                // 生成一组副露
                let z = this.getChildIndex(standing[0]);
                let yy = standing[hidden + 3].y + ext - GAP_T;

                for (let i = 0; i < 4; ++i) {
                    let t = createWall13Tile();
                    if (i == 1 || i == 2) t.ck_ = true;
                    this.addChildAt(t, z + i);
                    this.packs_[3].push(t);

                    t.y = standing[idx[i]].y;
                    (new TWEEN.Tween(t)).to({y:yy - HEIGHT_13 * (4 - i)}, DISCARD_DT).start();
                }

                this.packData_[3].push(0x300);
                this._shrink(3, ext, hidden + 3, idx);
                standing[13].visible = false;

                play_snd('snd/09-cpk.wav');
            }

            pk3(pack, h) {
                let tile = pack_get_tile(pack);

                let prev = this.packs_[3];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = h ? this._randomIdx(3) : 13;
                let src = this.standing_[3][idx];

                let sp = (pr instanceof PoolTile0) ? new PoolTile0(tile) : new PoolTile2(tile);
                let z = this.getChildIndex(pr);
                this.addChildAt(sp, z);
                this.packs_[3].push(sp);

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y;
                (new TWEEN.Tween(sp)).to({x:(pr.x + WIDTH_02 + 10),y:(pr.y)}, DISCARD_DT).start();
                sp.dstx_ = pr.x + WIDTH_02;
                sp.dsty_ = pr.y;
                this.activeTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    setTimeout(()=>{
                        this._discardEffect(3, idx, 12);
                        this.standing_[3][13].visible = false;
                    }, DISCARD_DT);
                }

                play_snd('snd/09-cpk.wav');
            }

            cpk2(pack) {
                let type = pack_get_type(pack);
                let tile = pack_get_tile(pack);

                this.removeBtns();
                this.removeCD();

                let hidden = this.packData_[2].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[2];
                let ext = (type != 2) ? EXT_CP_02 : EXT_DK_02;

                // 立牌往左，已有的副露往右
                this.openPos_[2] -= ext;
                let prev = this.packs_[2];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({x:(sp.x + ext)}, DISCARD_DT).start();
                }

                let idx1 = this._randomIdx(2);
                let idx2, idx3;
                do { idx2 = this._randomIdx(2); } while (idx1 == idx2);

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0:
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default: t0 = new PoolTile3(tile - 4); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile + 4); break;
                    case 2: t0 = new PoolTile3(tile); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile + 4); break;
                    case 3: t0 = new PoolTile3(tile + 4); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile); break;
                    }
                    break;
                case 1:
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t2.pr_ = true; break;
                    }
                    break;
                case 2:
                    do { idx3 = this._randomIdx(1); } while (idx1 == idx3 || idx2 == idx3);
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                    case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                    case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile1(tile); break;
                    }
                    break;
                }

                let z = this.getChildIndex(standing[13]);

                this.addChildAt(t0, z + 1);
                this.addChildAt(t1, z + 1);
                this.addChildAt(t2, z + 1);
                if (type == 2) this.addChildAt(t3, z + 1);

                this.packs_[2].push(t0);
                this.packs_[2].push(t1);
                this.packs_[2].push(t2);
                if (type == 2) this.packs_[2].push(t3);

                // 动画
                let xx = standing[hidden + 3].x - ext + GAP_T + WIDTH_02;

                // 来源牌
                let req = this.activeTile_;
                this.activeTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.x = standing[idx1].x;
                    t2.x = standing[idx2].x;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 * 2),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = standing[idx3].x;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 * 3),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.x = standing[idx1].x;
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.x = standing[idx2].x;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = standing[idx3].x;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 * 2 + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02 * 2),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.x = standing[idx1].x;
                    t1.x = standing[idx2].x;
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_13 + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx),y:0}, DISCARD_DT).start();
                    }
                    else {
                        t2.x = standing[idx3].x;
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_13 + WIDTH_02 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13 + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx),y:0}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.visible = false;
                    this.removeChild(req);
                }

                this.packData_[2].push(pack);
                this._shrink(2, -ext, hidden + 3, [idx1, idx2, idx3]);
                if (type == 2) standing[13].visible = false;
                else this.setTurn((this.seat_ + 2) & 3);

                play_snd('snd/09-cpk.wav');
            }

            ck2(h) {
                let hidden = this.packData_[2].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[2];
                let ext = EXT_CK_02;

                // 立牌往左，已有的副露往右
                this.openPos_[2] -= ext;
                let prev = this.packs_[2];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({x:(sp.x + ext)}, DISCARD_DT).start();
                }

                let idx = [this._randomIdx(2), 0, 0, 13];
                do { idx[1] = this._randomIdx(2); } while (idx[1] == idx[0]);
                do { idx[2] = this._randomIdx(2); } while (idx[2] == idx[0] || idx[2] == idx[1]);
                if (h) do { idx[3] = this._randomIdx(2); } while (idx[3] == idx[0] || idx[3] == idx[1] || idx[3] == idx[2]);

                // 生成一组副露
                let z = this.getChildIndex(standing[13]);
                let xx = standing[hidden + 3].x - ext + GAP_T + WIDTH_02;

                for (let i = 0; i < 4; ++i) {
                    let t = createWall02Tile();
                    if (i == 1 || i == 2) t.ck_ = true;
                    this.addChildAt(t, z + 1);
                    this.packs_[2].push(t);

                    t.x = standing[idx[i]].x;
                    (new TWEEN.Tween(t)).to({x:(xx + WIDTH_02 * i)}, DISCARD_DT).start();
                }

                this.packData_[2].push(0x300);
                this._shrink(2, -ext, hidden + 3, idx);
                standing[13].visible = false;

                play_snd('snd/09-cpk.wav');
            }

            pk2(pack, h) {
                let tile = pack_get_tile(pack);

                let prev = this.packs_[2];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = h ? this._randomIdx(2) : 13;
                let src = this.standing_[2][idx];

                let sp = (pr instanceof PoolTile3) ? new PoolTile3(tile) : new PoolTile1(tile);
                let z = this.getChildIndex(pr);
                this.addChildAt(sp, z + 1);
                this.packs_[2].push(sp);

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y;
                (new TWEEN.Tween(sp)).to({x:pr.x,y:(pr.y + HEIGHT_13 + 10)}, DISCARD_DT).start();
                sp.dstx_ = pr.x;
                sp.dsty_ = pr.y + HEIGHT_13;
                this.activeTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    setTimeout(()=>{
                        this._discardEffect(2, idx, 12);
                        this.standing_[2][13].visible = false;
                    }, DISCARD_DT);
                }

                play_snd('snd/09-cpk.wav');
            }

            cpk1(pack) {
                let type = pack_get_type(pack);
                let tile = pack_get_tile(pack);

                this.removeBtns();
                this.removeCD();

                let hidden = this.packData_[1].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[1];
                let ext = (type != 2) ? EXT_CP_13 : EXT_DK_13;

                // 立牌往上，已有的副露往下
                this.openPos_[1] -= ext;
                let prev = this.packs_[1];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y + ext)}, DISCARD_DT).start();
                }

                let xx = standing[0].x;

                let idx1 = this._randomIdx(1);
                let idx2, idx3;
                do { idx2 = this._randomIdx(1); } while (idx1 == idx2);

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0:
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default: t0 = new PoolTile2(tile - 4); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile + 4); break;
                    case 2: t0 = new PoolTile2(tile); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile + 4); break;
                    case 3: t0 = new PoolTile2(tile + 4); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile); break;
                    }
                    break;
                case 1:
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t2.pr_ = true; break;
                    }
                    break;
                case 2:
                    do { idx3 = this._randomIdx(1); } while (idx1 == idx3 || idx2 == idx3);
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                    case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                    case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile0(tile); break;
                    }
                    break;
                }

                let z = this.getChildIndex(standing[0]);

                this.addChildAt(t0, z + 1);
                this.addChildAt(t1, z + 1);
                this.addChildAt(t2, z + 1);
                if (type == 2) this.addChildAt(t3, z + 1);

                this.packs_[1].push(t0);
                this.packs_[1].push(t1);
                this.packs_[1].push(t2);
                if (type == 2) this.packs_[1].push(t3);

                // 动画
                let yy = standing[hidden + 3].y - ext + GAP_T + HEIGHT_13 * 2;

                // 来源牌
                let req = this.activeTile_;
                this.activeTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.x = xx - (WIDTH_13 - WIDTH_13S); t1.y = standing[idx1].y;
                    t2.x = t1.x; t2.y = standing[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 * 2),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = t1.x; t3.y = standing[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 * 3),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.x = xx - (WIDTH_13 - WIDTH_13S); t0.y = standing[idx1].y;
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.x = t0.x; t2.y = standing[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = t0.x; t3.y = standing[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 * 2 + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13 * 2),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.x = xx - (WIDTH_13 - WIDTH_13S); t0.y = standing[idx1].y;
                    t1.x = t0.x; t1.y = standing[idx2].y;
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_02 + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                    }
                    else {
                        t2.x = t0.x; t2.y = standing[idx3].y;
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_02 + HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_02 + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.visible = false;
                    this.removeChild(req);
                }

                this.packData_[1].push(pack);

                this._shrink(1, -ext, hidden + 3, [idx1, idx2, idx3]);
                if (type == 2) standing[13].visible = false;
                else this.setTurn((this.seat_ + 1) & 3);

                play_snd('snd/09-cpk.wav');
            }

            ck1(h) {
                let hidden = this.packData_[1].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[1];
                let ext = EXT_CK_13;

                // 立牌往上，已有的副露往下
                this.openPos_[1] -= ext;
                let prev = this.packs_[1];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y + ext)}, DISCARD_DT).start();
                }

                let xx = standing[0].x;

                let idx = [this._randomIdx(1), 0, 0, 13];
                do { idx[1] = this._randomIdx(1); } while (idx[1] == idx[0]);
                do { idx[2] = this._randomIdx(1); } while (idx[2] == idx[0] || idx[2] == idx[1]);
                if (h) do { idx[3] = this._randomIdx(1); } while (idx[3] == idx[0] || idx[3] == idx[1] || idx[3] == idx[2]);

                // 生成一组副露
                let z = this.getChildIndex(standing[0]);
                let yy = standing[hidden + 3].y - ext + GAP_T;

                for (let i = 0; i < 4; ++i) {
                    let t = createWall13Tile();
                    if (i == 1 || i == 2) t.ck_ = true;
                    this.addChildAt(t, z + 1);
                    this.packs_[1].push(t);

                    t.x = xx - (WIDTH_13 - WIDTH_13S); t.y = standing[idx[i]].y;
                    (new TWEEN.Tween(t)).to({y:(yy + HEIGHT_13 * (5 - i))}, DISCARD_DT).start();
                }

                this.packData_[1].push(0x300);
                this._shrink(1, -ext, hidden + 3, idx);
                standing[13].visible = false;

                play_snd('snd/09-cpk.wav');
            }

            pk1(pack, h) {
                let tile = pack_get_tile(pack);

                let prev = this.packs_[1];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = h ? this._randomIdx(1) : 13;
                let src = this.standing_[1][idx];

                let sp = (pr instanceof PoolTile2) ? new PoolTile2(tile) : new PoolTile0(tile);
                let z = this.getChildIndex(pr);
                this.addChildAt(sp, z);
                this.packs_[1].push(sp);

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y;
                (new TWEEN.Tween(sp)).to({x:(pr.x - WIDTH_02 - 10),y:pr.y}, DISCARD_DT).start();
                sp.dstx_ = pr.x - WIDTH_02;
                sp.dsty_ = pr.y;
                this.activeTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    setTimeout(()=>{
                        this._discardEffect(1, idx, 12);
                        this.standing_[1][13].visible = false;
                    }, DISCARD_DT);
                }

                play_snd('snd/09-cpk.wav');
            }

            cpk0(pack) {
                let type = pack_get_type(pack);
                let tile = pack_get_tile(pack);

                this.removeCD();

                let hidden = this.packData_[0].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[0];
                let idx1, idx2, idx3;

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0: {
                    let tt0 = tile - 4 + ((pack >> 10) & 3);
                    let tt1 = tile + ((pack >> 12) & 3);
                    let tt2 = tile + 4 + ((pack >> 14) & 3);
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default:
                        idx1 = this._findIdx(0, tt1); idx2 = this._findIdx(0, tt2);
                        t0 = new PoolTile1(tt0); t1 = new PoolTile0(tt1); t2 = new PoolTile0(tt2);
                        break;
                    case 2:
                        idx1 = this._findIdx(0, tt0); idx2 = this._findIdx(0, tt2);
                        t0 = new PoolTile1(tt1); t1 = new PoolTile0(tt0); t2 = new PoolTile0(tt2);
                        break;
                    case 3:
                        idx1 = this._findIdx(0, tt0); idx2 = this._findIdx(0, tt1);
                        t0 = new PoolTile1(tt2); t1 = new PoolTile0(tt0); t2 = new PoolTile0(tt1);
                        break;
                    }
                    break;
                }
                case 1: {
                    let tm = tile + ((pack >> 10) & 3);
                    idx1 = this._findIdxN(0, tm);
                    idx2 = this._findIdxN(idx1 + 1, tm);
                    idx3 = 13;
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t2.pr_ = true; break;
                    }
                    break;
                }
                case 2:
                    this.stopFlower_ = true;
                    idx1 = this._findIdxA(0, tile);
                    idx2 = this._findIdxA(idx1 + 1, tile);
                    idx3 = this._findIdxA(idx2 + 1, tile);
                    switch (pack_get_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                    case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                    case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile3(tile); break;
                    }
                    break;
                }

                let z = this.getChildIndex(standing[13]);

                this.addChildAt(t0, z + 1);
                this.addChildAt(t1, z + 1);
                this.addChildAt(t2, z + 1);
                if (type == 2) this.addChildAt(t3, z + 1);

                this.packs_[0].push(t0);
                this.packs_[0].push(t1);
                this.packs_[0].push(t2);
                if (type == 2) this.packs_[0].push(t3);

                // 动画
                let xx = this.openPos_[0];
                let yy = standing[0].y;

                // 来源牌
                let req = this.activeTile_;
                this.activeTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.x = standing[idx1].x; t1.y = yy - HEIGHT_02F * HAND_SCALE; t1.scale.set(HAND_SCALE);
                    t2.x = standing[idx2].x; t2.y = yy - HEIGHT_02F * HAND_SCALE; t2.scale.set(HAND_SCALE);
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_13 + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = standing[idx3].x; t3.y = yy - HEIGHT_02F * HAND_SCALE; t3.scale.set(HAND_SCALE);
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_13 + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx + WIDTH_13 + WIDTH_02 * 2),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.x = standing[idx1].x; t0.y = yy - HEIGHT_02F * HAND_SCALE; t0.scale.set(HAND_SCALE);
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.x = standing[idx2].x; t2.y = yy - HEIGHT_02F * HAND_SCALE; t2.scale.set(HAND_SCALE);
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = standing[idx3].x; t3.y = yy - HEIGHT_02F * HAND_SCALE; t3.scale.set(HAND_SCALE);
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx + WIDTH_02 * 2 + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.x = standing[idx1].x; t0.y = yy - HEIGHT_02F * HAND_SCALE; t0.scale.set(HAND_SCALE);
                    t1.x = standing[idx2].x; t1.y = yy - HEIGHT_02F * HAND_SCALE; t1.scale.set(HAND_SCALE);
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 * 2),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    else {
                        t2.x = standing[idx3].x; t2.y = yy - HEIGHT_02F * HAND_SCALE; t2.scale.set(HAND_SCALE);
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 * 2),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx + WIDTH_02 * 3),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.visible = false;
                    this.removeChild(req);
                }

                this.packData_[0].push(pack);
                this._shrink(0, 0, hidden + 3, [idx1, idx2, idx3]);
                if (type != 2) {
                    this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * 2 + GAP_T;
                    this.setTurn(this.seat_);
                    this.addCD(this.cfg_['r30']);
                }
                else {
                    this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * 3 + GAP_T;
                    standing[13].visible = false;
                }

                play_snd('snd/09-cpk.wav');
            }

            ck0(pack) {
                let hidden = this.packData_[0].length * 3;
                if (hidden >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let standing = this.standing_[0];
                let tile = pack_get_tile(pack);

                let idx = [0, 0, 0, 0];
                idx[0] = this._findIdxA(0, tile);
                idx[1] = this._findIdxA(idx[0] + 1, tile);
                idx[2] = this._findIdxA(idx[1] + 1, tile);
                idx[3] = this._findIdxA(idx[2] + 1, tile);

                // 生成一组副露
                let z = this.getChildIndex(standing[13]);
                let xx = this.openPos_[0];
                let yy = standing[0].y;

                for (let i = 0; i < 4; ++i) {
                    let t = (i == 0 || i == 3) ? createWall02Tile() : new PoolTile0(tile);
                    this.addChildAt(t, z + 1);
                    this.packs_[0].push(t);

                    t.x = standing[idx[3 - i]].x;
                    t.y = yy - HEIGHT_02F * HAND_SCALE;
                    t.scale.set(HAND_SCALE);
                    (new TWEEN.Tween(t)).to({x:(xx + WIDTH_02 * i),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                    (new TWEEN.Tween(t.scale)).to({x:1,y:1}, DISCARD_DT).start();
                }
                this.openPos_[0] = xx + WIDTH_02 * 4 + GAP_T;

                this.stopFlower_ = true;

                this.packData_[0].push(pack);

                // 插入手牌动画
                if (idx[3] == 13) {
                    this._shrink(0, 0, hidden + 3, idx);
                }
                else {
                    let z = this.getChildIndex(standing[0]);
                    let dp = new Array(14);
                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        dp[i] = sp.x;
                        if (i == idx[0] || i == idx[1] || i == idx[2]) {
                            sp.t_ = -1;
                        }
                        else if (i == idx[3]) {
                            sp.t_ = 0xFF;
                        }
                    }

                    standing.sort(function(a, b) { return a.t_ - b.t_; });

                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z + i);
                        if (i < hidden + 3) {
                            sp.visible = false;
                            sp.x = dp[i];
                        }
                        else {
                            sp.visible = true;
                            if (sp.x != dp[i]) {
                                (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                            }
                        }
                    }
                }
                standing[13].visible = false;

                play_snd('snd/09-cpk.wav');
            }

            pk0(pack) {
                let tile = pack_get_tile(pack);

                let prev = this.packs_[0];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = this._findIdxA(0, tile);
                let src = this.standing_[0][idx];

                let sp = (pr instanceof PoolTile3) ? new PoolTile3(tile) : new PoolTile1(tile);
                let z = this.getChildIndex(pr);
                this.addChildAt(sp, z);
                this.packs_[0].push(sp);

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y - HEIGHT_13F * HAND_SCALE;
                sp.scale.set(HAND_SCALE);
                (new TWEEN.Tween(sp)).to({x:pr.x,y:(pr.y - HEIGHT_13 - 10)}, DISCARD_DT).start();
                (new TWEEN.Tween(sp.scale)).to({x:1,y:1}, DISCARD_DT).start();
                sp.dstx_ = pr.x;
                sp.dsty_ = pr.y - HEIGHT_13;
                this.activeTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    let standing = this.standing_[0];
                    let z = this.getChildIndex(standing[0]);
                    let dp = new Array(14);
                    for (let i = 0; i < 14; ++i) {
                        dp[i] = standing[i].x;
                    }

                    src.t_ = 0xFF;
                    src.visible = false;
                    standing.sort(function(a, b) { return a.t_ - b.t_; });

                    for (let i = 0; i < 14; ++i) {
                        let sp = standing[i];
                        this.setChildIndex(sp, z + i);
                        if (sp.x != dp[i]) {
                            (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                        }
                    }
                }

                this.stopFlower_ = true;

                play_snd('snd/09-cpk.wav');
            }

            showSettleView(hand, tile, table, detail) {
                this.closeSettleView();

                let names = [
                    this.infoPanels_[(4 - this.seat_) & 3].getName(),
                    this.infoPanels_[(5 - this.seat_) & 3].getName(),
                    this.infoPanels_[(6 - this.seat_) & 3].getName(),
                    this.infoPanels_[(7 - this.seat_) & 3].getName(),
                ];

                let view = new SettleView(hand, tile, table, detail, names, this.seat_, this.cfg_['r30'],
                    (n)=>{
                        if (n == 0) {
                            if (!this.rp_) {
                                ws.send('{"m":2,"r":8,"v":0}');
                            }
                            else {
                                this.showResult();
                            }
                            this.closeSettleView();
                        }
                        else {
                            this.settleView_.visible = false;
                            this.settleBtn_.visible = true;
                        }
                    }
                );
                this.addChild(view);
                view.scale.set(1.25);
                view.x = (this.width - view.width) * .5;
                view.y = (this.height - view.height) * .5;
                this.settleView_ = view;

                if (!this.rdfsh_) {
                    let rss = (detail['s'] || [0, 0, 0, 0]), rps = detail['n'];
                    for (let i = 0; i < 4; ++i) {
                        let pl = this.players_[i], rs = rss[i], rp = rps[i];
                        pl['rs'][this.rd_] = rs;
                        pl['rp'][this.rd_] = rp;
                        pl['s'] += (rs + rp);
                    }
                    this.rdfsh_ = true;
                }
            }

            closeSettleView() {
                if (this.settleView_) {
                    this.removeChild(this.settleView_);
                    this.settleView_ = null;
                }
                this.settleBtn_.visible = false;
            }

            showFalseWin(f, table) {
                let view = new FalseWinView(f, table);
                this.addChild(view);
                view.scale.set(1.25);
                view.x = (this.width - view.width) * .5;
                view.y = (this.height - view.height) * .5;
                if (this.turn_ == this.seat_) {
                    setTimeout(()=>{
                        this.addCD(this.cfg_['r30']);
                    }, 4000);
                }
            }

            toggleHistory() {
                let hv = this.historyView_;
                if (hv.visible) {
                    hv.visible = false;
                }
                else {
                    this.setChildIndex(hv, this.children.length - 1);
                    hv.show(this.players_, this.rd_ + (this.rdfsh_ ? 1 : 0), this.cfg_['i'], -this.cfg_['b']);
                }
            }

            toggleChase() {
                // this.seat_ = 0;
                // this.players_[0]['n'] = '12';
                // this.rp_ = [{'n':'123','s':123},{'n':'12','s':12},{'n':'-12','s':-12},{'n':'-123','s':-123}];
                // this.rpt_ = 0;
                // this.showResult();
                // return;
                let cv = this.chaseView_;
                if (cv.visible) {
                    cv.visible = false;
                }
                else {
                    let fw = this.falseWin_;
                    let penalties = [0, 0, 0, 0];
                    if (this.cfg_['fa']) {
                        for (let i = 0; i < 4; ++i) {
                            if (fw[i]) {
                                for (let k = 0; k < 4; ++k) {
                                    penalties[k] += (i != k) ? 10 : -30;
                                }
                            }
                        }
                    }
                    else {
                        for (let i = 0; i < 4; ++i) {
                            if (fw[i]) {
                                penalties[i] -= 40;
                            }
                        }
                    }
                    this.setChildIndex(cv, this.children.length - 1);
                    cv.show(this.players_, penalties);
                }
            }

            showResult() {
                if (this.resultView_) {
                    this.removeChild(this.resultView_);
                    this.resultView_ = null;
                }

                let view = new ResultView(this.cfg_['t'], this.players_[this.seat_]['n'], this.rp_, this.rpt_, ()=>{
                    if (this.resultView_) {
                        this.removeChild(this.resultView_);
                        this.resultView_ = null;
                        delete this.rp_;
                        delete this.rpt_;
                        ws.send('{"m":1,"r":2}');
                        game.visible = false;
                        lobby.visible = true;
                        delete lobby.seat_;
                        delete lobby.tableid_;
                        this.historyView_.visible = false;
                        this.chaseView_.visible = false;
                    }
                });
                this.addChild(view);
                view.scale.set(1.25);
                view.x = (this.width - view.width) * .5;
                view.y = (this.height - view.height) * .5;
                this.resultView_ = view;
            }

            _removeOpenTiles(n, cnt) {
                let sp;
                while (sp = this.openTiles_[n].pop()) {
                    this.removeChild(sp);
                }

                let hidden = this.packData_[n].length * 3;
                let standing = this.standing_[n];
                for (let i = hidden; i < cnt; ++i) {
                    standing[i].visible = true;
                }

                let packs = this.packs_[n];
                for (let i = 0, len = packs.length; i < len; ++i) {
                    packs[i].visible = true;
                }
            }

            openHand(tiles, succeed, wp, cp, wt) {
                if (succeed) {
                    setTimeout(()=>{
                        let p = (this.seat_ + 1) & 3;
                        this._open1(tiles[p], wp == p ? wt : undefined);
                        p = (this.seat_ + 2) & 3;
                        this._open2(tiles[p], wp == p ? wt : undefined);
                        p = (this.seat_ + 3) & 3;
                        this._open3(tiles[p], wp == p ? wt : undefined);
                        this._open0(tiles[this.seat_], wp == this.seat_ ? wt : undefined);
                    }, DISCARD_DT * 2);

                    if (wp != undefined && cp != undefined && wp != cp) {
                        let n0 = (wp + 4 - this.seat_) & 3;
                        let n1 = (cp + 4 - this.seat_) & 3;
                        let src = this.activeTile_;
                        let dst = this.standing_[n0][13];
                        let xx, yy, sp;
                        if (!src) {
                            console.log('ui error');
                            reenter();
                            return;
                        }
                        switch (n0) {
                        case 0:
                            sp = new PoolTile0(wt);
                            sp.anchor.y = 1;
                            sp.x = src.x;
                            sp.y = src.y - HEIGHT_02;
                            xx = dst.x;
                            yy = dst.y;
                            break;
                        case 1:
                            sp = new PoolTile1(wt);
                            sp.x = src.x;
                            sp.y = src.y;
                            xx = dst.x - (WIDTH_13 - WIDTH_13S);
                            yy = dst.y - HEIGHT_13SF + HEIGHT_13F * 2;
                            break;
                        case 2:
                            sp = new PoolTile2(wt);
                            sp.x = src.x;
                            sp.y = src.y;
                            xx = dst.x;
                            yy = dst.y;
                            break;
                        case 3:
                            sp = new PoolTile3(wt);
                            sp.x = src.x;
                            sp.y = src.y;
                            xx = dst.x;
                            yy = dst.y;
                            break;
                        }
                        let z = this.getChildIndex(src);
                        this.addChild(sp);
                        this.removeChild(src);
                        this.activeTile_ = null;

                        (new TWEEN.Tween(sp)).to({x:xx,y:yy}, DISCARD_DT).onComplete(()=>{ this.removeChild(sp); }).start();

                        if (n0 == 0) {
                            (new TWEEN.Tween(sp.scale)).to({x:HAND_SCALE,y:HAND_SCALE}, DISCARD_DT).start();
                        }

                        let pos = this.callTextPos_[n1];
                        let text = new PIXI.extras.BitmapText('点炮', { font:'128px STXingkai' });
                        text.anchor.x = pos['ax'];
                        text.anchor.y = pos['ay'];
                        text.x = pos['x'];
                        text.y = pos['y'];
                        this.addChild(text);
                        this.openTiles_[n1].push(text);
                    }

                    if (wp != undefined) {
                        let n0 = (wp + 4 - this.seat_) & 3;
                        let pos = this.callTextPos_[n0];
                        let text = new PIXI.extras.BitmapText('和', { font:'128px STXingkai' });
                        text.anchor.x = pos['ax'];
                        text.anchor.y = pos['ay'];
                        text.x = pos['x'];
                        text.y = pos['y'];
                        this.addChild(text);
                        this.openTiles_[n0].push(text);
                    }
                }
                else {
                    let n = (wp + 4 - this.seat_) & 3;
                    this.showCallText(n, '错和');
                    switch (n) {
                    case 0: this._open0(tiles[this.seat_], wt); break;
                    case 1: this._open1(tiles[(this.seat_ + 1) & 3], wt); break;
                    case 2: this._open2(tiles[(this.seat_ + 2) & 3], wt); break;
                    case 3: this._open3(tiles[(this.seat_ + 3) & 3], wt); break;
                    }
                    setTimeout(()=>{
                        this._removeOpenTiles(n, (this.turn_ != wp ? 13 : 14));
                    }, 5000);
                }
            }

            _open3(ht, wt) {
                let ot = this.openTiles_[3];

                let standing = this.standing_[3];
                let z = this.getChildIndex(standing[0]);
                let yy = HEIGHT_13SF - HEIGHT_13F;

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                let pos = this.openPos_[3];
                for (let i = 0, len = st.length; i < len; ++i) {
                    let sp0 = standing[offset + i];
                    let sp1 = (st[i] != 255) ? new PoolTile3(st[i]) : createWall13Tile();
                    sp1.x = sp0.x;
                    sp1.y = pos + (offset + i) * HEIGHT_13 + yy;
                    this.addChildAt(sp1, z + offset + i);
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = standing[13];
                    let sp1 = new PoolTile3(wt);
                    sp1.x = sp0.x;
                    sp1.y = pos + 13 * HEIGHT_13 + GAP_T + yy;
                    this.addChildAt(sp1, z + 13);
                    sp0.visible = false;
                    ot.push(sp1);
                }

                let packs = this.packs_[3];
                for (let i = 0, len = ps.length; i < len; ++i) {
                    let p = ps[i];
                    if ((p & 0xFFC0) == 0x200) {
                        for (let k = 0, len2 = packs.length, cnt = 0; k < len2 && cnt < 2; ++k) {
                            let sp0 = packs[k];
                            if (sp0.visible && sp0.ck_) {
                                let sp1 = new PoolTile3(pack_get_tile(p));
                                sp1.x = sp0.x;
                                sp1.y = sp0.y;
                                this.addChildAt(sp1, this.getChildIndex(sp0)+1);
                                sp0.visible = false;
                                ot.push(sp1);
                                ++cnt;
                            }
                        }
                    }
                }
            }

            _open2(ht, wt) {
                let ot = this.openTiles_[2];

                let standing = this.standing_[2];
                let z = this.getChildIndex(standing[0]);

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                let pos = this.openPos_[2];
                for (let i = 0, len = st.length; i < len; ++i) {
                    let sp0 = standing[offset + i];
                    let sp1 = (st[i] != 255) ? new PoolTile2(st[i]) : createWall02Tile();
                    sp1.x = pos - (offset + i) * WIDTH_02;
                    sp1.y = sp0.y;
                    this.addChildAt(sp1, z);
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = standing[13];
                    let sp1 = new PoolTile2(wt);
                    sp1.x = pos - 13 * WIDTH_02 - GAP_T;
                    sp1.y = sp0.y;
                    this.addChildAt(sp1, z);
                    sp0.visible = false;
                    ot.push(sp1);
                }

                let packs = this.packs_[2];
                for (let i = 0, len = ps.length; i < len; ++i) {
                    let p = ps[i];
                    if ((p & 0xFFC0) == 0x200) {
                        for (let k = 0, len2 = packs.length, cnt = 0; k < len2 && cnt < 2; ++k) {
                            let sp0 = packs[k];
                            if (sp0.visible && sp0.ck_) {
                                let sp1 = new PoolTile2(pack_get_tile(p));
                                sp1.x = sp0.x;
                                sp1.y = sp0.y;
                                this.addChildAt(sp1, this.getChildIndex(sp0)+1);
                                sp0.visible = false;
                                ot.push(sp1);
                                ++cnt;
                            }
                        }
                    }
                }
            }

            _open1(ht, wt) {
                let ot = this.openTiles_[1];

                let standing = this.standing_[1];
                let z = this.getChildIndex(standing[0]);
                let xx = WIDTH_13 - WIDTH_13S;
                let yy = HEIGHT_13SF - HEIGHT_13F;

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                let pos = this.openPos_[1];
                for (let i = 0, len = st.length; i < len; ++i) {
                    let sp0 = standing[offset + i];
                    let sp1 = (st[i] != 255) ? new PoolTile1(st[i]) : createWall13Tile();
                    sp1.x = sp0.x - xx;
                    sp1.y = pos - (offset + i - 1) * HEIGHT_13 - yy;
                    this.addChildAt(sp1, z);
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = standing[13];
                    let sp1 = new PoolTile1(wt);
                    sp1.x = sp0.x - xx;
                    sp1.y = pos - 12 * HEIGHT_13 - GAP_T - yy;
                    this.addChildAt(sp1, z);
                    sp0.visible = false;
                    ot.push(sp1);
                }

                let packs = this.packs_[1];
                for (let i = 0, len = ps.length; i < len; ++i) {
                    let p = ps[i];
                    if ((p & 0xFFC0) == 0x200) {
                        for (let k = 0, len2 = packs.length, cnt = 0; k < len2 && cnt < 2; ++k) {
                            let sp0 = packs[k];
                            if (sp0.visible && sp0.ck_) {
                                let sp1 = new PoolTile1(pack_get_tile(p));
                                sp1.x = sp0.x;
                                sp1.y = sp0.y;
                                this.addChildAt(sp1, this.getChildIndex(sp0) + 1);
                                sp0.visible = false;
                                ot.push(sp1);
                                ++cnt;
                            }
                        }
                    }
                }
            }

            _open0(ht, wt) {
                let ot = this.openTiles_[0];

                let standing = this.standing_[0];
                let z = this.getChildIndex(standing[0]);

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                for (let i = 0, len = st.length; i < len; ++i) {
                    if (st[i] == 255) continue;
                    let sp0 = standing[offset + i];
                    let sp1 = new PoolTile0(st[i]);
                    sp1.x = sp0.x;
                    sp1.y = sp0.y;
                    sp1.anchor.y = 1;
                    sp1.scale.set(HAND_SCALE);
                    this.addChildAt(sp1, z + i);
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = standing[13];
                    let sp1 = new PoolTile0(wt);
                    sp1.x = sp0.x;
                    sp1.y = sp0.y;
                    sp1.anchor.y = 1;
                    sp1.scale.set(HAND_SCALE);
                    this.addChildAt(sp1, z + 13);
                    sp0.visible = false;
                    ot.push(sp1);
                }
            }

            reconnect(resp) {
                this.clear();
                this.option_.reset();

                // 基本信息
                let seat = this.seat_ = resp['v'];
                let users = this.players_ = resp['u'];
                for (let i = 0; i < 4; ++i) {
                    let user = users[i];
                    let k = (i + 4 - seat) & 3;
                    let ip = this.infoPanels_[k];
                    ip.setName(user['n']);
                    ip.setFlower(user['f']);
                    ip.setConnection(!user['o']);
                    ip.setFalseWin(this.falseWin_[k] = user['w']);

                    this.windTexts_[k].text = WIND[i] + ' ' + user['s'];
                }

                let dtl = resp['i'];
                if (dtl == undefined) {
                    return;
                }

                this.step_ = dtl['s'];
                this.setupPool(dtl['p']);

                let rd = this.rd_ = dtl['d'];
                this.roundText_.text = WIND[rd >> 2] + '风' + WIND[rd & 3];
                this.setTurn(dtl['t']);

                this.isDiscarding_ = dtl['e'];

                let at = dtl['at'];
                if (at != undefined) {
                    let n = (this.turn_ + 4 - seat) & 3;
                    let dst = this._findPoolDest(n);
                    if (dst != null) {
                        dst.update(at);

                        let sp = new (CTOR_PT[n])(at);
                        this.activeTile_ = sp;
                        this.addChildAt(sp, this.getChildIndex(dst));
                        sp.dst_ = dst;
                        sp.x = dst.x + DOX[n];
                        sp.y = dst.y + DOY[n];
                    }
                }

                // 牌墙
                let w = dtl['w'];
                let dd = w['d'];
                let d = [ dd & 0xF, (dd >> 4) & 0xF, (dd >> 8) & 0xF, (dd >> 12) & 0xF];

                let dir = (d[0] + d[1] - 1 + 4 - seat) & 3;
                let off = d[0] + d[1] + d[2] + d[3];
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                this.backPier_ = off > 0 ? {'dir':dir,'off':off - 1,'down':false} : {'dir':(dir+1)&3,'off':17,'down':false};
                this.openPier_ = {'dir':dir, 'off':off, 'down':false};
                this.frontPier_ = {'dir':dir,'off':off,'down':false};
                let f = w['f'];
                let b = w['b'];
                this.remainCnt_ = 144 - f - b;
                this.remainText_.text = '牌墙剩余：' + this.remainCnt_;
                for (; f > 0; --f) {
                    this._drawTileF();
                }
                for (; b > 0; --b) {
                    this._drawTileB();
                }

                // 自己手牌
                let h = dtl['h'][seat];
                let p = h['p'] || [];
                let s = h['s'];
                let o = p.length * 3;
                let standing = this.standing_[0];
                for (let i = 0; i < 13; ++i) {
                    let sp = standing[i];
                    if (i >= o) {
                        sp.visible = true;
                        sp.update(s[i - o]);
                    }
                    else {
                        sp.t_ = -1;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = standing[13];
                    sp.visible = true;
                    sp.update(s[13 - o]);
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_get_type(pack);
                    let tile = pack_get_tile(pack);
                    let hidden = this.packData_[0].length * 3;
                    let ext = (3 * WIDTH_02 * HAND_SCALE) - (WIDTH_02 * 2 + WIDTH_13 + GAP_T);
                    if (type == 2) {
                        ext -= WIDTH_02;
                        if (pack_get_offer(pack) == 0) {
                            ext += (WIDTH_13 - WIDTH_02);
                        }
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_get_offer(pack)) {
                        default: t0 = new PoolTile1(tile - 4); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile + 4); break;
                        case 2: t0 = new PoolTile1(tile); t1 = new PoolTile0(tile - 4); t2 = new PoolTile0(tile + 4); break;
                        case 3: t0 = new PoolTile1(tile + 4); t1 = new PoolTile0(tile - 4); t2 = new PoolTile0(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile3(tile); break;
                        case 0: hz = 3; t0 = createWall02Tile(); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = createWall02Tile(); break;
                        }
                        break;
                    case 3:
                        switch (pack_get_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        case 2: hz = 5; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile0(tile); break;
                        case 3: hz = 6; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        }
                        break;
                    }

                    let z = this.getChildIndex(standing[13]);

                    this.addChildAt(t0, z + 1);
                    this.addChildAt(t1, z + 1);
                    this.addChildAt(t2, z + 1);
                    if (t3 != undefined) this.addChildAt(t3, z + 1);

                    this.packs_[0].push(t0);
                    this.packs_[0].push(t1);
                    this.packs_[0].push(t2);
                    if (t3 != undefined) this.packs_[0].push(t3);

                    // 不是动画
                    let xx = this.openPos_[0];
                    let yy = standing[0].y;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.position.set(xx, yy - HEIGHT_13F);
                            t1.position.set(xx + WIDTH_13, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                        }
                        else {
                            t0.position.set(xx, yy - HEIGHT_13F);
                            t1.position.set(xx + WIDTH_13, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                            t3.position.set(xx + WIDTH_13 + WIDTH_02 * 2, yy - HEIGHT_02F);
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_13F);
                            t2.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                        }
                        else {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_13F);
                            t2.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_02F);
                            t3.position.set(xx + WIDTH_02 * 2 + WIDTH_13, yy - HEIGHT_02F);
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_02 * 2, yy - HEIGHT_13F);
                        }
                        else {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_02F);
                            t3.position.set(xx + WIDTH_02 * 2 + WIDTH_13, yy - HEIGHT_13F);
                        }
                        break;
                    case 3:
                        t0.position.set(xx, yy - HEIGHT_02F);
                        t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                        t2.position.set(xx + WIDTH_02 * 2, yy - HEIGHT_02F);
                        t3.position.set(xx + WIDTH_02 * 3, yy - HEIGHT_02F);
                        break;
                    case 4:
                        t0.position.set(xx, yy - HEIGHT_13F);
                        t1.position.set(xx, yy - HEIGHT_13F - HEIGHT_13);
                        t2.position.set(xx + WIDTH_13, yy - HEIGHT_02F);
                        t3.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                        break;
                    case 5:
                        t0.position.set(xx, yy - HEIGHT_02F);
                        t1.position.set(xx + WIDTH_02, yy - HEIGHT_13F);
                        t2.position.set(xx + WIDTH_02, yy - HEIGHT_13F - HEIGHT_13);
                        t3.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_02F);
                        break;
                    case 6:
                        t0.position.set(xx, yy - HEIGHT_02F);
                        t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                        t2.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_13F);
                        t3.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_13F - HEIGHT_13);
                        break;
                    }

                    this.packData_[0].push(pack);

                    if (hz < 3) {
                        this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * (t3 == undefined ? 2 : 3) + GAP_T;
                    }
                    else if (hz == 3) {
                        this.openPos_[0] = xx + WIDTH_02 * 4 + GAP_T;
                    }
                    else {
                        this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * 2 + GAP_T;
                    }
                }

                // 下家手牌
                h = dtl['h'][(seat + 1) & 3];
                p = h['p'] || [];
                s = h['s'];
                o = p.length * 3;
                standing = this.standing_[1];
                for (let i = 0; i < 13; ++i) {
                    let sp = standing[i];
                    if (i >= o) {
                        sp.visible = true;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = standing[13];
                    sp.visible = true;
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_get_type(pack);
                    let tile = pack_get_tile(pack);
                    let hidden = this.packData_[1].length * 3;
                    let ext = (HEIGHT_02 - HEIGHT_13 + GAP_T) * .5;
                    if (type == 2) {
                        ext += HEIGHT_13 * .5;
                        if (pack_get_offer(pack) == 0) {
                            ext -= (HEIGHT_02 - HEIGHT_13) * .5;
                        }
                    }

                    // 立牌往上，已有的副露往下
                    this.openPos_[1] -= ext;
                    let prev = this.packs_[1];
                    for (let i = 0, len = prev.length; i < len; ++i) {
                        let sp = prev[i];
                        sp.y += ext;
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_get_offer(pack)) {
                        default: t0 = new PoolTile2(tile - 4); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile + 4); break;
                        case 2: t0 = new PoolTile2(tile); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile + 4); break;
                        case 3: t0 = new PoolTile2(tile + 4); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile0(tile); break;
                        case 0: hz = 3; t0 = createWall13Tile(); t1 = createWall13Tile(); t2 = createWall13Tile(); t3 = createWall13Tile(); t1.ck_ = true; t2.ck_ = true; break;
                        }
                        break;
                    case 3:
                        switch (pack_get_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        case 2: hz = 5; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile1(tile); break;
                        case 3: hz = 6; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        }
                        break;
                    }

                    let z = this.getChildIndex(standing[0]);

                    this.addChildAt(t0, z + 1);
                    this.addChildAt(t1, z + 1);
                    this.addChildAt(t2, z + 1);
                    if (t3 != undefined) this.addChildAt(t3, z + 1);

                    this.packs_[1].push(t0);
                    this.packs_[1].push(t1);
                    this.packs_[1].push(t2);
                    if (t3 != undefined) this.packs_[1].push(t3);

                    // 不是动画
                    let xx = standing[0].x;
                    let x0 = xx - (WIDTH_13 - WIDTH_13S);
                    let yy = standing[hidden + 3].y - ext + GAP_T + HEIGHT_13 * 2;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 2);
                            t1.position.set(x0, yy + HEIGHT_13);
                            t2.position.set(x0, yy);
                        }
                        else {
                            t0.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 3);
                            t1.position.set(x0, yy + HEIGHT_13 * 2);
                            t2.position.set(x0, yy + HEIGHT_13);
                            t3.position.set(x0, yy);
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.position.set(x0, yy + HEIGHT_13 + HEIGHT_02);
                            t1.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13);
                            t2.position.set(x0, yy);
                        }
                        else {
                            t0.position.set(x0, yy + HEIGHT_13 * 2 + HEIGHT_02);
                            t1.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 2);
                            t2.position.set(x0, yy + HEIGHT_13);
                            t3.position.set(x0, yy);
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.position.set(x0, yy + HEIGHT_02 + HEIGHT_13);
                            t1.position.set(x0, yy + HEIGHT_02);
                            t2.position.set(xx - (WIDTH_02 - WIDTH_13S), yy);
                        }
                        else {
                            t0.position.set(x0, yy + HEIGHT_02 + HEIGHT_13 * 2);
                            t1.position.set(x0, yy + HEIGHT_02 + HEIGHT_13);
                            t2.position.set(x0, yy + HEIGHT_02);
                            t3.position.set(xx - (WIDTH_02 - WIDTH_13S), yy);
                        }
                        break;
                    case 3:
                        t0.position.set(x0, yy + HEIGHT_13 * 3);
                        t1.position.set(x0, yy + HEIGHT_13 * 2);
                        t2.position.set(x0, yy + HEIGHT_13);
                        t3.position.set(x0, yy);
                        break;
                    case 4:
                        t0.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 2);
                        t1.position.set(xx - (WIDTH_02 * 2 - WIDTH_13S), yy + HEIGHT_13 * 2);
                        t2.position.set(x0, yy + HEIGHT_13);
                        t3.position.set(x0, yy);
                        break;
                    case 5:
                        t0.position.set(x0, yy + HEIGHT_13 + HEIGHT_02);
                        t1.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13);
                        t2.position.set(xx - (WIDTH_02 * 2 - WIDTH_13S), yy + HEIGHT_13);
                        t3.position.set(x0, yy);
                        break;
                    case 6:
                        t0.position.set(x0, yy + HEIGHT_02 + HEIGHT_13);
                        t1.position.set(x0, yy + HEIGHT_02);
                        t2.position.set(xx - (WIDTH_02 - WIDTH_13S), yy);
                        t3.position.set(xx - (WIDTH_02 * 2 - WIDTH_13S), yy);
                        break;
                    }

                    this.packData_[1].push(pack);

                    // 移动余下立牌
                    for (let i = 0; i < 14; ++i) {
                        standing[i].y -= ext;
                    }
                }

                // 对家手牌
                h = dtl['h'][(seat + 2) & 3];
                p = h['p'] || [];
                s = h['s'];
                o = p.length * 3;
                standing = this.standing_[2];
                for (let i = 0; i < 13; ++i) {
                    let sp = standing[i];
                    if (i >= o) {
                        sp.visible = true;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = standing[13];
                    sp.visible = true;
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_get_type(pack);
                    let tile = pack_get_tile(pack);
                    let hidden = this.packData_[2].length * 3;
                    let ext = (WIDTH_13 - WIDTH_02 + GAP_T) * .5;
                    if (type == 2) {
                        ext += WIDTH_02 * .5;
                        if (pack_get_offer(pack) == 0) {
                            ext -= (WIDTH_13 - WIDTH_02) * .5;
                        }
                    }

                    // 立牌往左，已有的副露往右
                    this.openPos_[2] -= ext;
                    let prev = this.packs_[2];
                    for (let i = 0, len = prev.length; i < len; ++i) {
                        let sp = prev[i];
                        sp.x += ext;
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_get_offer(pack)) {
                        default: t0 = new PoolTile3(tile - 4); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile + 4); break;
                        case 2: t0 = new PoolTile3(tile); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile + 4); break;
                        case 3: t0 = new PoolTile3(tile + 4); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile1(tile); break;
                        case 0: hz = 3; t0 = createWall02Tile(); t1 = createWall02Tile(); t2 = createWall02Tile(); t3 = createWall02Tile(); t1.ck_ = true; t2.ck_ = true; break;
                        }
                        break;
                    case 3:
                        switch (pack_get_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        case 2: hz = 5; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile2(tile); break;
                        case 3: hz = 6; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        }
                        break;
                    }

                    let z = this.getChildIndex(standing[13]);

                    this.addChildAt(t0, z + 1);
                    this.addChildAt(t1, z + 1);
                    this.addChildAt(t2, z + 1);
                    if (t3 != undefined) this.addChildAt(t3, z + 1);

                    this.packs_[2].push(t0);
                    this.packs_[2].push(t1);
                    this.packs_[2].push(t2);
                    if (t3 != undefined) this.packs_[2].push(t3);

                    // 不是动画
                    let xx = standing[hidden + 3].x - ext + GAP_T + WIDTH_02;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.x = xx + WIDTH_02 * 2;
                            t1.x = xx + WIDTH_02;
                            t2.x = xx;
                        }
                        else {
                            t0.x = xx + WIDTH_02 * 3;
                            t1.x = xx + WIDTH_02 * 2;
                            t2.x = xx + WIDTH_02;
                            t3.x = xx;
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.x = xx + WIDTH_02 + WIDTH_13;
                            t1.x = xx + WIDTH_02;
                            t2.x = xx;
                        }
                        else {
                            t0.x = xx + WIDTH_02 * 2 + WIDTH_13;
                            t1.x = xx + WIDTH_02 * 2;
                            t2.x = xx + WIDTH_02;
                            t3.x = xx;
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.x = xx + WIDTH_13 + WIDTH_02;
                            t1.x = xx + WIDTH_13;
                            t2.x = xx;
                        }
                        else {
                            t0.x = xx + WIDTH_13 + WIDTH_02 * 2;
                            t1.x = xx + WIDTH_13 + WIDTH_02;
                            t2.x = xx + WIDTH_13;
                            t3.x = xx;
                        }
                        break;
                    case 3:
                        t0.x = xx + WIDTH_02 * 3;
                        t1.x = xx + WIDTH_02 * 2;
                        t2.x = xx + WIDTH_02;
                        t3.x = xx;
                        break;
                    case 4:
                        t0.position.set(xx + WIDTH_02 * 2, HEIGHT_13);
                        t1.x = xx + WIDTH_02 * 2;
                        t2.x = xx + WIDTH_02;
                        t3.x = xx;
                        break;
                    case 5:
                        t0.x = xx + WIDTH_02 + WIDTH_13;
                        t1.position.set(xx + WIDTH_02, HEIGHT_13);
                        t2.x = xx + WIDTH_02;
                        t3.x = xx;
                        break;
                    case 6:
                        t0.x = xx + WIDTH_13 + WIDTH_02;
                        t1.x = xx + WIDTH_13;
                        t2.position.set(xx, HEIGHT_13);
                        t3.x = xx;
                        break;
                    }

                    this.packData_[2].push(pack);

                    // 移动余下立牌
                    for (let i = 0; i < 14; ++i) {
                        standing[i].x -= ext;
                    }
                }

                // 上家手牌
                h = dtl['h'][(seat + 3) & 3];
                p = h['p'] || [];
                s = h['s'];
                o = p.length * 3;
                standing = this.standing_[3];
                for (let i = 0; i < 13; ++i) {
                    let sp = standing[i];
                    if (i >= o) {
                        sp.visible = true;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = standing[13];
                    sp.visible = true;
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_get_type(pack);
                    let tile = pack_get_tile(pack);
                    let hidden = this.packData_[3].length * 3;
                    let ext = (HEIGHT_02 - HEIGHT_13 + GAP_T) * .5;
                    if (type == 2) {
                        ext += HEIGHT_13 * .5;
                        if (pack_get_offer(pack) == 0) {
                            ext -= (HEIGHT_02 - HEIGHT_13) * .5;
                        }
                    }

                    // 立牌往下，已有的副露往上
                    this.openPos_[3] += ext;
                    let prev = this.packs_[3];
                    for (let i = 0, len = prev.length; i < len; ++i) {
                        let sp = prev[i];
                        sp.y -= ext;
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_get_offer(pack)) {
                        default: t0 = new PoolTile0(tile - 4); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile + 4); break;
                        case 2: t0 = new PoolTile0(tile); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile + 4); break;
                        case 3: t0 = new PoolTile0(tile + 4); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_get_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile2(tile); break;
                        case 0: hz = 3; t0 = createWall13Tile(); t1 = createWall13Tile(); t2 = createWall13Tile(); t3 = createWall13Tile(); t1.ck_ = true; t2.ck_ = true; break;
                        }
                        break;
                    case 3:
                        switch (pack_get_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        case 2: hz = 5; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile3(tile); break;
                        case 3: hz = 6; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        }
                        break;
                    }

                    let z = this.getChildIndex(standing[0]);

                    this.addChildAt(t0, z);
                    this.addChildAt(t1, z + 1);
                    this.addChildAt(t2, z + 2);
                    if (t3 != undefined) this.addChildAt(t3, z + 3);

                    this.packs_[3].push(t0);
                    this.packs_[3].push(t1);
                    this.packs_[3].push(t2);
                    if (t3 != undefined) this.packs_[3].push(t3);

                    // 不是动画
                    let yy = standing[hidden + 3].y + ext - GAP_T;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 * 2;
                            t2.y = yy - HEIGHT_13;
                        }
                        else {
                            t0.y = yy - HEIGHT_13 * 3 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 * 3;
                            t2.y = yy - HEIGHT_13 * 2;
                            t3.y = yy - HEIGHT_13;
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 - HEIGHT_02;
                            t2.y = yy - HEIGHT_13;
                        }
                        else {
                            t0.y = yy - HEIGHT_13 * 3 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                            t2.y = yy - HEIGHT_13 * 2;
                            t3.y = yy - HEIGHT_13;
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.y = yy - HEIGHT_02 - HEIGHT_13 * 2;
                            t1.y = yy - HEIGHT_02 - HEIGHT_13;
                            t2.y = yy - HEIGHT_02;
                        }
                        else {
                            t0.y = yy - HEIGHT_02 - HEIGHT_13 * 3;
                            t1.y = yy - HEIGHT_02 - HEIGHT_13 * 2;
                            t2.y = yy - HEIGHT_02 - HEIGHT_13;
                            t3.y = yy - HEIGHT_02;
                        }
                        break;
                    case 3:
                        t0.y = yy - HEIGHT_13 * 4;
                        t1.y = yy - HEIGHT_13 * 3;
                        t2.y = yy - HEIGHT_13 * 2;
                        t3.y = yy - HEIGHT_13;
                        break;
                    case 4:
                        t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                        t1.position.set(WIDTH_02, t0.y);
                        t2.y = yy - HEIGHT_13 * 2;
                        t3.y = yy - HEIGHT_13;
                        break;
                    case 5:
                        t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                        t1.y = yy - HEIGHT_13 - HEIGHT_02;
                        t2.position.set(WIDTH_02, t1.y);
                        t3.y = yy - HEIGHT_13;
                        break;
                    case 6:
                        t0.y = yy - HEIGHT_02 - HEIGHT_13 * 2;
                        t1.y = yy - HEIGHT_02 - HEIGHT_13;
                        t2.y = yy - HEIGHT_02;
                        t3.position.set(WIDTH_02, t2.y);
                        break;
                    }

                    this.packData_[3].push(pack);

                    // 移动余下立牌
                    for (let i = 0; i < 14; ++i) {
                        standing[i].y += ext;
                    }
                }

                this.addBtns(dtl['a']);
            }

        }

        class StandingTile extends PIXI.Sprite {
            constructor(t, callback) {
                let ti = all_tiles[t];
                let tex = PIXI.loader.resources['img/tiles/standing0.png'].texture.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                super(tex);
                this.t_ = t;

                if (!callback) {
                    return;
                }

                tex = tex.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * 7 + 2, (HEIGHT_02F + 2) * 3 + 2,
                    WIDTH_02, HEIGHT_02F);
                let fg = new PIXI.Sprite(tex);
                this.addChild(fg);
                fg.anchor.y = 1;
                fg.alpha = .3;
                this.fg_ = fg;
                fg.visible = false;

                this.callback_ = callback;
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                this.interactive = true;
                this.on('click', this.click);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', this.click);
                //this.on('touchstart', hlt);
                //this.on('touchendoutside', nml);
                //this.on('touchend', nml);
            }

            update(t) {
                updatePool02Tile(this, t);
            }

            setHighlight(h) {
                this.fg_.visible = h;
            }

            isHighlight() {
                return this.fg_.visible;
            }

            click() {
                this.callback_(this);
            }
        }

        function updatePool02Tile(sp, t) {
            if (sp.t_ != t) {
                let ti = all_tiles[t];
                sp.texture.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                sp.t_ = t;
            }
        }

        function updatePool13Tile(sp, t) {
            if (sp.t_ != t) {
                let ti = all_tiles[t];
                sp.texture.frame = new PIXI.Rectangle(
                    (WIDTH_13 + 2) * (ti & 0xF) + 2, (HEIGHT_13F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_13, HEIGHT_13F);
                sp.t_ = t;
            }
        }

        function createWall02Tile() {
            let tex = PIXI.loader.resources['img/tiles/pool0.png'].texture.clone();
            tex.frame = new PIXI.Rectangle(
                (WIDTH_02 + 2) * 8 + 2, (HEIGHT_02F + 2) * 4 + 2,
                WIDTH_02, HEIGHT_02F);
            return new PIXI.Sprite(tex);
        }

        function createWall13Tile() {
            let tex = PIXI.loader.resources['img/tiles/pool1.png'].texture;
            tex.frame = new PIXI.Rectangle(
                (WIDTH_13 + 2) * 8 + 2, (HEIGHT_13F + 2) * 4 + 2,
                WIDTH_13, HEIGHT_13F);
            return new PIXI.Sprite(tex);
        }

        function createStandingTile1() {
            let tex = PIXI.loader.resources['img/tiles/standing1.png'].texture;
            return new PIXI.Sprite(tex);
        }

        function createStandingTile2() {
            let tex = PIXI.loader.resources['img/tiles/pool2.png'].texture.clone();
            tex.frame = new PIXI.Rectangle(
                (WIDTH_02 + 2) * 8 + 2, (HEIGHT_02F + 2) * 4 + 2,
                WIDTH_02, HEIGHT_02F);
            return new PIXI.Sprite(tex);
        }

        function createStandingTile3() {
            let tex = PIXI.loader.resources['img/tiles/standing3.png'].texture;
            return new PIXI.Sprite(tex);
        }

        const rcs = [
            new PIXI.Rectangle(2, 2, 72, 200), new PIXI.Rectangle(76, 2, 90, 200), new PIXI.Rectangle(168, 2, 70, 200),
            new PIXI.Rectangle(240, 2, 70, 200), new PIXI.Rectangle(312, 2, 70, 200), new PIXI.Rectangle(384, 2, 70, 200),
            new PIXI.Rectangle(2, 204, 70, 200), new PIXI.Rectangle(74, 204, 70, 200), new PIXI.Rectangle(146, 204, 58, 200),
        ];

        function createDice(n) {
            let tex = PIXI.loader.resources[`img/dice/${n}.png`].texture;
            let frames = [];
            for (let i = 0; i < 9; ++i) {
                let f = new PIXI.Texture(tex, rcs[i]);
                frames.push(f);
            }
            let asp = new PIXI.extras.AnimatedSprite(frames);
            asp.x = 100;
            asp.y = 100;
            asp.animationSpeed = .4;
            asp.loop = false;
            asp.play();
            return asp;
        }

        class OptionPanel extends PIXI.Container {
            constructor() {
                super();

                let btns = new Array(7);
                const btnTitle = ['自动补花', '不 吃', '不 碰', '不 杠', '只和自摸', '自动和牌', '自动摸打'];
                for (let i = 0; i < 7; ++i) {
                    let cb = new CheckBox(btnTitle[i]);
                    this.addChild(cb);
                    cb.x = 200 * i;
                    btns[i] = cb;
                }
                this.btns_ = btns;
            }

            reset() {
                for (let i = 0; i < 7; ++i) {
                    let cb = this.btns_[i];
                    cb.setSelected(i == 0);
                }
            }

            status() {
                let s = new Array(7);
                for (let i = 0; i < 7; ++i) {
                    s[i] = this.btns_[i].isSelected();
                }
                return s;
            }
        }

        class InfoPanel extends PIXI.Container {
            constructor() {
                super();

                const width = 220, height = 200;
                this.width = width;
                this.height = height;
                this.pivot.x = width;

                {
                let graph = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0x000000, .25);
                graph.drawRect(0, 0, width, height);
                graph.endFill();
                this.addChild(graph);
                }

                let text = this.lcText_ = new PIXI.Text('掉线', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 80,
                    fill: '#ffffff'
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5;
                text.y = height * .5;
                text.alpha = .2;
                text.visible = false;

                text = this.nameText_ = new PIXI.Text('', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5;
                text.y = height * .5;

                text = this.flowerText_ = new PIXI.Text('\uD83C\uDF38 \u00D7 0', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 28,
                    fill: '#ffffff'
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5;
                text.y = height - 25;

                text = this.fwText_ = new PIXI.Text('错和', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 28,
                    fill: '#ffffff'
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5;
                text.y = 30;
                text.visible = false;
            }

            reset() {
                this.flowerText_.text = '\uD83C\uDF38 \u00D7 0';
                this.fwText_.visible = false;
            }

            setName(s) {
                let t = this.nameText_;
                t.text = s;
                scaleText(t, 210);
            }

            getName() {
                return this.nameText_.text;
            }

            setFlower(f) {
                this.flowerText_.text = '\uD83C\uDF38 \u00D7 ' + parseInt(f);
            }

            setConnection(lc) {
                this.lcText_.visible = !lc;
            }

            setFalseWin(fw) {
                this.fwText_.visible = fw;
            }
        }

        class CheckBox extends PIXI.Container {
            constructor(str, callback) {
                super();

                let bg = new PIXI.Sprite(PIXI.loader.resources['img/ui/checkbox_normal.png'].texture);
                this.addChild(bg);

                let tk = this.tk_ = new PIXI.Sprite(PIXI.loader.resources['img/ui/checkbox_tick.png'].texture);
                this.addChild(tk);
                tk.visible = false;

                let text = this.text_ = new PIXI.Text(str, {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 30,
                    fill: '#ffffff',
                    stroke: '#000000',
                    strokeThickness: 3,
                });
                this.addChild(text);
                text.x = bg.width + 5;

                let width = bg.width + 5 + text.width;
                let height = Math.max(bg.height, text.height);
                bg.anchor.y = .5;
                tk.anchor.y = .5;
                text.anchor.y = .5;
                bg.y = height * .5;
                tk.y = height * .5;
                text.y = height * .5;

                this.width = width;
                this.height = height;

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawRect(0, 0, width, height);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                let clk = ()=>{
                    let tk = this.tk_;
                    if (tk.visible) {
                        tk.visible = false;
                        this.text_.style.stroke = '#000000';
                    }
                    else {
                        tk.visible = true;
                        this.text_.style.stroke = '#0066ff';
                    }

                    if (callback) {
                        callback(this);
                    }
                };
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }

            isSelected() {
                return this.tk_.visible;
            }

            setSelected(s) {
                this.tk_.visible = s;
                this.text_.style.stroke = s ? '#0066ff' : '#000000';
            }
        }

        class EmptyButton extends PIXI.Container {
            constructor(width, height, callback) {
                super();

                this.width = width;
                this.height = height;

                let clk = callback.bind(this);
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                let bg = new PIXI.Graphics();
                bg.beginFill(0x000000, .25);
                bg.drawRect(0, 0, width, height);
                bg.endFill();
                this.addChild(bg);

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawRect(0, 0, width, height);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }
        }

        class TextButton extends EmptyButton {
            constructor(str, style, width, height, callback) {
                super(width, height, callback);

                let text = this.face_ = new PIXI.Text(str, style);
                text.anchor.set(.5);
                text.x = width * .5;
                text.y = height * .5;
                this.addChild(text);
            }
        }

        class ActionButton extends PIXI.Container {
            constructor() {
                super();

                this.width = 150;
                this.height = 150;

                let clk = ()=>{ this.callback_(this); };
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                let bg = this.bg_ = new PIXI.Graphics();
                this.addChild(bg);

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawCircle(75, 75, 75);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                let text = this.face_ = new PIXI.extras.BitmapText('', { font:'100px STXingkai' });
                text.anchor.set(.5);
                text.x = 75;
                text.y = 75;
                this.addChild(text);

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }

            setup(idx, callback) {
                this.face_.text = ACTION[idx];
                this.callback_ = callback;

                let bg = this.bg_;
                bg.clear();
                bg.beginFill((idx != 3 ? 0 : 0xCC4040), .25);
                bg.drawCircle(75, 75, 75);
                bg.endFill();
            }
        }

        class SelectionView extends PIXI.Container {
            constructor(type, data, callback) {
                super();

                const width = WIDTH_02 * HAND_SCALE * 2 + 60;
                const height = HEIGHT_02F * HAND_SCALE + 40;

                this.width = width * data.length;
                this.height = height;

                {
                let bg = new PIXI.Graphics();
                //bg.lineStyle(2, 0x0000FF, 1);
                bg.beginFill(0xFFFFFF, .25);
                bg.drawRect(0, 0, width * data.length, height);
                bg.endFill();
                this.addChild(bg);
                }

                for (let i = 0; i < data.length; ++i) {
                    let btn = new EmptyButton(width, height, ()=>{
                        //console.log('click action', data[i]);
                        callback(data[i]);
                    });
                    this.addChild(btn);
                    btn.x = width * i;

                    let tl = '';
                    let ts = [];
                    let ai = data[i];
                    switch (type) {
                    case 3:
                        tl = '吃';
                        ts.push(new StandingTile(hi_byte(ai)));
                        ts.push(new StandingTile(lo_byte(ai)));
                        break;
                    case 5:
                        tl = '杠';
                        ts.push(new StandingTile(lo_byte(ai)));
                        break;
                    default:
                        tl = '取消';
                        break;
                    }

                    let tx = new PIXI.Text(tl, {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 48,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    btn.addChild(tx);
                    tx.y = height - tx.height - 20;
                    let x0 = (width - tx.width - WIDTH_02 * HAND_SCALE * ts.length) * .5;
                    tx.x = x0;

                    x0 += tx.width;
                    for (let i = 0; i < ts.length; ++i) {
                        let sp = ts[i];
                        btn.addChild(sp);
                        sp.scale.set(HAND_SCALE);
                        sp.x = x0 + WIDTH_02 * HAND_SCALE * i;
                        sp.y = height - HEIGHT_02F * HAND_SCALE - 20;
                    }
                }
            }
        }

        class WinHand extends PIXI.Container {
            constructor(hand, tile, flw) {
                super();

                const height = Math.max(HEIGHT_13 + HEIGHT_13F, HEIGHT_02);
                this.height = height;

                // 加这个布局才正常
                let bg = new PIXI.Graphics();
                this.addChild(bg);

                let width = 0;
                if (hand != undefined) {
                    // 副露
                    let ps = hand['p'];
                    if (ps != undefined) {
                        for (let i = 0; i < ps.length; ++i) {
                            let p = ps[i];
                            let o = pack_get_offer(p);
                            let t = pack_get_tile(p);
                            switch (pack_get_type(p)) {
                            case 0: {  // 吃
                                let cls = [PoolTile1, PoolTile0, PoolTile0];
                                let tt;
                                switch (o) {
                                default: tt = [t-4, t, t+4]; break;
                                case 2: tt = [t, t-4, t+4]; break;
                                case 3: tt = [t+4, t-4, t]; break;
                                }
                                for (let i = 0; i < 3; ++i) {
                                    let s = new (cls[i])(tt[i]);
                                    this.addChild(s);
                                    s.anchor.y = 1;
                                    s.x = width;
                                    s.y = height;
                                    width += s.width;
                                }
                                break;
                            }
                            case 1: {  // 碰
                                let cls = [PoolTile0, PoolTile0, PoolTile0];
                                cls[o - 1] = (o == 1) ? PoolTile1 : PoolTile3;
                                for (let i = 0; i < 3; ++i) {
                                    let s = new (cls[i])(t);
                                    this.addChild(s);
                                    s.anchor.y = 1;
                                    s.x = width;
                                    s.y = height;
                                    width += s.width;
                                }
                                break;
                            }
                            case 2: {  // 杠
                                if (o == 0) {  // 暗杠
                                    for (let i = 0; i < 4; ++i) {
                                        let s = (i == 0 || i == 3) ? createWall02Tile() : new PoolTile0(t);
                                        this.addChild(s);
                                        s.anchor.y = 1;
                                        s.x = width;
                                        s.y = height;
                                        width += s.width;
                                    }
                                }
                                else {  // 明杠（直杠）
                                    let cls = [PoolTile0, PoolTile0, PoolTile0, PoolTile0];
                                    switch (o) {
                                    case 1: cls[0] = PoolTile1; break;
                                    case 2: cls[1] = PoolTile1; break;
                                    case 3: cls[3] = PoolTile3; break;
                                    default: break;
                                    }
                                    for (let i = 0; i < 4; ++i) {
                                        let s = new (cls[i])(t);
                                        this.addChild(s);
                                        s.anchor.y = 1;
                                        s.x = width;
                                        s.y = height;
                                        width += s.width;
                                    }
                                }
                                break;
                            }
                            case 3:  {  // 加杠
                                let cls = [PoolTile0, PoolTile0, PoolTile0];
                                cls[o - 1] = (o == 1) ? PoolTile1 : PoolTile3;

                                let s = new (cls[o - 1])(t);
                                this.addChild(s);
                                s.anchor.y = 1;
                                s.x = width + WIDTH_02 * (o - 1);
                                s.y = height - HEIGHT_13;

                                for (let i = 0; i < 3; ++i) {
                                    let s = new (cls[i])(t);
                                    this.addChild(s);
                                    s.anchor.y = 1;
                                    s.x = width;
                                    s.y = height;
                                    width += s.width;
                                }
                                break;
                            }
                            default:
                                break;
                            }

                            width += GAP_T;
                        }
                    }

                    // 立牌
                    let ss = hand['s'];
                    if (ss != undefined) {
                        for (let i = 0; i < ss.length; ++i) {
                            let s = new PoolTile0(ss[i]);
                            this.addChild(s);
                            s.anchor.y = 1;
                            s.x = width;
                            s.y = height;
                            width += s.width;
                        }
                        width += GAP_T;
                    }

                    // 和牌
                    if (tile != undefined) {
                        let s = new PoolTile0(tile);
                        this.addChild(s);
                        s.anchor.y = 1;
                        s.x = width;
                        s.y = height;
                        width += s.width;
                    }

                    // 花
                    if (flw != undefined && flw > 0) {
                        let t = new PIXI.Text(`\uD83C\uDF38 \u00D7 ${((flw>>8)&0xFF)+1}`, {
                            fontFamily: 'Arial,Helvetica,sans-serif',
                            fontSize: 18,
                            fill: '#ffffff'
                        });
                        this.addChild(t);
                        t.x = width - 80;
                    }
                }
                this.width = width;

                //{
                //bg.lineStyle(2, 0x0000FF, 1);
                //bg.beginFill(0xFF00BB, .25);
                //bg.drawRect(0, 0, width, height);
                //bg.endFill();
                //}
            }
        }

        const FAN_NAME = ['无',
            '大四喜', '大三元', '绿一色', '九莲宝灯', '四杠', '连七对', '十三幺',
            '清幺九', '小四喜', '小三元', '字一色', '四暗刻', '一色双龙会',
            '一色四同顺', '一色四节高',
            '一色四步高', '三杠', '混幺九',
            '七对', '七星不靠', '全双刻', '清一色', '一色三同顺', '一色三节高', '全大', '全中', '全小',
            '清龙', '三色双龙会', '一色三步高', '全带五', '三同刻', '三暗刻',
            '全不靠', '组合龙', '大于五', '小于五', '三风刻',
            '花龙', '推不倒', '三色三同顺', '三色三节高', '无番和', '妙手回春', '海底捞月', '杠上开花', '抢杠和',
            '碰碰和', '混一色', '三色三步高', '五门齐', '全求人', '双暗杠', '双箭刻',
            '全带幺', '不求人', '双明杠', '和绝张',
            '箭刻', '圈风刻', '门风刻', '门前清', '平和', '四归一', '双同刻', '双暗刻', '暗杠', '断幺',
            '一般高', '喜相逢', '连六', '老少副', '幺九刻', '明杠', '缺一门', '无字', '边张', '嵌张', '单钓将', '自摸',
            '花牌'
            , '明暗杠'
        ];
        let fan_item = (f, v)=>{
            let c = ((v >> 8) & 0xFF) + 1;
            return `${FAN_NAME[f]} ${c==1?`${v&0xFF}番`:`${v&0xFF}番 \u00D7 ${c}`}`;
        }

        class SettleView extends PIXI.Container {
            // hand = {"s":[22,22,22,23,35,35,35,38,39,40,52,53,54]}
            // tile = 21
            // table = {"50":6,"62":2,"68":2}
            // detail = {"r":0,"f":10,"p":0x0103,"t":[34,-8,-8,-18],"s":[34,-8,-8,-18],"n":[0,0,0,0]}
            // names = ['东','南','西','北']
            // seat = 1
            constructor(hand, tile, table, detail, names, seat, cd, callback) {
                super();

                const width = 700, height = 640, gap = 20;

                this.height = height;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                let t = new WinHand(hand, tile, table != undefined ? table['81'] : 0);
                this.addChild(t);
                t.y = gap;
                if (t.width > width - gap * 2) {
                    t.scale.set((width - gap * 2) / t.width);
                    t.x = gap;
                }
                else {
                    t.x = (width - t.width) * .5;
                }

                let p = detail['p'], cl = -1, wn = -1;
                if (p == undefined) {
                    p = -1;
                }
                if (p >= 0) {
                    cl = lo_byte(p);
                    wn = hi_byte(p);
                }

                let y = gap * 2 + t.height;
                {
                    let tx = '';
                    let f = detail['f'];
                    if (p < 0) {
                        tx = '荒庄';
                    }
                    else {
                        tx = `「${names[wn]}」${cl!=wn?`和牌 「${names[cl]}」点炮`:'自摸'}  ${f}番`;
                    }
                    let t = new PIXI.Text(tx, {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 26,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    this.addChild(t);
                    t.anchor.x = .5;
                    t.x = width * .5;
                    t.y = y;
                    scaleText(t, width - gap * 2);

                    y += t.height + gap;
                }

                let i = 0;
                const frp = (width - gap * 2) / 3;
                for (let f in table) {
                    let x0 = gap + 5 + (i % 3) * frp;
                    let y0 = y + 5 + 35 * Math.floor(i / 3);

                    let v = table[f];
                    let t = new PIXI.Text(fan_item(f, v), {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 22,
                        fill: '#99ffff'
                    });
                    this.addChild(t);
                    t.anchor.y = .5;
                    t.x = x0;
                    //t.x = frp + gap; t.anchor.x = 1;
                    t.y = y0;

                    ++i;
                }

                const x0 = 200, y0 = 400, w0 = 200, h0 = 100;
                let cx = [width * .5, width - gap - x0 * .5, width * .5, gap + x0 * .5];
                let cy = [height - gap - h0 * .5, height - h0 - gap * 2.5, height - h0 * 1.5 - gap * 4, height - h0 - gap * 2.5];

                {
                    let rd = detail['r'];
                    let t = new PIXI.extras.BitmapText(WIND[rd >> 2] + '风' + WIND[rd & 3], { font: '48px SourceHanSansBold' });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = width * .5;
                    t.y = cy[1];
                }

                let ts = detail['t'];
                let ss = detail['s'];
                let ps = detail['n'];
                for (let i = 0; i < 4; ++i) {
                    let ri = (i + seat) & 3;

                    let g = new PIXI.Graphics();
                    //g.lineStyle(2, 0x0000FF, 1);
                    g.beginFill(ri != wn ? (ri != cl ? 0xBBDED6 : 0x89A4C7) : 0xFFAAA5, .5);
                    g.drawRect(0, 0, w0, h0);
                    g.endFill();
                    this.addChild(g);
                    g.x = cx[i] - w0 * .5;
                    g.y = cy[i] - h0 * .5;

                    let t = new PIXI.extras.BitmapText(WIND[ri], { font: '64px SourceHanSansBold'});
                    this.addChild(t);
                    t.anchor.y = .5;
                    t.x = cx[i] - w0 * .5 + 10;
                    t.y = cy[i] + 15;

                    // t = new PIXI.Text(i, {
                    //     fontFamily: 'Arial,Helvetica,sans-serif',
                    //     fontSize: 24,
                    //     fill: '#ffffff',
                    //     stroke: '#0066ff',
                    //     strokeThickness: 2,
                    // });
                    // this.addChild(t);
                    // t.anchor.set(.5);
                    // t.x = cx[i];
                    // t.y = cy[i];

                    t = new PIXI.Text(names[ri], {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 24,
                        fontWeight:'bold',
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = cx[i];
                    t.y = cy[i] - 30;
                    scaleText(t, w0 - 10);

                    let xx = cx[i] + 25;
                    if (ss == undefined) {
                        ss = [0,0,0,0];
                    }
                    let ss0 = ss[ri], ps0 = ps[ri];
                    t = new PIXI.Text(`本盘 ${plus_sign(ss0)}${ps0==0?'':plus_sign(ps0)}`, {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = xx;
                    t.y = cy[i] + 2;

                    let ts0 = ts[ri];
                    t = new PIXI.Text(`累计 ${plus_sign(ts0)}`, {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = xx;
                    t.y = cy[i] + 32;

                    if (ps0 < 0) {
                        t = new PIXI.Text('错和', {
                            fontFamily: 'Arial,Helvetica,sans-serif',
                            fontSize: 16,
                            fill: '#ffffff',
                            stroke: '#0066ff',
                            strokeThickness: 2,
                        });
                        this.addChild(t);
                        t.anchor.y = .5;
                        t.x = cx[i] - w0 * .5 + 10;
                        t.y = cy[i] + 35;
                    }
                }

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect(0, 0, width, height);
                bg.endFill();

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('OK', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(0); });
                this.addChild(btn);
                btn.x = width - btnWidth - gap;
                btn.y = height - btnHeight - gap;

                t = new PIXI.Text(cd, {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 18,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                t.anchor.set(1);
                t.x = btnWidth;
                t.y = btnHeight;
                btn.addChild(t);

                t.end_ = new Date().getTime() + cd * 1000;
                t.timer_ = setInterval(()=>{
                    let n = (t.end_ - new Date().getTime());
                    let s = Math.round(n / 1000);
                    if (s > 0) {
                        t.text = s;
                    }
                    else {
                        callback(0);
                        clearInterval(t.timer_);
                    }
                }, 33.33);

                btn = new TextButton('查看桌面', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(1); });
                this.addChild(btn);
                btn.x = gap;
                btn.y = height - btnHeight - gap;
            }
        }

        class FalseWinView extends PIXI.Container {
            constructor(fn, table) {
                super();

                const width = 500, gap = 20;
                let y = 0;
                this.width = width;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                let t = new PIXI.Text(fn + '番错和', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 26,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.x = .5;
                t.x = width * .5;
                t.y = gap;

                let i = 0;
                const frp = (width - gap * 2) / 2;
                for (let f in table) {
                    let x0 = gap + (i & 1) * frp;
                    let y0 = 70 + 35 * (i >> 1);

                    let v = table[f];
                    let t = new PIXI.Text(fan_item(f, v), {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 22,
                        fill: '#99ffff'
                    });
                    this.addChild(t);
                    t.x = x0;
                    //t.x = frp + gap; t.anchor.x = 1;
                    t.y = y0;
                    y = y0;

                    ++i;
                }

                t = new PIXI.Text('你已错和，本盘失去和牌权', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 22,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.x = .5;
                t.x = width * .5;
                t.y = 220;

                let height = Math.max(y + 110, 340);

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect(0, 0, width, height);
                bg.endFill();

                let thiz = this;
                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('OK', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ thiz.parent.removeChild(thiz); });
                this.addChild(btn);
                btn.x = width - btnWidth - gap;
                btn.y = height - btnHeight - gap;
            }
        }

        function fmt_date(ud) {
            let y = ud.getUTCFullYear(),
                m = ud.getUTCMonth() + 1,
                d = ud.getUTCDate(),
                h = ud.getUTCHours(),
                mm = ud.getUTCMinutes(),
                s = ud.getUTCSeconds();
            return `${y}-${pad2(m)}-${pad2(d)} ${pad2(h)}:${pad2(mm)}:${pad2(s)}`;
        }

        class ResultView extends PIXI.Container {
            constructor(title, name, players, tm, callback) {
                super();

                const width = 600, height = 540, gap = 50;
                const offsetY = 110, gapY = 60;

                this.width = width;
                this.height = height;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect(0, 0, width, height);
                bg.endFill();

                bg.lineStyle(2, 0x808080, 1);
                bg.moveTo(gap, offsetY);
                bg.lineTo(gap, offsetY + gapY * 5);
                bg.lineTo(width - gap, offsetY + gapY * 5);
                bg.lineTo(width - gap, offsetY);
                bg.lineTo(gap, offsetY);

                for (let i = 1; i < 5; ++i) {
                    bg.moveTo(gap, offsetY + gapY * i);
                    bg.lineTo(width - gap, offsetY + gapY * i);
                }

                bg.moveTo(gap + 80, offsetY);
                bg.lineTo(gap + 80, offsetY + gapY * 5);

                bg.moveTo(width - gap - 120, offsetY);
                bg.lineTo(width - gap - 120, offsetY + gapY * 5);

                let t = new PIXI.Text(title + '\n对战结果', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                    align: 'center'
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = width * .5;
                t.y = 60;
                scaleText(t, width - 20);

                const ti = ['名次', '昵称', '分数'];
                let xx = [gap + 40, width * .5 + 40 - 60, width - gap - 60];
                let yy = offsetY + gapY * .5;
                for (let i = 0; i < 3; ++i) {
                    t = new PIXI.Text(ti[i], {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 24,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = xx[i];
                    t.y = yy;
                }

                for (let k = 0; k < 4; ++k) {
                    let yy = offsetY + gapY * (k + 1.5);
                    let text = [k + 1, players[k]['n'], players[k]['s']];
                    for (let i = 0; i < 3; ++i) {
                        t = new PIXI.Text(text[i], {
                            fontFamily: 'Arial,Helvetica,sans-serif',
                            fontSize: 24,
                            fill: (name != text[1]) ? '#ffffff' : '#5cdbd3'
                        });
                        this.addChild(t);
                        t.anchor.set(.5);
                        t.x = xx[i];
                        t.y = yy;
                        if (i == 1) scaleText(t, 280);
                    }
                }

                t = new PIXI.Text(fmt_date(new Date(tm + 28800000)) + ' UTC+08:00', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = width * .5;
                t.y = height - 105;

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('OK', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(); });
                this.addChild(btn);
                btn.x = (width - btnWidth) * .5;
                btn.y = height - btnHeight - 30;
            }
        }

        class HistoryView extends PIXI.Container {
            constructor() {
                super();

                const width = 710, height = 920;
                // 40+70*9+40

                this.width = width;
                this.height = height;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect(0, 0, width, height);
                bg.endFill();

                let t = new PIXI.Text('计分表', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = width * .5;
                t.y = 35;

                bg.lineStyle(2, 0x808080, 1);
                bg.moveTo(40, 70);
                bg.lineTo(40, 830);
                bg.lineTo(width - 40, 830);
                bg.lineTo(width - 40, 70);
                bg.lineTo(40, 70);

                t = new PIXI.Text('昵称', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 20,
                    fontWeight: 'bold',
                    fill: '#DCDCDC',
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = 75;
                t.y = 90;

                let ntt = new Array(4), ttt = new Array(4);
                for (let i = 0; i < 4; ++i) {
                    t = ntt[i] = new PIXI.Text('', {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#FFD700',
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = 180 + 140 * i;
                    t.y = 90;

                    t = ttt[i] = new PIXI.Text('', {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#FFD700',
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = 180 + 140 * i;
                    t.y = 810;
                }
                this.ntt_ = ntt;
                this.ttt_ = ttt;

                t = new PIXI.Text('盘序', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 20,
                    fontWeight: 'bold',
                    fill: '#DCDCDC',
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = 75;
                t.y = 130;

                for (let i = 0; i < 8; ++i) {
                    t = new PIXI.Text(i & 1 ? '累计' : '本盘', {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#DCDCDC',
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = 145 + i * 70;
                    t.y = 130;
                }

                bg.moveTo(40, 110);
                bg.lineTo(width - 40, 110);

                let rtt = new Array(16);
                for (let i = 0; i < 16; ++i) {
                    let yy = 170 + i * 40;
                    t = new PIXI.Text(WIND[i >> 2] + '风' + WIND[i & 3], {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#DCDCDC',
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = 75;
                    t.y = yy;

                    rtt[i] = new Array(8);
                    for (let k = 0; k < 8; ++k) {
                        t = rtt[i][k] = new PIXI.Text('', {
                            fontFamily: 'Arial,Helvetica,sans-serif',
                            fontSize: 20,
                            fontWeight: 'bold'
                        });
                        this.addChild(t);
                        t.anchor.set(.5);
                        t.x = 145 + k * 70;
                        t.y = yy;
                    }

                    bg.moveTo(40, yy - 20);
                    bg.lineTo(width - 40, yy - 20);
                }
                this.rtt_ = rtt;

                t = new PIXI.Text('合计', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 20,
                    fontWeight: 'bold',
                    fill: '#DCDCDC',
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = 75;
                t.y = 810;

                bg.moveTo(40, 790);
                bg.lineTo(width - 40, 790);

                for (let i = 0; i < 4; ++i) {
                    let xx = 110 + 140 * i;
                    bg.moveTo(xx, 70);
                    bg.lineTo(xx, 830);
                    xx += 70;
                    bg.moveTo(xx, 110);
                    bg.lineTo(xx, 790);
                }

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('OK', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ this.visible = false; });
                this.addChild(btn);
                btn.x = (width - btnWidth) * .5;
                btn.y = height - btnHeight - 20;
            }

            show(players, rd, is, nbp) {
                this.visible = true;

                let ntt = this.ntt_, ttt = this.ttt_, rtt = this.rtt_;

                let rss = [players[0]['rs'], players[1]['rs'], players[2]['rs'], players[3]['rs']];
                let rps = [players[0]['rp'], players[1]['rp'], players[2]['rp'], players[3]['rp']];
                let tl = [is, is, is, is];

                for (let i = 0; i < 16; ++i) {
                    let rssi = [rss[0][i], rss[1][i], rss[2][i], rss[3][i]];
                    let rspi = [rps[0][i], rps[1][i], rps[2][i], rps[3][i]];
                    let sd = (rssi[0] != nbp && rssi[1] != nbp && rssi[2] != nbp && rssi[3] != nbp);
                    let tie = (rssi[0] == 0 && rssi[1] == 0 && rssi[2] == 0 && rssi[3] == 0);
                    for (let k = 0; k < 8; ++k) {
                        let tx = '', cl = '#DCDCDC';
                        if (i < rd) {
                            let rs = rssi[k >> 1], rp = rspi[k >> 1];
                            let rr = rs + rp;
                            if (k & 1) {
                                tl[k >> 1] += rr;
                                rr = tl[k >> 1];
                            }
                            else {
                                if (!tie) {
                                    cl = (rs < 0) ? ((rs == nbp || sd) ? '#00CD66' : '#00BFFF') : '#FF6A6A';
                                }
                            }
                            tx = rr;
                        }

                        let t = rtt[i][k];
                        t.text = tx;
                        t.style.fill = cl;
                    }
                }

                for (let i = 0; i < 4; ++i) {
                    let t = ntt[i];
                    t.text = players[i]['n'];
                    scaleText(t, 130);

                    t = ttt[i];
                    t.text = tl[i];
                }
            }
        }

        class ChaseView extends PIXI.Container {
            constructor() {
                super();

                const width = 640, height = 680;
                // 40+120*2+80*4+40 40*10

                this.width = width;
                this.height = height;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect(0, 0, width, height);
                bg.endFill();

                let t = new PIXI.Text('追分策略', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = width * .5;
                t.y = 35;

                bg.lineStyle(2, 0x808080, 1);
                bg.moveTo(40, 70);
                bg.lineTo(40, 470);
                bg.lineTo(width - 40, 470);
                bg.lineTo(width - 40, 70);
                bg.lineTo(40, 70);

                const xps1 = [40, 40, 40, 40, 160, 40, 40, 160, 160];
                for (let i = 0; i < 9; ++i) {
                    let yy = 110 + 40 * i;
                    bg.moveTo(xps1[i], yy);
                    bg.lineTo(width - 40, yy);
                }

                const xps = [160, 280, 360, 440, 520];
                for (let i = 0; i < 5; ++i) {
                    let xx = xps[i];
                    bg.moveTo(xx, 70);
                    bg.lineTo(xx, 110);

                    bg.moveTo(xx, 150);
                    bg.lineTo(xx, 190);

                    bg.moveTo(xx, 230);
                    bg.lineTo(xx, 310);

                    bg.moveTo(xx, 350);
                    bg.lineTo(xx, 470);
                }

                const cls = ['#FFD700', '#FFD700', '#DCDCDC', '#FF6A6A', '#00BFFF', '#00CD66'];
                const tix = ['追者', '被追', '分差', '自摸', '对点', '旁点'];
                const xps2 = [100, 220, 320, 400, 480, 560];
                for (let i = 0; i < 6; ++i) {
                    t = new PIXI.Text(tix[i], {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: cls[i]
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = xps2[i];
                    t.y = 90;
                }

                const yps1 = [170, 270, 410];
                const yps2 = [170, 250, 370];
                let texts = [[null, new Array(1)], [null, new Array(2)], [null, new Array(3)]];
                for (let i = 0; i < 3; ++i) {
                    t = new PIXI.Text('', {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: cls[0],
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = xps2[0];
                    t.y = yps1[i];
                    texts[i][0] = t;

                    for (let k = 0; k <= i; ++k) {
                        texts[i][1][k] = new Array(5);
                        for (let l = 0; l < 5; ++l) {
                            t = new PIXI.Text('', {
                                fontFamily: 'Arial,Helvetica,sans-serif',
                                fontSize: 20,
                                fontWeight: 'bold',
                                fill: cls[l + 1],
                            });
                            this.addChild(t);
                            t.anchor.set(.5);
                            t.x = xps2[l + 1];
                            t.y = yps2[i] + 40 * k;
                            texts[i][1][k][l] = t;
                        }
                    }
                }
                this.texts_ = texts;

                t = new PIXI.Text('自摸：(分差-32) / 4\n对点：(分差-32) / 2\n旁点：(分差-32)', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                    lineHeight: 40
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = width * .5;
                t.y = height - 130;

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('OK', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ this.visible = false; });
                this.addChild(btn);
                btn.x = (width - btnWidth) * .5;
                btn.y = height - btnHeight - 20;
            }

            show(players, penalties) {
                this.visible = true;

                let pls = [
                    {'n':players[0]['n'],'s':players[0]['s'] + penalties[0]},
                    {'n':players[1]['n'],'s':players[1]['s'] + penalties[1]},
                    {'n':players[2]['n'],'s':players[2]['s'] + penalties[2]},
                    {'n':players[3]['n'],'s':players[3]['s'] + penalties[3]}
                ];
                pls.sort(function(a, b) { return b['s'] - a['s']; });

                let t;
                let texts = this.texts_;
                for (let i = 0; i < 3; ++i) {
                    t = texts[i][0];
                    t.text = pls[i + 1]['n'];
                    scaleText(t, 110);

                    for (let k = 0; k <= i; ++k) {
                        let dt = pls[i - k]['s'] - pls[i + 1]['s'];
                        let sd = 8, dd = 8, od = 8;
                        if (dt > 32) {
                            let oo = dt - 32;
                            sd = Math.max((oo >> 2) + 1, 8);
                            dd = Math.max((oo >> 1) + 1, 8);
                            od = Math.max(oo + 1, 8);
                        }

                        let ctt = [pls[i - k]['n'], dt, sd, dd, od];
                        for (let l = 0; l < 5; ++l) {
                            t = texts[i][1][k][l];
                            t.text = ctt[l];
                            if (l == 0) scaleText(t, 110);
                        }
                    }
                }
            }
        }

        class RangeBar extends PIXI.Container {
            constructor(w, h0, h1, cb) {
                super();

                this.width = w;
                this.height = h0;

                this.min_ = h0 * .5;
                this.max_ = w - h0 * .5;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                //bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0xffffff, .5);
                bg.drawRect(0, (h0 - h1) * .5, w, h1);
                bg.endFill();

                let thmb = this.thmb_ = new PIXI.Graphics();
                thmb.beginFill(0xffffff, 1);
                thmb.drawCircle(h0 * .25, h0 * .25, h0 * .5);
                thmb.endFill();
                this.addChild(thmb);
                thmb.x = thmb.y = h0 * .25;

                this.dragging_ = false;
                thmb.interactive = true;
                thmb.on('pointerdown', ()=>{ this.dragging_ = true; });
                thmb.on('pointerup', ()=>{ this.dragging_ = false; });
                thmb.on('pointerupoutside', ()=>{ this.dragging_ = false; })
                thmb.on('pointermove', (e)=>{
                    if (!this.dragging_) return;
                    let pt = this.toLocal(e.data.global);
                    let v0 = this.min_, v1 = this.max_;
                    let vx = Math.max(v0, Math.min(v1, pt.x));
                    this.thmb_.x = vx - v0 * .5;
                    this.value_ = (vx - v0) * 100 / (v1 - v0);
                    cb(this.value_);
                })
            }

            setValue(v) {
                this.value_ = v;
                this.thmb_.x = this.min_ * .5 + (this.max_ - this.min_) * v / 100;
            }

            getValue() {
                return this.value_;
            }
        }

        class SettingView extends PIXI.Container {
            constructor(callback) {
                super();

                const gap = 30, width2 = 450, height2 = 320;

                this.width = LOBBY_WIDTH;
                this.height = LOBBY_HEIGHT;
                this.interactive = true;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.beginFill(0, 0);
                bg.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                bg.endFill();

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect((LOBBY_WIDTH - width2) * .5, (LOBBY_HEIGHT - height2) * .5, width2, height2);
                bg.endFill();

                let t = new PIXI.Text('设置', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = (LOBBY_HEIGHT - height2) * .5 + 40;

                t = new PIXI.Text('音量', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.y = .5;
                t.x = (LOBBY_WIDTH - width2) * .5 + gap + 10;
                t.y = 300;

                let t0 = new PIXI.Text('100%', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t0);
                t0.anchor.x = 1;
                t0.anchor.y = .5;
                t0.x = (LOBBY_WIDTH + width2) * .5 - gap - 10;
                t0.y = 300;

                let rb = new RangeBar(t0.x - t0.width - t.x - t.width - 15, 30, 15, (v)=>{
                    t0.text = Math.round(v) + '%';
                });
                this.addChild(rb);
                rb.x = t.x + t.width + 10;
                rb.y = 285;
                let volume = localStorage.getItem('volume');
                volume = (volume != undefined) ? Math.max(0, Math.min(100, parseFloat(volume))) : 100;
                t0.text = Math.round(volume) + '%';
                rb.setValue(volume);

                t = new PIXI.Text('倒计时音效', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.y = .5;
                t.x = (LOBBY_WIDTH - width2) * .5 + gap + 10;
                t.y = 370;

                let cb = new CheckBox('');
                this.addChild(cb);
                cb.scale.set(.75);
                cb.x = t.x + t.width + 50;
                cb.y = t.y - 15;
                cb.setSelected(!mutecd);

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('取消', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(); });
                this.addChild(btn);
                btn.x = (LOBBY_WIDTH - width2) * .5 + gap;
                btn.y = (LOBBY_HEIGHT + height2) * .5 - btnHeight - 20;

                btn = new TextButton('确定', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{
                    let volume = rb.getValue();
                    mutecd = cb.isSelected() ? 0 : 1;
                    localStorage.setItem('volume', volume);
                    localStorage.setItem('mutecd', mutecd);
                    PIXI.sound.volumeAll = volume / 100;
                    callback();
                });
                this.addChild(btn);
                btn.x = (LOBBY_WIDTH + width2) * .5 - btnWidth - gap;
                btn.y = (LOBBY_HEIGHT + height2) * .5 - btnHeight - 20;
            }
        }

        class PianoKey extends PIXI.Container {
            constructor(width, height, clkcb) {
                super();

                this.width = width;
                this.height = height;

                let clk = clkcb.bind(this);
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                let bg = new PIXI.Graphics();
                bg.beginFill(0, .25);
                bg.drawRect(0, 0, width, height);
                bg.endFill();
                this.addChild(bg);

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawRect(0, 0, width, height);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }
        }

        class Piano extends PIXI.Container {
            constructor(width, standing) {
                super();

                this.width = width;
                this.height = 400;

                let graph = new PIXI.Graphics();
                this.addChild(graph);
                graph.lineStyle(5, 0x808080, 1);
                graph.drawRect(0, 0, width, 240);
                graph.drawRect(0, 240, width, 160);
                graph.endFill();
                graph.moveTo(width * .5, 240);
                graph.lineTo(width * .5, 400);

                let btn = new TextButton('<', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 64,
                    fill: '#ffffff',
                    strokeThickness: 2,
                }, width * .5, 160, ()=>{ this.offset(-1); });
                btn.y = 240;
                this.addChild(btn);

                btn = new TextButton('>', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 64,
                    fill: '#ffffff',
                    strokeThickness: 2,
                }, width * .5, 160, ()=>{ this.offset(1); });
                btn.x = width * .5;
                btn.y = 240;
                this.addChild(btn);

                this.standing_ = standing;
                this.btnctns_ = new Array(3);
                this.o_ = -1;
                this.hlt_ = -1;

                const TILE_WIDTH = WIDTH_02 * HAND_SCALE;
                const BTN_WIDTH = TILE_WIDTH * 3;
                let xx = standing[0].x - BTN_WIDTH;
                let maxx = width - BTN_WIDTH;
                for (let k = 0; k < 3; ++k) {
                    let btnctn = this.btnctns_[k] = new PIXI.Container();
                    this.addChild(btnctn);
                    for (let i = 0; i < 7; ++i) {
                        let x = xx + BTN_WIDTH * i + k * TILE_WIDTH;
                        let w = BTN_WIDTH;
                        let xh = BTN_WIDTH * .5;
                        if (x < 0) {
                            w = BTN_WIDTH + x;
                            x = 0;
                            xh = w - BTN_WIDTH * .5;
                        }
                        else if (x > maxx) {
                            w = BTN_WIDTH - (x - maxx);
                            if (w < BTN_WIDTH * .5) {
                                xh = -1;
                            }
                        }
                        else if (x >= width) {
                            break;
                        }

                        let ri = i * 3 + k - 2;
                        let btn = new PianoKey(w, 240, (btn)=>{
                            let standing = this.standing_;
                            let sp = standing[ri];
                            if (sp && sp.visible) {
                                if (sp.isHighlight()) {
                                    sp.click();
                                    sp.setHighlight(false);
                                }
                                else {
                                    sp.setHighlight(true);
                                    for (let n = 0; n < 14; ++n) {
                                        let st = standing[n];
                                        st.setHighlight(st == sp);
                                    }
                                    let chr = btnctn.children;
                                    for (let n = 0, cnt = chr.length; n < cnt; ++n) {
                                        chr[n].fg_.visible = false;
                                    }

                                    btn.fg_.visible = true;
                                }
                            }
                        });
                        btn.x = x;
                        btnctn.addChild(btn);

                        let graph = new PIXI.Graphics();
                        if (xh > 0) {
                            graph.lineStyle(5, 0xffffff, 1);
                            graph.moveTo(xh, 0);
                            graph.lineTo(xh, 120);
                        }
                        graph.lineStyle(5, 0x808080, 1);
                        graph.drawRect(0, 0, w, 240);
                        graph.endFill();

                        btn.addChild(graph);
                    }
                    btnctn.visible = (k == 0);
                }
            }

            offset(o) {
                let sta = this.standing_;

                // 找到高亮的牌
                let hlt = -1;
                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    if (sp.visible && sp.isHighlight()) {
                        hlt = i;
                        break;
                    }
                }

                if (hlt != -1) {
                    // 高亮的牌对应的钢琴
                    let btnctn = this.btnctns_[(hlt + 2) % 3];
                    if (btnctn.visible) {
                        sta[hlt].setHighlight(false);

                        let sp = sta[hlt + o];
                        if (sp && sp.visible) {
                            sp.setHighlight(true);
                        }
                    }
                }

                o = this.o_ + o;
                if (o > 1) o = -1;
                if (o < -1) o = 1;
                this.o_ = o;

                for (let k = 0; k < 3; ++k) {
                    let btnctn = this.btnctns_[k];
                    if (k != (o + 1)) {
                        btnctn.visible = false;
                    }
                    else {
                        btnctn.visible = true;
                        let chr = btnctn.children;
                        let sta = this.standing_;
                        for (let i = 0, cnt = chr.length; i < cnt; ++i) {
                            let ri = i * 3 + k - 2;
                            let sp = sta[ri];
                            chr[i].fg_.visible = (sp && sp.visible && sp.isHighlight());
                        }
                    }
                }
            }

            refresh() {
                for (let k = 0; k < 3; ++k) {
                    let btnctn = this.btnctns_[k];
                    if (btnctn.visible) {
                        let chr = btnctn.children;
                        let sta = this.standing_;
                        for (let i = 0, cnt = chr.length; i < cnt; ++i) {
                            let ri = i * 3 + k - 2;
                            let sp = sta[ri];
                            chr[i].fg_.visible = (sp && sp.visible && sp.isHighlight());
                        }
                    }
                }
            }
        }

        function scaleText(t, w) {
            let w0 = t.width / t.scale.x;
            if (w0 > w) {
                t.scale.set(w / w0);
            }
            else {
                t.scale.set(1);
            }
        }

        const LOBBY_WIDTH = 680, LOBBY_HEIGHT = 700;

        function bytes_len(s) {
            let r = 0;
            for (let i = 0, len = s.length; i < len; ++i) {
                let c = s.charCodeAt(i);
                if (c >= 0 && c < 256) ++r;
                else r += 2;
            }
            return r;
        }

        class LobbyView extends PIXI.Container {
            constructor() {
                super();

                let container = this.container_ = new PIXI.Container();
                container.width = LOBBY_WIDTH;
                container.height = LOBBY_HEIGHT;
                this.addChild(container);

                {
                let graph = new PIXI.Graphics();
                graph.beginFill(0x89A4C7, .5);
                graph.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                graph.endFill();
                container.addChild(graph);
                }

                //let resp = {"m":1,"r":2,"t":{"i":10001,"t":1548852882425,"r":0,"u":false,"p":["游客10002","","",""],"g":{"t":"45679","n":16,"d":false,"i":0,"l":8,"r12":3,"r30":10,"dt":255,"d12":false,"fa":true,"fc":false,"s":true,"o":false,"a":false,"r":true}}};
                //container.addChild(new TableInfoView(resp['t']));

                const btnWidth = 120, btnHeight = 50;
                let btn = this.nameBtn_ = new TextButton('', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ ws.send('{"m":1,"r":10}'); });
                container.addChild(btn);
                btn.x = LOBBY_WIDTH - btnWidth;

                btn = new TextButton('返回主页', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ window.open("/", "_blank"); });
                container.addChild(btn);

                btn = new TextButton('创建桌子', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ this._showCreateView(); });
                container.addChild(btn);
                btn.x = (LOBBY_WIDTH - btnWidth) * .5;
                btn.y = LOBBY_HEIGHT - btnHeight - 20;

                btn = this.prevBtn_ = new TextButton('上一页', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ this._prevPage(); });
                container.addChild(btn);
                btn.x = LOBBY_WIDTH * .25 - btnWidth * .5;
                btn.y = LOBBY_HEIGHT - btnHeight - 90;

                btn = this.nextBtn_ = new TextButton('下一页', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ this._nextPage(); });
                container.addChild(btn);
                btn.x = LOBBY_WIDTH * .75 - btnWidth * .5;
                btn.y = LOBBY_HEIGHT - btnHeight - 90;

                this.tables_ = [];
                this.page_ = 0;

                let t = this.pageText_ = new PIXI.Text('1/1', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                container.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = LOBBY_HEIGHT - btnHeight - 65;

                this._enable(this.prevBtn_, false);
                this._enable(this.nextBtn_, false);

                let root = this.root_ = new PIXI.Container();
                container.addChild(root);
            }

            onmessage(resp) {
                let r = resp['r'];
                switch (r) {
                case 1:
                    switch (resp['e']) {
                    default: this._error('未知错误'); break;
                    case 0: this._error('未知错误0'); break;
                    case 1: this._error('你已经在桌子上'); break;
                    case 2: this._error('你已经在对局中'); break;
                    case 3: this._error('桌子不存在'); break;
                    case 4: this._error('不正确的位置'); break;
                    case 5: this._error('这个位置已经有人了'); break;
                    case 6: this._error('密码错误'); break;
                    case 7: this._error('你不在桌子上'); break;
                    case 8: this._error('你已在别处登录'); break;
                    case 9: this._error('用户名或密码过长'); break;
                    case 10: this._error('该桌不允许游客账号加入'); break;
                    case 11: this._error('不允许使用特殊字符'); break;
                    case 12:this._error('鸣牌时限不能超过出牌时限');break;
                    case 13: this._error('账号和密码不匹配'); break;
                    case 14: this._error('验证码已过期'); break;
                    case 15: this._error('验证码错误'); break;
                    case 16: {
                        document.cookie = '__p=;Path=/;Max-Age=0';
                        let un = localStorage.getItem('username'), pw = localStorage.getItem('password');
                        if (un && pw) {
                            ws.send(`{"m":1,"r":9,"u":"${un}","p":"${pw}"}`);
                        }
                        else {
                            this._error('自动登录失败，请输入账号密码登录');
                        }
                        break;
                    }
                    }
                    break;
                case 2: {
                    let t = this.nameBtn_.face_;
                    t.text = resp['n'] || '';
                    scaleText(t, 115);

                    let tv;
                    while (tv = this.tables_.pop()) {
                        this.root_.removeChild(tv);
                    }

                    let ts = resp['t'];
                    for (let i = 0, len = ts.length; i < len; ++i) {
                        let t = ts[i];
                        tv = new TableInfoView(t, (id, s, p)=>{ this._callback(id, s, p); });
                        tv.x = 10;
                        this.root_.addChild(tv);
                        this.tables_.push(tv);

                        tv.refresh(this.tableid_, this.seat_);
                    }

                    this._refresh();
                    break;
                }
                case 3: {
                    let t = resp['t'];
                    let tv = new TableInfoView(t, (id, s, p)=>{ this._callback(id, s, p); });
                    tv.x = 10;
                    this.root_.addChild(tv);
                    this.tables_.push(tv);

                    tv.refresh(this.tableid_, this.seat_);
                    this._refresh();
                    break;
                }
                case 4:
                    this._sitDown(resp['t']);
                    this._standUp(resp['f']);
                    break;
                case 5:
                    this._standUp(resp['t']);
                    break;
                case 6:
                    this._ready(resp['t']);
                    break;
                case 7:
                    this._delete(resp['t']);
                    break;
                case 8: {
                    let t = resp['t'];
                    this.tableid_ = t['i'];
                    this.seat_ = t['s'];
                    break;
                }
                case 9: {
                    let t = this.nameBtn_.face_;
                    t.text = resp['u'];
                    scaleText(t, 115);
                    let k = resp['t'];
                    if (k) {
                        let exp = new Date();
                        exp.setTime(exp.getTime() + 864000);
                        document.cookie=`__p=${k};Path=/;Expires=${exp.toGMTString()}`;
                    }
                    break;
                }
                case 10:
                    this._showUserView(resp['z']);
                    break;
                default:
                    break;
                }
            }

            adapt() {
                let sx = window.innerWidth / LOBBY_WIDTH;
                let sy = window.innerHeight / LOBBY_HEIGHT;
                let ss = Math.min(sx, sy);

                this.container_.scale.set(ss);
                let cw = LOBBY_WIDTH * ss;
                if (window.innerWidth > cw) {
                    this.container_.x = (window.innerWidth - cw) * .5;
                } else {
                    this.container_.x = 0;
                }
            }

            _showUserView(pzl) {
                if (this.uv_) {
                    this.container_.removeChild(this.uv_);
                    this.uv_.removeChildren();
                }

                let uv = this.uv_ = new UserView(pzl, (un, pw, sln)=>{
                    console.log('un pw', un, pw);
                    if (un && pw) {
                        ws.send(`{"m":1,"r":9,"u":"${un}","p":"${pw}","z":"${pzl}","s":"${sln}"}`);
                        localStorage.setItem('username', un);
                        localStorage.setItem('password', pw);
                    }
                    this.container_.removeChild(this.uv_);
                    this.uv_.removeChildren();
                    delete this.uv_;
                });
                this.container_.addChild(uv);
                uv.x = (LOBBY_WIDTH - uv.width) * .5;
                uv.y = (LOBBY_HEIGHT - uv.height) * .5;
            }

            _showCreateView() {
                if (this.ctv_) {
                    return;
                }

                let ctv = this.ctv_ = new CreateTableView((cfg)=>{
                    //console.log('cfg', cfg);
                    if (cfg) {
                        let bl = bytes_len(cfg['t']);
                        if (bl == 0) {
                            this._error('对局名称不能为空');
                            return;
                        }
                        if (bl > 40) {
                            this._error('对局名称最多40个字符');
                            return;
                        }
                        let p = cfg['p'];
                        if (p.length > 0 && !p.match('[0-9a-zA-Z]')) {
                            this._error('密码只允许数字和字母');
                            return;
                        }
                        if (p.length > 6) {
                            this._error('密码最长6位');
                            return;
                        }
                        ws.send(JSON.stringify({'m':1,'r':3,'g':cfg}));
                    }

                    this.container_.removeChild(this.ctv_);
                    this.ctv_.removeChildren();
                    delete this.ctv_;
                });
                this.container_.addChild(ctv);
                ctv.x = (LOBBY_WIDTH - ctv.width) * .5;
                ctv.y = (LOBBY_HEIGHT - ctv.height) * .5;
            }

            _callback(id, s, p) {
                //console.log(`{"m":1,"r":4,"v":${id},"s":${s}}`);
                if (s != this.seat_) {
                    if (!p || this.tableid_ == id) {
                        ws.send(`{"m":1,"r":4,"v":${id},"s":${s}}`);
                    }
                    else {
                        if (this.pv_) {
                            return;
                        }
                        let pv = this.pv_ = new PasswordView((p)=>{
                            if (p) {
                                ws.send(`{"m":1,"r":4,"v":${id},"s":${s},"p":"${p}"}`);
                            }
                            this.container_.removeChild(this.pv_);
                            this.pv_.removeChildren();
                            delete this.pv_;
                        });
                        this.container_.addChild(pv);
                        pv.x = (LOBBY_WIDTH - pv.width) * .5;
                        pv.y = (LOBBY_HEIGHT - pv.height) * .5;
                    }
                }
                else {
                    ws.send('{"m":1,"r":5}');
                }
            }

            _findTable(i) {
                let tbs = this.tables_;
                for (let k = 0, len = tbs.length; k < len; ++k) {
                    if (tbs[k].tableid_ == i) {
                        return k;
                    }
                }
                return -1;
            }

            _sitDown(t) {
                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tv = this.tables_[i];
                    tv.sitDown(t['s'], t['n']);
                    tv.refresh(this.tableid_, this.seat_);
                }
            }

            _standUp(t) {
                if (t == undefined) return;

                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tv = this.tables_[i];
                    tv.standUp(t['s']);
                    tv.refresh(this.tableid_, this.seat_);
                }
            }

            _ready(t) {
                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tv = this.tables_[i];
                    tv.ready(t['s'], !!t['r'], this.tableid_);
                }
            }

            _delete(t) {
                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tbs = this.tables_;
                    let tv = tbs[i];
                    tbs.splice(i, 1);
                    this.root_.removeChild(tv);
                    this._refresh();
                }
            }

            _enable(btn, e) {
                let style = btn.face_.style;
                if (e) {
                    style.fill = '#ffffff';
                    style.stroke = '#0066ff';
                    btn.interactive = true;
                }
                else {
                    style.fill = '#cccccc';
                    style.stroke = '#000000';
                    btn.interactive = false;
                    btn.fg_.visible = false;
                }
            }

            _refresh() {
                let tbs = this.tables_;
                let maxPage = Math.ceil(tbs.length / 4);
                if (maxPage == 0) {
                    maxPage = 1;
                }

                let page = this.page_;
                if (page >= maxPage) {
                    page = maxPage - 1;
                    this.page_ = page;
                }

                let s = page * 4, e = s + 4;
                tbs.sort((a, b)=>{ return b.time_ - a.time_; });

                for (let k = 0, len = tbs.length; k < len; ++k) {
                    let tv = tbs[k];
                    if (k < s || k >= e) {
                        tv.visible = false;
                    }
                    else {
                        tv.visible = true;
                        tv.y = 60 + tv.height * (k - s);
                    }
                }

                this._enable(this.prevBtn_, page > 0);
                this._enable(this.nextBtn_, (page + 1) < maxPage);
                this.pageText_.text = (page + 1) + '/' + maxPage;
            }

            _prevPage() {
                if (this.page_ == 0) {
                    return;
                }
                --this.page_;
                this._refresh();
            }

            _nextPage() {
                if (this.page_ >= Math.ceil(this.tables_.length / 4)) {
                    return;
                }
                ++this.page_;
                this._refresh();
            }

            _error(s) {
                let bg = new PIXI.Graphics();
                this.container_.addChild(bg);

                let t = new PIXI.Text(s, {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 40,
                    fill: '#000000',
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = LOBBY_HEIGHT * .5;

                let w = t.width, h = t.height;
                bg.beginFill(0xffffff, .9);
                bg.drawRect((LOBBY_WIDTH - w) * .5 - 20, (LOBBY_HEIGHT - h) * .5 - 20, w + 40, h + 40);
                bg.endFill();

                (new TWEEN.Tween(bg)).to({alpha:1}, 100).onComplete(()=>{
                    (new TWEEN.Tween(bg)).to({alpha:0}, 100).delay(1300).onComplete(()=>{ this.container_.removeChild(bg); }).start();
                }).start();
            }
        }

        function fmt_cfg(cfg) {
            let str = cfg['n'] + '盘 | ' + cfg['l'] + '番 (' + cfg['b'] + ') | ' + cfg['r30'] + '/' + cfg['r12'] + '秒 | ';
            str += (cfg['s']) ? '有战术鸣牌 | ' : '无战术鸣牌 | ';
            str += (cfg['o']) ? '结束显示手牌 | ' : '结束不显示手牌 | ';
            str += (cfg['fa']) ? '错和-30/+10 ' : '错和-40/+0 ';
            str += (cfg['fc']) ? '允许鸣牌' : '不允许鸣牌';
            return str;
        }

        class CreateTableView extends PIXI.Container {
            constructor(callback) {
                super();

                const gap = 30, offsetY = 80, gapY = 35;

                this.width = LOBBY_WIDTH;
                this.height = LOBBY_HEIGHT;
                this.interactive = true;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                bg.endFill();

                let t = new PIXI.Text('创建牌桌', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = 35;

                const title = [
                    '对局名称',
                    '类型',
                    '起和番',
                    '底分',
                    '出牌时限',
                    '鸣牌时限',
                    '战术鸣牌',
                    '一盘结束后显示手牌',
                    '错和处罚策略',
                    '错和后允许鸣牌',
                    '对局初始分',
                    '随机分配初始座位',
                    '对外隐藏玩家昵称',
                    '允许游客加入',
                    '密码（可选）'];
                const option = [
                    undefined,
                    ['全庄', '半庄', '东风'],
                    ['1番', '8番', '16番', '24番', '32番'],
                    ['0', '8'],
                    ['5秒', '8秒', '10秒', '15秒'],
                    ['3秒', '5秒', '8秒', '10秒'],
                    ['有', '无'],
                    ['是', '否'],
                    ['-30/+10', '-40/+0'],
                    ['是', '否'],
                    ['0', '500'],
                    ['是', '否'],
                    ['是', '否'],
                    ['是', '否'],
                    undefined
                ];

                let ctrls = new Array(15);
                for (let i = 0; i < 15; ++i) {
                    let yy = offsetY + 35 * i;
                    t = new PIXI.Text(title[i], {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 18,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    t.anchor.y = .5;
                    t.x = gap;
                    t.y = yy;
                    this.addChild(t);

                    let xx = Math.max(gap * 2 + t.width, 150);

                    let opt = option[i];
                    if (opt != undefined) {
                        let btns = [];
                        for (let k = 0, len = opt.length; k < len; ++k) {
                            let cb = new CheckBox(opt[k], ()=>{
                                for (let n = 0, len = opt.length; n < len; ++n) {
                                    btns[n].setSelected(n == k);
                                }
                            });
                            this.addChild(cb);
                            cb.scale.set(.66);
                            cb.x = xx + 100 * k;
                            cb.y = yy - cb.height * .5;
                            btns.push(cb);
                        }
                        ctrls[i] = btns;
                    }
                    else {
                        let textInput = new PIXI.TextInput({
                            fontSize: '18px',
                            width: (LOBBY_WIDTH - xx - gap * 2) + 'px',
                            height: '18px',
                            padding: '6px',
                        });
                        textInput.x = xx;
                        textInput.y = yy - 15;
                        textInput.substituteText = false;
                        this.addChild(textInput);
                        ctrls[i] = textInput;
                    }
                }
                this.ctrls_ = ctrls;

                let defcfg = JSON.parse(localStorage.getItem('default_config')) || {};

                function dv(v, d) {
                    if (v != undefined) return v;
                    return d;
                }

                ctrls[0].text = dv(defcfg['t'], '');
                ctrls[1][dv(defcfg['n'], 0)].setSelected(true);
                ctrls[2][dv(defcfg['l'], 1)].setSelected(true);
                ctrls[3][dv(defcfg['b'], 1)].setSelected(true);
                ctrls[4][dv(defcfg['r30'], 2)].setSelected(true);
                ctrls[5][dv(defcfg['r12'], 1)].setSelected(true);
                ctrls[6][dv(defcfg['s'], 0)].setSelected(true);
                ctrls[7][dv(defcfg['o'], 1)].setSelected(true);
                ctrls[8][dv(defcfg['fa'], 0)].setSelected(true);
                ctrls[9][dv(defcfg['fc'], 1)].setSelected(true);
                ctrls[10][dv(defcfg['i'], 0)].setSelected(true);
                ctrls[11][dv(defcfg['r'], 0)].setSelected(true);
                ctrls[12][dv(defcfg['a'], 1)].setSelected(true);
                ctrls[13][dv(defcfg['g'], 1)].setSelected(true);
                ctrls[14].text = dv(defcfg['p'], '');

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('取消', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(); });
                this.addChild(btn);
                btn.x = gap;
                btn.y = LOBBY_HEIGHT - btnHeight - 20;

                btn = new TextButton('确定', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(this._cfg()); });
                this.addChild(btn);
                btn.x = LOBBY_WIDTH - btnWidth - gap;
                btn.y = LOBBY_HEIGHT - btnHeight - 20;
            }

            _cfg() {
                let ctrls = this.ctrls_;
                function rv(rbs, dv) {
                    for (let i = 0, len = rbs.length; i < len; ++i) {
                        if (rbs[i].isSelected()) {
                            return i;
                        }
                    }
                    return dv;
                }

                let cfg = {
                    't':ctrls[0].text.trim(),
                    'n':rv(ctrls[1], 0),
                    'l':rv(ctrls[2], 1),
                    'b':rv(ctrls[3], 1),
                    'r30':rv(ctrls[4], 2),
                    'r12':rv(ctrls[5], 1),
                    's':rv(ctrls[6], 0),
                    'o':rv(ctrls[7], 1),
                    'fa':rv(ctrls[8], 0),
                    'fc':rv(ctrls[9], 1),
                    'i':rv(ctrls[10], 0),
                    'r':rv(ctrls[11], 0),
                    'a':rv(ctrls[12], 1),
                    'g':rv(ctrls[13], 1),
                    'p':ctrls[14].text
                };
                localStorage.setItem('default_config', JSON.stringify(cfg));
                return cfg;
            }
        }

        class TableInfoView extends PIXI.Container {
            constructor(data, callback) {
                super();

                this.tableid_ = data['i'];
                this.time_ = data['t'];
                this.pw_ = data['u'];

                const width = LOBBY_WIDTH - 20, height = 120, gap = 10;

                this.width = width;
                this.height = height;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect(0, 0, width, height);
                bg.endFill();

                let cfg = data['g'];
                this.anonym_ = cfg['a'];

                let t = new PIXI.Text(cfg['t'], {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 26,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                t.anchor.y = .5;
                t.x = gap;
                t.y = 25;
                this.addChild(t);

                let btn = new TextButton('准备', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 40, ()=>{
                    //console.log(`{"m":1,"r":6,"v":${this.readyBtn_.value_}}`);
                    ws.send(`{"m":1,"r":6,"v":${this.readyBtn_.value_}}`);
                });
                btn.x = width - gap - 120;
                btn.y = 5;
                this.addChild(btn);
                btn.value_ = 1;
                this.readyBtn_ = btn;

                t = new PIXI.Text((this.pw_ ? '\uD83D\uDD12' : '')+ fmt_cfg(cfg), {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 18,
                    fill: '#ffffff',
                    //stroke: '#0066ff',
                    //strokeThickness: 2,
                });
                t.anchor.y = .5;
                t.x = gap;
                t.y = 60;
                this.addChild(t);

                let name = new Array(4);
                let tick = new Array(4);

                let gapX = (width - gap * 2) * .25;
                let p = data['p'];
                let ready = data['r'];
                let rdm = cfg['r'];
                for (let i = 0; i < 4; ++i) {
                    let xx = gap + gapX * i;
                    btn = new EmptyButton(gapX, 40, ()=>{ callback(this.tableid_, i, this.pw_); });
                    btn.x = xx;
                    btn.y = 75;
                    this.addChild(btn);

                    t = new PIXI.Text(rdm ? (i + 1) : WIND[i], {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 22,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    t.anchor.y = .5;
                    t.x = xx;
                    t.y = 100;
                    this.addChild(t);

                    let sp = new PIXI.Sprite(PIXI.loader.resources['img/ui/checkbox_tick.png'].texture);
                    sp.anchor.set(.5);
                    sp.x = xx + 37;
                    sp.y = 100;
                    this.addChild(sp);
                    tick[i] = sp;
                    sp.visible = (ready & (1 << i));

                    t = new PIXI.Text((!this.anonym_ || p[i].length == 0) ? p[i] : '匿名用户', {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 20,
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    t.anchor.y = .5;
                    t.x = xx + 50;
                    t.y = 100;
                    this.addChild(t);
                    t.w_ = gapX - 50;
                    name[i] = t;
                    scaleText(t, t.w_);
                }

                this.name_ = name;
                this.tick_ = tick;
            }

            refresh(id, seat) {
                let btn = this.readyBtn_;
                if (id == this.tableid_) {
                    if (this.seat_ != seat) {
                        btn.face_.text = '准备';
                        btn.value_ = 1;
                    }

                    btn.visible = true;
                    this.seat_ = seat;

                    //console.log('seat', seat);
                    let nm = this.name_;
                    for (let i = 0; i < 4; ++i) {
                        nm[i].style.fill = (seat != i) ? '#ffffff' : '#5cdbd3';
                    }
                }
                else {
                    btn.visible = false;
                    delete this.seat_;

                    let nm = this.name_;
                    for (let i = 0; i < 4; ++i) {
                        nm[i].style.fill = '#ffffff';
                    }
                }
            }

            sitDown(s, n) {
                let t = this.name_[s];
                t.text = !this.anonym_ ? n : '匿名用户';
                scaleText(t, t.w_);
            }

            standUp(s) {
                this.name_[s].text = '';
                this.tick_[s].visible = false;
            }

            ready(s, r, id) {
                this.tick_[s].visible = r;
                if (id == this.tableid_ && s == this.seat_) {
                    let btn = this.readyBtn_;
                    if (r) {
                        btn.face_.text = '取消准备';
                        btn.value_ = 0;
                    }
                    else {
                        btn.face_.text = '准备';
                        btn.value_ = 1;
                    }
                }
            }
        }

        class PasswordView extends PIXI.Container {
            constructor(callback) {
                super();

                const gap = 30, width2 = 360, height2 = 220;

                this.width = LOBBY_WIDTH;
                this.height = LOBBY_HEIGHT;
                this.interactive = true;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.beginFill(0, 0);
                bg.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                bg.endFill();

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect((LOBBY_WIDTH - width2) * .5, (LOBBY_HEIGHT - height2) * .5, width2, height2);
                bg.endFill();

                let t = new PIXI.Text('请输入密码', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = (LOBBY_HEIGHT - height2) * .5 + 40;

                let textInput = new PIXI.TextInput({
                    fontSize: '20px',
                    width: '200px',
                    height: '30px',
                    padding: '6px',
                    paddingLeft: '10px',
                });
                textInput.x = LOBBY_WIDTH * .5 - 100;
                textInput.y = LOBBY_HEIGHT * .5 - 20;
                textInput.substituteText = false;
                this.addChild(textInput);

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('取消', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(); });
                this.addChild(btn);
                btn.x = (LOBBY_WIDTH - width2) * .5 + gap;
                btn.y = (LOBBY_HEIGHT + height2) * .5 - btnHeight - 20;

                btn = new TextButton('确定', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(textInput.text); });
                this.addChild(btn);
                btn.x = (LOBBY_WIDTH + width2) * .5 - btnWidth - gap;
                btn.y = (LOBBY_HEIGHT + height2) * .5 - btnHeight - 20;
            }
        }

        class UserView extends PIXI.Container {
            constructor(pzl, callback) {
                super();

                const gap = 30, width2 = 450, height2 = pzl ? 420 : 320;

                this.width = LOBBY_WIDTH;
                this.height = LOBBY_HEIGHT;
                this.interactive = true;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.beginFill(0, 0);
                bg.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                bg.endFill();

                bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0, .85);
                bg.drawRect((LOBBY_WIDTH - width2) * .5, (LOBBY_HEIGHT - height2) * .5, width2, height2);
                bg.endFill();

                let t = new PIXI.Text('登录', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = (LOBBY_HEIGHT - height2) * .5 + 40;

                const prefix = ['昵称', '密码', '验证'];
                let textInputs = [null, null, null];
                let plh = [localStorage.getItem('username'), localStorage.getItem('password')];
                for (let i = 0, c = pzl ? 3 : 2; i < c; ++i) {
                    let yy = (LOBBY_HEIGHT - height2) * .5 + 110 + 70 * i;
                    t = new PIXI.Text(prefix[i], {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 24,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    this.addChild(t);
                    t.anchor.y = .5;
                    t.x = (LOBBY_WIDTH - width2) * .5 + gap + 10;
                    t.y = yy;

                    let textInput = new PIXI.TextInput({
                        fontSize: '20px',
                        width: '280px',
                        height: '30px',
                        padding: '6px',
                        paddingLeft: '10px',
                    });
                    textInput.x = (LOBBY_WIDTH + width2) * .5 - 300 - gap - 10;
                    textInput.y = yy - 20;
                    this.addChild(textInput);
                    textInputs[i] = textInput;
                    textInput.text = plh[i] || '';
                    textInput.substituteText = false;
                }
                textInputs[1]._dom_input.setAttribute('type', 'password');
                if (pzl) {
                    t = new PIXI.Text(`验证问题：清一色${pzl}，\n听牌为（包括已出现4枚的）`, {
                        fontFamily: 'Arial,Helvetica,sans-serif',
                        fontSize: 18,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                        align: 'center'
                    });
                    this.addChild(t);
                    t.anchor.set(.5);
                    t.x = LOBBY_WIDTH * .5;
                    t.y = LOBBY_HEIGHT * .5 + 95;
                }

                const btnWidth = 120, btnHeight = 50;
                let btn = new TextButton('取消', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(); });
                this.addChild(btn);
                btn.x = (LOBBY_WIDTH - width2) * .5 + gap;
                btn.y = (LOBBY_HEIGHT + height2) * .5 - btnHeight - 20;

                btn = new TextButton('确定', {
                    fontFamily: 'Arial,Helvetica,sans-serif',
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, btnWidth, btnHeight, ()=>{ callback(textInputs[0].text.trim(), textInputs[1].text, pzl ? textInputs[2].text : ''); });
                this.addChild(btn);
                btn.x = (LOBBY_WIDTH + width2) * .5 - btnWidth - gap;
                btn.y = (LOBBY_HEIGHT + height2) * .5 - btnHeight - 20;
            }
        }

    </script>
</body>
</html>
