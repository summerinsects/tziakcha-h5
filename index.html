<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>雀渣——国标麻将 (旧版)</title>
    <style>*{padding:0;margin:0}</style>
    <meta name="viewport" content="user-scalable=no,initial-scale=.4,maximum-scale=.4,minimum-scale=.4,width=device-width,height=device-height">
</head>
<body>
    <canvas>你的浏览器不支持此游戏</canvas>
    <script src="js/pixi.min.js"></script>
    <script src="js/pixi-sound.js"></script>
    <script src="js/Tween.min.js"></script>
    <script src="js/PIXI.TextInput.min.js"></script>
    <script>
        const all_tiles = Uint8Array.of(
            0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
            3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5,
            6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8,
            16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
            19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21,
            22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24,
            32, 32, 32, 32, 33, 33, 33, 33, 34, 34, 34, 34,
            35, 35, 35, 35, 36, 36, 36, 36, 37, 37, 37, 37,
            38, 38, 38, 38, 39, 39, 39, 39, 40, 40, 40, 40,
            48, 48, 48, 48, 49, 49, 49, 49, 50, 50, 50, 50,
            51, 51, 51, 51, 52, 52, 52, 52, 53, 53, 53, 53,
            54, 54, 54, 54, 64, 65, 66, 67, 68, 69, 70, 71
        );

        const seat_2_org = [
            [0, 1, 2, 3], [3, 0, 1, 2], [2, 3, 0, 1], [1, 2, 3, 0],
            [1, 0, 3, 2], [0, 3, 2, 1], [3, 2, 1, 0], [2, 1, 0, 3],
            [3, 2, 0, 1], [2, 1, 3, 0], [1, 0, 2, 3], [0, 3, 1, 2],
            [2, 3, 1, 0], [1, 2, 0, 3], [0, 1, 3, 2], [3, 0, 2, 1]
        ];

        const hint_text = [
            '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '1', '2', '3', '4', '5', '6', '7', '8', '9',
            '1', '2', '3', '4', '5', '6', '7', '8', '9',
            'E', 'S', 'W', 'N', 'C', 'F', 'P', '', ''
        ];

        /**
         * 获取pack类型（吃碰杠）
         * @param {number} p pack
         * @return {number}
         */
        function pack_type(p) { return (p >> 8) & 3; }

        /**
         * 获取pack的牌
         * @param {number} p pack
         * @return {number}
         */
        function pack_tile(p) { return (p & 0x3F) << 2; }

        /**
         * 获取pack的供牌者
         * @param {number} p pack
         * @return {number}
         */
        function pack_offer(p) { return (p >> 6) & 3; }

        /**
         * pack是否为加杠
         * @param {number} p pack
         * @return {boolean}
         */
        function is_pk(p) { return (p & 0x0300) == 0x0300; }

        /**
         * 获取word的低字节
         * @param {number} w word
         * @return {number}
         */
        function lo_byte(w) { return w & 0xFF; }

        /**
         * 获取word的高字节
         * @param {number} w word
         * @return {number}
         */
        function hi_byte(w) { return (w >> 8) & 0xFF; }

        /**
         * 随机打乱数组
         * @param {array} arr
         * @param {number} beg 开始位置
         * @param {number} end 结束位置（不包括）
         */
        function shuffle_array(arr, beg, end) {
            for (let i = beg, len = arr.length; i < end && i < len; ++i) {
                let j = Math.floor(Math.random() * (end - beg)) + beg;
                if (i != j) {
                    let t = arr[i];
                    arr[i] = arr[j];
                    arr[j] = t;
                }
            }
        }

        /**
         * 字符串化数字时显示正号
         * @param {number} x
         * @return {string}
         */
        function plus_sign(x) { return (x >= 0 ? `+${x}` : x); }

        /**
         * 字符串化数字时显示为两位
         * @param {number} x
         * @return {string}
         */
        function pad2(x) { return (x < 10 ? `0${x}` : x); }

        /**
         * 根据base64字符串生成PIXI纹理
         * @param {string} b base64的图片
         * @return {object}
         */
        function base64Tex(b) {
            let img = new Image();
            img.src = b;
            return PIXI.Texture.from(img);
        }

        const FF = [
            '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'Noto Sans', 'sans-serif',
            'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'
        ];

        console.log('location.search', location.search);

        let app = new PIXI.Application({
            width: window.innerWidth,
            height: window.innerHeight,
            view: document.querySelector('canvas')
        });

        //PIXI.SCALE_MODES.DEFAULT = PIXI.SCALE_MODES.NEAREST;

        app.renderer.view.style.display = 'block';
        window.onresize = ()=>{
            app.renderer.resize(window.innerWidth, window.innerHeight);
        };

        //function animate(time) {
        //    window.requestAnimationFrame(animate);
        //    app.renderer.render(app.stage);
        //    TWEEN.update();
        //}
        //animate(performance.now());

        setInterval(()=>{
            app.renderer.render(app.stage);
            try {
                TWEEN.update();
            }
            catch (e) {
                console.log(e);
            }
        }, 33.333);

        var tz = {};

        /**
         * 提示数据不同步（以前的版本是直接重新加载页面，但效果不好）
         */
        function reenter() {
            tz.topmost.error('数据与服务器不同步，请刷新重试', true);
            //ws.send('{"m":4}');
        }

        /**
         * 播放音乐
         * @param {string} s 音乐文件名
         */
        function play_snd(s) {
            try {
                PIXI.loader.resources[s].sound.play();
            }
            catch (e) {
                console.log(e);
            }
        }

        PIXI.DisplayObject.prototype.dstry = function() {
            try {
                this.destroy({children:true});
            }
            catch (e) {
                console.log(e);
            }
        };

        /**
         * 开始加载
         */
        function start_load() {
            let lt = new PIXI.Text('0%', {
                fontFamily: FF,
                fontSize: 32,
                fill: '#ffffff',
                stroke: '#0066ff',
                strokeThickness: 2,
            });
            app.stage.addChild(lt);
            lt.anchor.set(.5);
            let adapt = ()=>{
                lt.x = window.innerWidth * .5;
                lt.y = window.innerHeight * .5;
                lt.scale.set(Math.min(window.innerWidth / 680, window.innerHeight / 700));
            };
            adapt();
            window.onresize = ()=>{
                app.renderer.resize(window.innerWidth, window.innerHeight);
                adapt();
            };

            tz.mutecd = parseInt(localStorage.getItem('mutecd'));
            tz.mutecall = parseInt(localStorage.getItem('mutecall'));

            PIXI.loader.add([
                'img/tiles/standing1.png',
                'img/tiles/standing3.png',
                'img/tiles/pool0.png',
                'img/tiles/pool1.png',
                'img/tiles/pool2.png',
                'img/tiles/pool3.png',
                'img/tiles/standing0.png',

                'img/dice/1.png',
                'img/dice/2.png',
                'img/dice/3.png',
                'img/dice/4.png',
                'img/dice/5.png',
                'img/dice/6.png',

                'fnt/SourceHanSansBold.png',
                'fnt/SourceHanSansBold.fnt',
                'fnt/STXingkai.png',
                'fnt/STXingkai.fnt',
                'fnt/shsb.png',
                'fnt/shsb.fnt',

                'snd/01-start.wav',
                'snd/02-dice.wav',
                'snd/03-cd.wav',
                'snd/05-draw.wav',
                'snd/06-discard.wav',
                'snd/08-inquire.wav',
                'snd/09-cpk.wav',
                'snd/10-win.wav',
                'snd/12-flower-m.wav',
                'snd/13-flower-f.wav',
                'snd/14-chow-m.wav',
                'snd/15-chow-f.wav',
                'snd/16-pung-m.wav',
                'snd/17-pung-f.wav',
                'snd/18-kong-m.wav',
                'snd/19-kong-f.wav',
                'snd/20-win-m.wav',
                'snd/21-win-f.wav',
                'snd/25-xchg.wav'
            ])
            .on('progress', (e)=>{
                console.log('loading progress:', e.progress);
                lt.text = e.progress.toFixed(2) + '%';
            }).load(()=>{
                lt.dstry();
                start_game();
            });
        }

        /**
         * 开始游戏
         */
        function start_game() {
            let res = PIXI.loader.resources;
            StandingTile.tex0 = res['img/tiles/standing0.png'].texture;
            StandingTile.tex1 = res['img/tiles/standing1.png'].texture;
            StandingTile.tex3 = res['img/tiles/standing3.png'].texture;
            PoolTile.tex0 = res['img/tiles/pool0.png'].texture;
            PoolTile.tex1 = res['img/tiles/pool1.png'].texture;
            PoolTile.tex2 = res['img/tiles/pool2.png'].texture;
            PoolTile.tex3 = res['img/tiles/pool3.png'].texture;

            let nht = localStorage.getItem('nht');
            tz.nht = nht = (nht != undefined) ? parseInt(nht) : 0;

            let piat = localStorage.getItem('piano');
            tz.piat = piat = (piat != undefined) ? parseInt(piat) : 0;

            let lobby = tz.lobby = new LobbyView();
            app.stage.addChild(lobby);

            let game = tz.game = new GameView();
            app.stage.addChild(game);

            game.visible = false;

            let topmost = tz.topmost = new TopView();
            app.stage.addChild(topmost);

            document.oncontextmenu = ()=>false;

            lobby.adapt();
            game.adapt();
            topmost.adapt();
            window.onresize = ()=>{
                app.renderer.resize(window.innerWidth, window.innerHeight);
                lobby.adapt();
                game.adapt();
                topmost.adapt();
            };

            let volume = localStorage.getItem('volume');
            volume = (volume != undefined) ? Math.max(0, Math.min(100, parseFloat(volume))) : 100;
            PIXI.sound.volumeAll = volume / 100;

            let ws = tz.ws = new WebSocket('ws://127.0.0.1:5333/ws');
            ws.onopen = ()=>{
                console.log('open');
                // 测试直接创建桌子/坐下
                // let idx = location.search.substr(1);
                // if (idx == undefined) idx = 0;
                // if (idx == 0) {
                //     ws.send('{"m":1,"r":3}');
                // }
                // else {
                //     ws.send(`{"m":1,"r":4,"v":10001,"s":${idx}}`);
                // }
                // ws.send('{"m":1,"r":6}');
                ws.send(`{"m":5,"t":${new Date().getTime()}}`);
                ws.send('{"m":1,"r":2}');
                let f = false;
                let ck = document.cookie;
                if (ck) {
                    let cks = ck.split(';');
                    for (let i = 0, c = cks.length; i < c; ++i) {
                        let p = cks[i].trim().split('=');
                        if (p[0] == '__p') {
                            if (p.length > 1) {
                                ws.send(`{"m":1,"r":11,"t":"${p[1]}"}`);
                                f = true;
                            }
                            break;
                        }
                    }
                }
                lobby.tlr_ = f;
                if (!f) {
                    let un = localStorage.getItem('username'), pw = localStorage.getItem('password');
                    if (un && pw) {
                        ws.send(`{"m":1,"r":12,"u":"${un}","p":"${pw}"}`);
                    }
                }

                tz.hbt = 0;
                window.setInterval(()=>{
                    if (++tz.hbt == 30) {
                        tz.hbt = 0;
                        ws.send(`{"m":5,"t":${new Date().getTime()}}`);
                    }
                }, 1000);
            };
            ws.onerror = (e)=>{
                topmost.error('网络错误，请刷新重试', true);
                console.log('error',e);
            };
            ws.onclose = ()=>{
                console.log('close');
            };
            ws.onmessage = (p)=>{
                try {
                    let resp = JSON.parse(p.data);
                    console.log(resp);
                    let m = resp['m'];
                    switch (m) {
                    case 1:
                        lobby.onmessage(resp);
                        break;
                    case 2:
                        game.onmessage(resp);
                        break;
                    case 3:
                        lobby.visible = false;
                        game.visible = true;
                        game.pool_.startup(resp['s']);
                        break;
                    case 4:
                        lobby.visible = false;
                        game.reconnect(resp);
                        game.pool_.startup(resp['s']);
                        game.visible = true;
                        break;
                    case 5:
                        lobby.speedTest(resp);
                        game.speedTest(resp);
                        break;
                    default:
                        break;
                    }
                } catch (e) {
                    console.log(e);
                }
                tz.hbt = 0;
            };

            // {
            // let pool = game.pool_;
            // // 15个番的测试用例
            // let ht = {"p":[0x21B],"s":[69,70,75,76,81,97,104,105,106,107]};
            // let ft = {"44":8,"46":8,"55":4,"56":4,"58":4,"60":2,"61":2,"64":2,"66":2,"67":2,"72":1,"73":1,"75":1,"78":1,"81":0x101};
            // let dt = {"r":0,"f":44,"p":0x0000,"t":[156,-52,-52,-52],"s":[156,-52,-52,-52],"n":[0,0,0,0]};
            // let nl = ['玩家1','玩家2','玩家3','玩家4'];
            // let vi = 1;
            // //let view = new SettleView(ht, 100, ft, dt, nl, vi, 10);
            // //view.scale.set(1.25);
            // //pool.addChild(view);

            // //view.x = (pool.width / pool.scale.x - view.width) * .5;
            // //view.y = (pool.height / pool.scale.x - view.height) * .5;
            // pool.cfg_={'r30':1500};
            // pool.showSettleView(ht, 100, ft, dt);
            // }
            //pool.rp_ = [{"n":"名字1","l":0,"s":100},{"n":"名字2","l":0,"s":50},{"n":"名字3","l":0,"s":-50},{"n":"名字4","l":0,"s":-100}];

            //game.pool_.showFalseWin(1, {"44":8,"46":8,/*"55":4,"56":4,"58":4,"60":2,"61":2,"64":2,"66":2,"67":2,"72":1,"73":1,"75":1,"78":1,"81":0x101*/});
            // {
            //     let pool = game.pool_;
            //     pool.cfg_={'t':'测试赛','i':0};
            //     pool.seat_=0;
            //     pool.rp_=[{"n":"名字1afsdafsdfafdasafdsfadsfads","l":0,"s":100},{"n":"名字2","l":0,"s":50},{"n":"名字3","l":0,"s":-50},{"n":"名字4","l":0,"s":-100}];
            //     pool.rpt_=0,
            //     game.pool_.showResult();
            // }
            // {
            //     let pool = game.pool_;
            //     let view = new SelectionView(5, [0x0001, 0x0102], (a)=>{
            //         //ws.send(`{"m":2,"r":${types[i]},"v":${a}}`);
            //         //this.rmBtns();
            //         //this.rmCD();
            //     });
            //     pool.addChild(view);
            //     view.y = pool.height_ - 450;
            //     view.x = (pool.width_ - view.width) * .5;
            // }
        }

        /**
         * 游戏界面
         * @typedef {object} GameView
         */
        class GameView extends PIXI.Container {
            constructor() {
                super();

                let title = this.title_ = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 40,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(title);

                // 加这个布局才正常
                // 加了标题之后，可以不要这个了
                //let bg = new PIXI.Graphics();
                //this.addChild(bg);

                let pool = new Pool();
                this.pool_ = pool;
/*
                pool.roundText_.text = '东风东';
                pool.remainText_.text = '牌墙剩余：144';

                pool.windTexts_[0].text = '东 1000';
                //pool.windTexts_[0].style.fill = 'black';
                //pool.windTexts_[0].style.stroke = '#ffffff';
                pool.windTexts_[1].text = '南 1000';
                pool.windTexts_[2].text = '西 1000';
                pool.windTexts_[3].text = '北 1000';

                pool.infoPanels_[0].setName('东家昵称长长长长');
                pool.infoPanels_[1].setName('南家昵称长长长长长');
                pool.infoPanels_[2].setName('西家昵称长长长长长长');
                pool.infoPanels_[3].setName('北家昵称长长长长长长长');
*/
                // //pool.removeChildren();
                // pool.setupPool([
                //     [0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36],
                //     [0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x44, 0x45, 0x46, 0x47],
                //     [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18],
                //     [0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28]
                // ]);
                pool.clear();

                this.addChild(pool);

                let panel = new OptionPanel();
                this.addChild(panel);
                pool.option_ = panel;

                let tail = new PIXI.Graphics();
                this.addChild(tail);
                tail.beginFill(0, 0);
                tail.drawRect(0, 0, 1, 1);
                tail.endFill();
                tail.y = pool.height + 105;

                pool.y = 50;
                panel.x = 0;
                panel.y = pool.height + 55;
                panel.scale.set(pool.width / (panel.width + 15));
                this.containerWidth_ = this.width;
                this.containerHeight_ = this.height;

                let piano3 = new Piano3(pool.width, pool.standing_[0]);
                this.addChild(piano3);
                piano3.visible = false;
                pool.piano3_ = piano3;

                let piano2 = new Piano2(pool.width, pool.standing_[0]);
                this.addChild(piano2);
                piano2.visible = false;
                pool.piano2_ = piano2;

                this.interactive = true;
                this.on('rightclick', pool.rightclick.bind(pool));
            }

            adapt() {
                let pool = this.pool_;
                let panel = pool.option_;
                let piano3 = pool.piano3_;
                let piano2 = pool.piano2_;

                let containerWidth = this.containerWidth_;
                let containerHeight = this.containerHeight_;

                let sx = window.innerWidth / containerWidth;
                let sy = window.innerHeight / containerHeight;
                let ss = Math.min(sx, sy);

                this.scale.set(ss);
                let ch = Math.round(containerHeight * ss);
                if (window.innerHeight <= ch) {
                    this.x = (window.innerWidth - containerWidth * ss) * .5;
                    if (piano3.visible) {
                        piano3.visible = false;
                        piano3.y = 0;
                    }
                    if (piano2.visible) {
                        piano2.visible = false;
                        piano2.y = 0;
                    }
                    panel.y = pool.height + 55;
                } else {
                    this.x = 0;

                    let space = window.innerHeight / ss - containerHeight;
                    //console.log('space = ', space);
                    if (space > 400 + 10 && tz.piat === 0) {
                        if (!piano3.visible) {
                            piano3.visible = true;
                            piano3.y = pool.height + 55;
                            panel.y = pool.height + 65 + 400;
                        }
                        if (piano2.visible) {
                            piano2.visible = false;
                            piano2.y = 0;
                        }
                    } else if (space > 340 + 10) {
                        if (!piano2.visible) {
                            piano2.visible = true;
                            piano2.y = pool.height + 55;
                            panel.y = pool.height + 65 + 340;
                        }
                        if (piano3.visible) {
                            piano3.visible = false;
                            piano3.y = 0;
                        }
                    } else {
                        if (piano3.visible) {
                            piano3.visible = false;
                            piano3.y = 0;
                        }
                        if (piano2.visible) {
                            piano2.visible = false;
                            piano2.y = 0;
                        }
                        panel.y = pool.height + 55;
                    }
                }
            }

            speedTest(resp) {
                let pool = this.pool_;
                pool.sp_.text = `${new Date().getTime() - resp['t']}ms`;
                clearTimeout(pool.sp_.ac_);
            }

            onmessage(resp) {
                let pool = this.pool_;
                let r = resp['r'];

                switch (r) {
                case 1:  { // 初始化桌子
                    let cfg = pool.cfg_ = resp['g'];
                    this.setTitle(cfg);
                    pool.step_ = 0;
                    break;
                }
                case 2: { // 起手
                    pool.clear();
                    pool.option_.reset();
                    pool.seat_ = parseInt(resp['p']);
                    let h = pool.rd_ = resp['h'];
                    pool.roundText_.text = WIND[h >> 2] + '风' + WIND[h & 3];
                    if (h & 3) {
                        pool.sendHandTiles(resp['d'], resp['v']);
                    }
                    else {
                        pool.sendHandTiles2(resp['d'], resp['v']);
                    }
                    pool.isDiscarding_ = false;
                    pool.step_ = 3;
                    break;
                }
                case 3: {  // 询问补花
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    pool.setTurn(v);
                    if (v != pool.seat_) {
                        pool.rmCD();
                        pool.rmBtns();
                    }
                    else {
                        if (resp['f']) {
                            pool.addBtns([0x10000]);
                            pool.addCD(pool.cfg_['r12']);
                        }
                        else {
                            pool.rmCD();
                            pool.rmBtns();
                        }
                    }
                    break;
                }
                case 4: {  // 补花
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    play_snd(!pool.players_[v]['g'] ? 'snd/12-flower-m.wav' : 'snd/13-flower-f.wav');
                    pool.turn_ = v;
                    if (v != pool.seat_) {
                        pool.flower123((v + 4 - pool.seat_) & 3, resp['h']);
                        pool.rmCD();
                    } else {
                        let t = resp['t'];
                        pool.flower0(lo_byte(t), hi_byte(t), resp['h']);
                        pool.addCD(pool.cfg_[pool.isDiscarding_ ? 'r30' : 'r12']);
                        pool.addBtns(resp['a']);
                    }
                    break;
                }
                case 5: {  // 开始出牌
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    pool.isDiscarding_ = true;
                    pool.setTurn(0);
                    if (pool.seat_ != 0) {
                        pool.rmCD();
                        pool.rmBtns();
                    }
                    else {
                        pool.addCD(pool.cfg_['r30']);
                        pool.addBtns(resp['a']);
                    }
                    break;
                }
                case 6: {  // 抓牌
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    let t = resp['t'];
                    pool.turn_ = v;
                    pool.draw((v + 4 - pool.seat_) & 3, hi_byte(t), lo_byte(t), resp['h']);
                    if (pool.seat_ == v) {
                        pool.addCD(pool.cfg_['r30']);
                        pool.addBtns(resp['a']);
                    }
                    break;
                }
                case 7: {  // 出牌
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    pool.discard((v + 4 - pool.seat_) & 3, resp['t'], resp['h']);
                    let a = resp['a'];
                    if (a && a.length > 0) {
                        pool.addCD(pool.cfg_[(((pool.turn_ + 1) & 3) == pool.seat_) ? 'r30' : 'r12']);
                        pool.addBtns(a);
                    }
                    break;
                }
                case 8:  // 吃
                case 9:  // 碰
                {
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    let idx = (v + 4 - pool.seat_) & 3;
                    let p = resp['p'];
                    if (p) {
                        pool['cpk' + idx].call(pool, p);
                    }
                    else {
                        play_snd(!pool.players_[v]['g'] ? (r == 8 ? 'snd/14-chow-m.wav' : 'snd/16-pung-m.wav') : (r == 8 ? 'snd/15-chow-f.wav' : 'snd/17-pung-f.wav'));
                        pool.showCall(idx, r == 8 ? '吃' : '碰');

                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                    }
                    break;
                }
                case 10: {  // 明杠
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    let idx = (v + 4 - pool.seat_) & 3;

                    let p = resp['p'];
                    if (!p) {
                        play_snd(!pool.players_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
                        pool.showCall(idx, '杠');

                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                    }
                    else if (!is_pk(p)) {
                        pool['cpk' + idx].call(pool, p);
                    }
                    else {
                        play_snd(!pool.players_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
                        pool.showCall(idx, '杠');

                        pool['pk' + idx].call(pool, p, false);
                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                    }
                    break;
                }
                case 11: {  // 暗杠
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    play_snd(!pool.players_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
                    let idx = (v + 4 - pool.seat_) & 3;
                    pool.showCall(idx, '杠');
                    pool['ck' + idx].call(pool, resp['p'], false);
                    break;
                }
                case 12: {  // 和
                    if (resp['i'] != ++pool.step_) {
                        console.log('missing step resp.i pool.step_', resp['i'], pool.step_);
                        reenter();
                        return;
                    }

                    let v = resp['v'];
                    let wp = hi_byte(v);
                    let cp = lo_byte(v);
                    let n = (wp + 4 - pool.seat_) & 3;

                    let detail = resp['d'];
                    if (detail == undefined) {
                        play_snd(!pool.players_[wp]['g'] ? 'snd/20-win-m.wav' : 'snd/21-win-f.wav');
                        pool.showCall(n, '和');
                        let a = resp['a'];
                        if (a && a.length > 0) {
                            pool.addCD(pool.cfg_['r12']);
                            pool.addBtns(a);
                        }
                        break;
                    }

                    let succeed = detail['w'];

                    let tiles = resp['t'];
                    pool.op_ht(tiles, succeed, wp, cp, resp['w']);
                    if (!succeed) {
                        pool.falseWin_[n] = true;
                        pool.infoPanels_[n].setFalseWin(true);
                        console.log('错和');
                        if (wp == pool.seat_) {
                            pool.showFalseWin(detail['f'], resp['p']);
                        }
                        break;
                    }
                    pool.rmCD();
                    pool.rmBtns();
                    pool.showSettleView(tiles[wp], resp['w'], resp['p'], detail);
                    break;
                }
                case 13: {  // 流局
                    pool.op_ht(resp['t'], true);
                    pool.showSettleView(null, 0, null, resp['d']);
                    break;
                }
                case 14: {  // 换位
                    pool.step_ = 1;
                    let p = resp['p'];
                    let v = parseInt(resp['v']);
                    pool.seat_ = v;
                    for (let i = 0; i < 4; ++i) {
                        let idx = (i + 4 - v) & 3;
                        let pi = p[i];
                        pool.infoPanels_[idx].setName(pi['n']);
                        pool.infoPanels_[idx].setConnection(!pi['o']);
                    }
                    pool.players_ = p;
                    break;
                }
                case 15: {  // 延时
                    break;
                }
                case 16: {  // 准备
                    let idx = (resp['v'] + 4 - pool.seat_) & 3;
                    pool.ready_[idx].visible = true;
                    break;
                }
                case 17: {  // 对局结束
                    pool.setResult(resp);
                    break;
                }
                case 18: {  // 离线/上线
                    let idx = (resp['v'] + 4 - pool.seat_) & 3;
                    pool.infoPanels_[idx].setConnection(resp['c']);
                    break;
                }
                case 19: // 超时
                    pool.timeout_.visible = true;
                    break;
                default:
                    break;
                }
            }

            setTitle(cfg) {
                this.title_.text = cfg['t'];
                this.pool_.setCfg(cfg);
            }

            reconnect(resp) {
                let pool = this.pool_;
                let cfg = pool.cfg_ = resp['g'];
                this.setTitle(cfg);
                pool.reconnect(resp);
            }
        }

        let showWall = true, openWall = false;

        const OVERLAP = 18, HEIGHT_02F = 78, HEIGHT_13F = 64, GAP_T = 5, GAP_W = 10;
        const WIDTH_02 = 52, HEIGHT_02 = 60,/*78-18=60*/ WIDTH_13 = 70, HEIGHT_13 = 46;/*64-18=46*/
        const WIDTH_13S = 36, HEIGHT_13SF = 83;

        const HAND_WIDTH_02 = WIDTH_02 * 14 + WIDTH_13 * 4 + GAP_T * 5;
        const HAND_HEIGHT_02 = HEIGHT_13 * 2 + OVERLAP;

        const HAND_WIDTH_13 = WIDTH_02 * 2;
        const HAND_HEIGHT_13 = HEIGHT_13 * 14 + HEIGHT_02 * 4 + GAP_T * 5 + OVERLAP;

        const HAND_SCALE = 1.7;//1 + (WIDTH_13 + GAP_T) / (WIDTH_02 * 3);

        const WIND = ['东', '南', '西', '北'];
        const ACTION = ['吃', '碰', '杠', '和', '花', '过', '弃'];

        const EXT_CP_02 = (WIDTH_13 + GAP_T - WIDTH_02) * .5; // (WIDTH_02 * 2 + WIDTH_13 + GAP_T - WIDTH_02 * 3) * .5
        const EXT_DK_02 = (WIDTH_13 + GAP_T) * .5;  // (WIDTH_02 * 3 + WIDTH_13 + GAP_T - WIDTH_02 * 3) * .5
        const EXT_CK_02 = (WIDTH_02 + GAP_T) * .5;

        const EXT_CP_13 = (HEIGHT_02 + GAP_T - HEIGHT_13) * .5; // (HEIGHT_13 * 2 + HEIGHT_02 + GAP_T - HEIGHT_13 * 3) * .5
        const EXT_DK_13 = (HEIGHT_02 + GAP_T) * .5;  //  (HEIGHT_13 * 3 + HEIGHT_02 + GAP_T - HEIGHT_13 * 3) * .5
        const EXT_CK_13 = (HEIGHT_13 + GAP_T) * .5;

        const DOX = [10, 10, -10, -10];
        const DOY = [10, -10, -10, 10];

/*
        const MPO = [
            [PoolTile1, PoolTile0, PoolTile3],
            [PoolTile2, PoolTile1, PoolTile0],
            [PoolTile3, PoolTile2, PoolTile1],
            [PoolTile0, PoolTile3, PoolTile2]
        ];
*/
        const DRAW_DT = 100;
        const SORT_DT = 200;
        const DISCARD_DT = 100;

        /**
         * 牌池中的牌
         * @typedef {object} PoolTile
         */
        class PoolTile extends PIXI.Sprite {
            /**
             * @param {object} tex 纹理
             * @param {number} t 牌张
             */
            constructor(tex, t) {
                super(tex);
                this.t_ = t;
            }
        }

        /**
         * 自己牌池中的牌
         * @typedef {object} PoolTile0
         */
        class PoolTile0 extends PoolTile {
            /**
             * @param {number} t 牌张
             */
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PoolTile.tex0.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                super(tex, t);

                if (tz.nht) {
                    let ht = this.ht_ = new PIXI.extras.BitmapText(hint_text[t >> 2], { font: '24px shsb'});
                    this.addChild(ht);
                    ht.x = 4;
                    ht.y = -2;
                }
            }

            /**
             * 更新牌面
             * @param {number} t 牌张
             */
            update(t) {
                update_t02(this, t);
            }

            /**
             * 重新布局，需在改变锚点后调用
             */
            layout() {
                if (tz.nht) {
                    let ht = this.ht_;
                    if (ht) {
                        ht.x = 4 - WIDTH_02 * this.anchor.x;
                        ht.y = -2 - HEIGHT_02F * this.anchor.y;
                    }
                }
            }
        }

        /**
         * 下家牌池中的牌
         * @typedef {object} PoolTile1
         */
        class PoolTile1 extends PoolTile {
            /**
             * @param {number} t 牌张
             */
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PoolTile.tex1.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_13 + 2) * (ti & 0xF) + 2, (HEIGHT_13F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_13, HEIGHT_13F);
                super(tex, t);

                if (tz.nht) {
                    let ht = this.ht_ = new PIXI.extras.BitmapText(hint_text[t >> 2], { font: '24px shsb'});
                    this.addChild(ht);
                    ht.rotation = -Math.PI * .5;
                    ht.x = 0;
                    ht.y = HEIGHT_13 - 8;
                }
            }

            /**
             * 更新牌面
             * @param {number} t 牌张
             */
            update(t) {
                update_t13(this, t);
            }

            /**
             * 重新布局，需在改变锚点后调用
             */
            layout() {
                if (tz.nht) {
                    let ht = this.ht_;
                    if (ht) {
                        ht.x = - WIDTH_13 * this.anchor.x;
                        ht.y = HEIGHT_13 - 8 - HEIGHT_13F * this.anchor.y;
                    }
                }
            }
        }

        /**
         * 对家牌池中的牌
         * @typedef {object} PoolTile2
         */
        class PoolTile2 extends PoolTile {
            /**
             * @param {number} t 牌张
             */
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PoolTile.tex2.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                super(tex, t);

                if (tz.nht) {
                    let ht = this.ht_ = new PIXI.extras.BitmapText(hint_text[t >> 2], { font: '24px shsb'});
                    this.addChild(ht);
                    ht.rotation = -Math.PI;
                    ht.x = WIDTH_02 - 5;
                    ht.y = HEIGHT_02 - 2;
                }
            }

            /**
             * 更新牌面
             * @param {number} t 牌张
             */
            update(t) {
                update_t02(this, t);
            }

            /**
             * 重新布局，需在改变锚点后调用
             */
            layout() {
                if (tz.nht) {
                    let ht = this.ht_;
                    if (ht) {
                        ht.x = WIDTH_02 - 5 - WIDTH_02 * this.anchor.x;
                        ht.y = HEIGHT_02 - 2 - HEIGHT_02F * this.anchor.y;
                    }
                }
            }
        }

        /**
         * 上家牌池中的牌
         * @typedef {object} PoolTile3
         */
        class PoolTile3 extends PoolTile {
            /**
             * @param {number} t 牌张
             */
            constructor(t) {
                let ti = all_tiles[t];
                let tex = PoolTile.tex3.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_13 + 2) * (ti & 0xF) + 2, (HEIGHT_13F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_13, HEIGHT_13F);
                super(tex, t);

                if (tz.nht) {
                    let ht = this.ht_ = new PIXI.extras.BitmapText(hint_text[t >> 2], { font: '24px shsb'});
                    this.addChild(ht);
                    ht.rotation = Math.PI * .5;
                    ht.x = WIDTH_13;
                    ht.y = 4;
                }
            }

            /**
             * 更新牌面
             * @param {number} t 牌张
             */
            update(t) {
                update_t13(this, t);
            }

            /**
             * 重新布局，需在改变锚点后调用
             */
            layout() {
                if (tz.nht) {
                    let ht = this.ht_;
                    if (ht) {
                        ht.x = WIDTH_13 - WIDTH_13 * this.anchor.x;
                        ht.y = 4 - HEIGHT_13F * this.anchor.y;
                    }
                }
            }
        }

        const CTOR_PT = [PoolTile0, PoolTile1, PoolTile2, PoolTile3];

        /**
         * 桌面牌池
         * @typedef {object} Pool
         */
        class Pool extends PIXI.Container {
            /**
             * 将子结点按zIndex排序（引擎的文档有这个函数，但是调用又报错，所以自己增加了这个）
             */
            sortChildren() {
                let ch = this.children;
                let len = ch.length, i, j, tmp, z;
                for (i = 1; i < len; ++i) {
                    tmp = ch[i];
                    z = tmp.zIndex || 0;
                    j = i - 1;
                    while (j >= 0 && z < (ch[j].zIndex || 0)) {
                        ch[j + 1] = ch[j];
                        --j;
                    }
                    ch[j + 1] = tmp;
                }
            }

            constructor() {
                super();

                const MAX_WIDTH = HAND_WIDTH_13 * 2 + GAP_W * 2 + HAND_WIDTH_02;
                const MAX_HEIGHT = HAND_HEIGHT_02 * 2 + GAP_W * 2 + HAND_HEIGHT_13 + OVERLAP * 2;
                console.log('max width height', MAX_WIDTH, MAX_HEIGHT);

                const CENTER_WIDTH = MAX_WIDTH - HAND_WIDTH_13 * 2 - GAP_W * 4 - WIDTH_02 * 14;
                const CENTER_HEIGHT = MAX_HEIGHT - HAND_HEIGHT_02 * 2 - GAP_W * 4 - HEIGHT_13 * 14 - OVERLAP * 4;

                /*this.width =*/ this.width_ = MAX_WIDTH;
                /*this.height =*/ this.height_ = MAX_HEIGHT;

                this.callTextPos_ = [
                    {'x':MAX_WIDTH * .5, 'y':MAX_HEIGHT - 120, 'ax':.5, 'ay':1},
                    {'x':MAX_WIDTH - 80, 'y':MAX_HEIGHT * .5, 'ax':1, 'ay':.5},
                    {'x':MAX_WIDTH * .5, 'y':80, 'ax':.5, 'ay':0},
                    {'x':80, 'y':MAX_HEIGHT * .5, 'ax':0, 'ay':.5}
                ];

                let graph = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0x89A4C7, .5);
                graph.drawRect(0, 0, MAX_WIDTH, MAX_HEIGHT);
                graph.endFill();
                this.addChild(graph);

                // 中间的面板
                graph = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0, .5);
                graph.drawRect(0, 0, CENTER_WIDTH, CENTER_HEIGHT);
                graph.endFill();
                this.addChild(graph);
                graph.pivot.x = CENTER_WIDTH * .5;
                graph.pivot.y = CENTER_HEIGHT * .5;
                graph.x = MAX_WIDTH * .5;
                graph.y = MAX_HEIGHT * .5;

                // 当前打：X风X
                let text = this.roundText_ = new PIXI.extras.BitmapText('', { font: '80px SourceHanSansBold' });
                text.anchor.set(.5);
                text.x = CENTER_WIDTH * .5;
                text.y = CENTER_HEIGHT * .5 - 25;
                graph.addChild(text);

                // 牌墙剩余
                text = this.remainText_ = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 26,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                text.anchor.set(.5);
                text.x = CENTER_WIDTH * .5;
                text.y = CENTER_HEIGHT * .5 + 40;
                graph.addChild(text);

                // 四家方位及得分
                let windTexts = [null, null, null, null];

                // 人名等信息
                let infoPanels = [null, null, null, null];

                let ready = [null, null, null, null];

                for (let i = 0; i < 4; ++i) {
                    text = new PIXI.Text('', {
                        fontFamily: FF,
                        fontSize: 32,
                        fontWeight: 'bold',
                        fill: '#888888',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    text.anchor.set(.5);
                    graph.addChild(text);
                    windTexts[i] = text;

                    let panel = infoPanels[i] = new InfoPanel();
                    this.addChild(panel);

                    let pos = this.callTextPos_[i];
                    let sp = new PIXI.Sprite(Pool.readyTex);
                    sp.anchor.x = pos['ax'];
                    sp.anchor.y = pos['ay'];
                    sp.x = pos['x'];
                    sp.y = pos['y'];
                    sp.zIndex = 501;
                    this.addChild(sp);
                    ready[i] = sp;
                }

                const WIND_OFFSET = 25;

                windTexts[0].x = CENTER_WIDTH * .5;
                windTexts[0].y = CENTER_HEIGHT - WIND_OFFSET;

                windTexts[1].x = CENTER_WIDTH - WIND_OFFSET;
                windTexts[1].y = CENTER_HEIGHT * .5;
                windTexts[1].rotation = -Math.PI * .5;

                windTexts[2].x = CENTER_WIDTH * .5;
                windTexts[2].y = WIND_OFFSET;
                windTexts[2].rotation = Math.PI;

                windTexts[3].x = WIND_OFFSET;
                windTexts[3].y = CENTER_HEIGHT * .5;
                windTexts[3].rotation = Math.PI * .5;

                this.windTexts_ = windTexts;

                const INFO_OFFSET_X_02 = (MAX_WIDTH - CENTER_WIDTH) * .5 - 5;
                const INFO_OFFSET_Y_02 = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - 100;
                const INFO_OFFSET_X_13 = (MAX_WIDTH - CENTER_WIDTH) * .5 - 100 - OVERLAP;
                const INFO_OFFSET_Y_13 = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - 5 - OVERLAP;

                infoPanels[0].x = INFO_OFFSET_X_02;
                infoPanels[0].y = MAX_HEIGHT - INFO_OFFSET_Y_02;

                infoPanels[1].x = MAX_WIDTH - INFO_OFFSET_X_13;
                infoPanels[1].y = MAX_HEIGHT - INFO_OFFSET_Y_13;
                infoPanels[1].rotation = -Math.PI * .5;

                infoPanels[2].x = MAX_WIDTH - INFO_OFFSET_X_02;
                infoPanels[2].y = INFO_OFFSET_Y_02;
                infoPanels[2].rotation = Math.PI;

                infoPanels[3].x = INFO_OFFSET_X_13;
                infoPanels[3].y = INFO_OFFSET_Y_13;
                infoPanels[3].rotation = Math.PI * .5;

                this.infoPanels_ = infoPanels;

                this.cfgText1_ = text = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                });
                text.alpha = .5;
                text.anchor.y = .5;
                this.addChild(text);
                text.x = 130;
                text.y = HEIGHT_02F + 25;

                this.cfgText2_ = text = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 22,
                    fill: '#ffffff',
                });
                text.alpha = .5;
                text.anchor.y = .5;
                this.addChild(text);
                text.x = INFO_OFFSET_X_13 - 160;
                text.y = INFO_OFFSET_Y_13 - 210;

                this.sp_ = text = new PIXI.Text('-', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                });
                this.addChild(text);
                text.anchor.set(.5);
                text.x = 60;
                text.y = 150;

                this.ready_ = ready;

                text = new PIXI.Text('文明游戏 禁止赌博', {
                    fontFamily: FF,
                    fontSize: 22,
                    fill: '#ffffff',
                });
                this.addChild(text);
                text.anchor.x = 1;
                text.anchor.y = .5;
                text.x = MAX_WIDTH - 10;
                text.y = this.cfgText1_.y;

                text = this.cst_ = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 22,
                    fill: '#dedede',
                });
                this.addChild(text);
                text.anchor.x = 1;
                text.anchor.y = .5;
                text.x = MAX_WIDTH - INFO_OFFSET_X_13 + 160;
                text.y = MAX_HEIGHT - INFO_OFFSET_Y_13 + 215;//180+35;

                {
                    // 四家牌墙
                    let walls = [new Array(36), new Array(36), new Array(36), new Array(36)];
                    let x, y;

                    // 上家
                    if (!openWall) {
                        x = HAND_WIDTH_13 + GAP_W;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 - OVERLAP - HEIGHT_13 * 18;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let realIdx = (17 - pier) * 2 + (1 - down);

                            let t = create_w13();
                            this.addChild(t);
                            walls[3][realIdx] = t;
                            t.x = x;
                            t.y = y + HEIGHT_13 * pier - OVERLAP * down;
                        }
                    }
                    else {
                        x = HAND_WIDTH_13 + GAP_W + WIDTH_13;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 * 2 + OVERLAP - HEIGHT_13 * 18;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = 1 - (i & 1);
                            let realIdx = (17 - pier) * 2 + down;

                            let t = create_w13();
                            this.addChild(t);
                            walls[3][realIdx] = t;
                            t.x = x - WIDTH_13 * down;
                            t.y = y + HEIGHT_13 * pier;
                        }
                    }

                    // 对家
                    if (!openWall) {
                        x = HAND_WIDTH_13 + GAP_W + WIDTH_13;
                        y = HAND_HEIGHT_02 + GAP_W + OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let realIdx = pier * 2 + (1 - down);

                            let t = create_w02();
                            this.addChild(t);
                            walls[2][realIdx] = t;
                            t.x = x + WIDTH_02 * pier;
                            t.y = y - OVERLAP * down;
                        }
                    }
                    else {
                        x = HAND_WIDTH_13 + GAP_W + WIDTH_13 * 2;
                        y = HAND_HEIGHT_02 + GAP_W + HEIGHT_02 - OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = 1 - (i & 1);
                            let realIdx = pier * 2 + down;

                            let t = create_w02();
                            this.addChild(t);
                            walls[2][realIdx] = t;
                            t.x = x + WIDTH_02 * pier;
                            t.y = y - HEIGHT_02 * down;
                        }
                    }

                    // 下家
                    if (!openWall) {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13;
                        y = HAND_HEIGHT_02 + GAP_W + HEIGHT_02 + OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let realIdx = pier * 2 + (1 - down);

                            let t = create_w13();
                            this.addChild(t);
                            walls[1][realIdx] = t;
                            t.x = x;
                            t.y = y + HEIGHT_13 * pier - OVERLAP * down;
                        }
                    }
                    else {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13 * 2;
                        y = HAND_HEIGHT_02 + GAP_W + HEIGHT_02 * 2 - OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);

                            let t = create_w13();
                            this.addChild(t);
                            walls[1][i] = t;
                            t.x = x + WIDTH_13 * down;
                            t.y = y + HEIGHT_13 * pier;
                        }
                    }

                    // 自己
                    if (!openWall) {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13 - WIDTH_02;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 - OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = 1 - (i & 1);
                            let realIdx = pier * 2 + down;

                            let t = create_w02();
                            this.addChild(t);
                            walls[0][realIdx] = t;
                            t.x = x - WIDTH_02 * pier;
                            t.y = y + OVERLAP * (down-1);
                        }
                    }
                    else {
                        x = MAX_WIDTH - HAND_WIDTH_13 - GAP_W - WIDTH_13 * 2 - WIDTH_02;
                        y = MAX_HEIGHT - HAND_HEIGHT_02 - GAP_W - HEIGHT_02 * 2 + OVERLAP;
                        for (let i = 0; i < 36; ++i) {
                            let pier = (i >> 1), down = (i & 1);
                            let t = create_w02();
                            this.addChild(t);
                            walls[0][i] = t;
                            t.x = x - WIDTH_02 * pier;
                            t.y = y + HEIGHT_02 * down;
                        }
                    }

                    // 测试顺序
                    //for (let i = 0; i < 4; ++i) {
                    //    for (let n = 0; n < 15; ++n) {
                    //        walls[i][n].visible = false;
                    //    }
                    //}

                    this.walls_ = walls;

                    if (!showWall) {
                        for (let i = 0; i < 36; ++i) {
                            walls[0][i].visible = false;
                            walls[1][i].visible = false;
                            walls[2][i].visible = false;
                            walls[3][i].visible = false;
                        }
                    }
                }

                // ZINDEX分配：
                // 下家 牌池100-129 副露150-169 立牌130-149
                // 对家 牌池210-239 副露170-189 立牌190-209
                // 上家 牌池280-309 副露240-259 立牌260-279
                // 自己 牌池310-339 副露340-359 立牌360-379

                // 四家牌池
                let pools = [new Array(24), new Array(24), new Array(24), new Array(24)];
                let x, y;

                // 下家
                x = (MAX_WIDTH + CENTER_WIDTH) * .5;
                y = (MAX_HEIGHT + CENTER_HEIGHT) * .5 - HEIGHT_13 * 6;
                for (let i = 0; i < 24; ++i) {
                    let col = Math.floor(i / 6), row = (i % 6);
                    let realIdx = col * 6 + (5 - row);

                    let t = new PoolTile1(0);
                    this.addChild(t);
                    t.zIndex = 100 + i;
                    pools[1][realIdx] = t;
                    t.x = x + WIDTH_13 * col;
                    t.y = y + HEIGHT_13 * row;
                    t.visible = false;
                }

                // 对家
                x = (MAX_WIDTH + CENTER_WIDTH) * .5 - WIDTH_02;
                y = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - HEIGHT_02 * 4 - OVERLAP;
                for (let i = 0; i < 24; ++i) {
                    let col = (i % 6), row = Math.floor(i / 6);
                    let realIdx = (3 - row) * 6 + col;

                    let t = new PoolTile2(0);
                    this.addChild(t);
                    t.zIndex = 210 + i;
                    pools[2][realIdx] = t;
                    t.x = x - WIDTH_02 * col;
                    t.y = y + HEIGHT_02 * row;
                    t.visible = false;
                }

                // 上家
                x = (MAX_WIDTH - CENTER_WIDTH) * .5 - WIDTH_13;
                y = (MAX_HEIGHT - CENTER_HEIGHT) * .5 - OVERLAP;
                for (let i = 0; i < 24; ++i) {
                    let t = new PoolTile3(0);
                    this.addChild(t);
                    t.zIndex = 280 + i;
                    pools[3][i] = t;
                    t.x = x - WIDTH_13 * Math.floor(i / 6);
                    t.y = y + HEIGHT_13 * (i % 6);
                    t.visible = false;
                }

                // 自己
                x = (MAX_WIDTH - CENTER_WIDTH) * .5;
                y = (MAX_HEIGHT + CENTER_HEIGHT) * .5;
                for (let i = 0; i < 24; ++i) {
                    let t = new PoolTile0(0);
                    this.addChild(t);
                    t.zIndex = 310 + i;
                    pools[0][i] = t;
                    t.x = x + WIDTH_02 * (i % 6);
                    t.y = y + HEIGHT_02 * Math.floor(i / 6);
                    t.visible = false;
                }

                this.pools_ = pools;

                // 测试顺序
                //for (let i = 0; i < 4; ++i) {
                //    for (let n = 0; n < 15; ++n) {
                //        pools[i][n].visible = true;
                //    }
                //}

                // 四家手牌
                let sta = [new Array(14), new Array(14), new Array(14), new Array(14)];
                let ori = [new Array(14), new Array(14), new Array(14), new Array(14)];

                // 上家
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect(0, (MAX_HEIGHT - HAND_HEIGHT_13) * .5, HAND_WIDTH_13, HAND_HEIGHT_13);
                    graph.endFill();
                    this.addChild(graph);

                    y = (MAX_HEIGHT - HAND_HEIGHT_13) * .5;
                    for (let i = 0; i < 4; ++i) {
                        for (let k = 0; k < 3; ++k) {
                            let t = new PoolTile3(0x41 + i);
                            t.y = y;
                            y += HEIGHT_13;
                            this.addChild(t);
                        }

                        let t = new PoolTile0(0x41 + i);
                        t.y = y;
                        y += HEIGHT_02 + GAP_T;
                        this.addChild(t);
                    }

                    let t = new PoolTile3(0x45);
                    t.y = y;
                    y += HEIGHT_13 + GAP_T;
                    this.addChild(t);

                    t = new PoolTile3(0x45);
                    t.y = y;
                    this.addChild(t);
*/

                    y = MAX_HEIGHT * .5 - (HEIGHT_13 * 13 + HEIGHT_13SF + GAP_T) * .5;
                    for (let i = 0; i < 14; ++i) {
                        let sp = create_st3();
                        this.addChild(sp);
                        sp.zIndex = 260 + i;
                        let yy = y + HEIGHT_13 * i + ((i != 13) ? 0 : GAP_T);
                        ori[3][i] = yy;
                        sp.y = yy;
                        sta[3][i] = sp;
                    }
                }

                // 对家
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect((MAX_WIDTH - HAND_WIDTH_02) * .5, 0, HAND_WIDTH_02, HAND_HEIGHT_02);
                    graph.endFill();
                    this.addChild(graph);

                    x = (MAX_WIDTH + HAND_WIDTH_02) * .5;
                    for (let i = 0; i < 4; ++i) {
                        for (let k = 0; k < 3; ++k) {
                            let t = new PoolTile2(0x41 + i);
                            x -= WIDTH_02;
                            t.x = x;
                            this.addChild(t);
                        }

                        let t = new PoolTile3(0x41 + i);
                        x -= WIDTH_13;
                        t.x = x;
                        x -= GAP_T;
                        this.addChild(t);
                    }

                    let t = new PoolTile2(0x45);
                    x -= WIDTH_02;
                    t.x = x;
                    x -= GAP_T;
                    this.addChild(t);

                    t = new PoolTile2(0x45);
                    x -= WIDTH_02;
                    t.x = x;
                    this.addChild(t);
*/

                    x = MAX_WIDTH * .5 + (WIDTH_02 * 14 + GAP_T) * .5;
                    for (let i = 0; i < 14; ++i) {
                        let sp = create_st2();
                        this.addChild(sp);
                        sp.zIndex = 190 + i;
                        let xx = x - WIDTH_02 * (i + 1) - ((i != 13) ? 0 : GAP_T);
                        ori[2][i] = xx;
                        sp.x = xx;
                        sta[2][i] = sp;
                    }
                }

                // 下家
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect(MAX_WIDTH - HAND_WIDTH_13, (MAX_HEIGHT - HAND_HEIGHT_13) * .5, HAND_WIDTH_13, HAND_HEIGHT_13);
                    graph.endFill();
                    this.addChild(graph);

                    y = (MAX_HEIGHT - HAND_HEIGHT_13) * .5;

                    let t = new PoolTile1(0x45);
                    t.x = MAX_WIDTH - WIDTH_13;
                    t.y = y;
                    y += HEIGHT_13 + GAP_T;
                    this.addChild(t);

                    t = new PoolTile1(0x45);
                    t.x = MAX_WIDTH - WIDTH_13;
                    t.y = y;
                    y += HEIGHT_13 + GAP_T;
                    this.addChild(t);

                    for (let i = 0; i < 4; ++i) {
                        for (let k = 0; k < 3; ++k) {
                            let t = new PoolTile1(0x41 + i);
                            t.x = MAX_WIDTH - WIDTH_13;
                            t.y = y;
                            y += HEIGHT_13;
                            this.addChild(t);
                        }

                        let t = new PoolTile0(0x41 + i);
                        t.x = MAX_WIDTH - WIDTH_02;
                        t.y = y;
                        y += HEIGHT_02 + GAP_T;
                        this.addChild(t);
                    }
*/

                    y = MAX_HEIGHT * .5 - (HEIGHT_13 * 13 + HEIGHT_13SF + GAP_T) * .5 + GAP_T;
                    for (let i = 0; i < 14; ++i) {
                        let sp = create_st1();
                        this.addChild(sp);
                        sp.zIndex = 130 + i;
                        sp.x = MAX_WIDTH - WIDTH_13S;
                        let yy = y + ((i != 0) ? HEIGHT_13 * i : -GAP_T);
                        ori[1][13 - i] = yy;
                        sp.y = yy;
                        sta[1][13 - i] = sp;
                    }
                }

                // 自己
                {
/*
                    let graph = new PIXI.Graphics();
                    graph.lineStyle(2, 0x0000FF, 1);
                    graph.beginFill(0xFF00BB, .25);
                    graph.drawRect((MAX_WIDTH - HAND_WIDTH_02) * .5, MAX_HEIGHT - HAND_HEIGHT_02, HAND_WIDTH_02, HAND_HEIGHT_02);
                    graph.endFill();
                    this.addChild(graph);
*/

                    x = (MAX_WIDTH - (WIDTH_02 * 14 + GAP_T) * HAND_SCALE) * .5;
                    for (let i = 0; i < 14; ++i) {
                        let sp = new StandingTile(i, (sp)=>{ this._click(sp); });
                        this.addChild(sp);
                        sp.zIndex = 360 + i;
                        sp.scale.set(HAND_SCALE);
                        sp.anchor.y = 1;
                        sp.layout();
                        sp.y = MAX_HEIGHT;
                        let xx = x + (WIDTH_02 * i + ((i != 13) ? 0 : GAP_T)) * HAND_SCALE;
                        ori[0][i] = xx;
                        sp.x = xx;
                        sta[0][i] = sp;
                    }
                }

                this.players_ = [{}, {}, {}, {}];
                this.origin_ = ori;
                this.standing_ = sta;
                this.packs_ = [[], [], [], []];
                this.packData_ = [[], [], [], []];
                this.flowers_ = [0, 0, 0, 0];
                this.falseWin_ = [false, false, false, false];
                this.seat_ = 0;
                this.turn_ = 0;
                this.flyTile_ = null;
                this.openTiles_ = [[], [], [], []];
                this.openPos_ = [0, 0, 0, 0];
                this.step_ = 0;
                this.stopFlower_ = false;
                this.rdfsh_ = false;
                this.callFlags_ = new Array(34);
                this.ignoreSD_ = false;
                this.rightWaive_ = false;

/*
                // TODO:
                btn = new TextButton('请求退出', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{ console.log('请求退出'); });
                this.addChild(btn);
                btn.zIndex = 500;
*/

                let btn = new TextButton('设置', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    if (this.sv_) {
                        return;
                    }

                    let sv = this.sv_ = new SettingView(MAX_WIDTH, MAX_HEIGHT, ()=>{
                        this.sv_.dstry();
                        delete this.sv_;
                    });
                    this.addChild(sv);
                    sv.zIndex = 500;
                    sv.scale.set(1.25);
                    sv.x = (MAX_WIDTH - sv.width) * .5;
                    sv.y = (MAX_HEIGHT - sv.height) * .5;

                });
                this.addChild(btn);
                btn.zIndex = 500;

                btn = new TextButton('测速', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    tz.ws.send(`{"m":5,"t":${new Date().getTime()}}`);
                    this.sp_.ac_ = setTimeout(()=>{
                        this.sp_.text = '-';
                    }, 60000);
                });
                this.addChild(btn);
                btn.y = 70;
                btn.zIndex = 500;

                btn = new TextButton('鸣牌设置', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    this.showCallOpt();
                });
                this.addChild(btn);
                btn.zIndex = 500;
                btn.x = MAX_WIDTH - 120;
                btn.y = MAX_HEIGHT - 200;

                btn = new TextButton('计分表', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    this.showHistory();
                });
                this.addChild(btn);
                btn.zIndex = 500;
                btn.y = MAX_HEIGHT - 270;

                btn = new TextButton('追分策略', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 60, ()=>{
                    this.showChase();
                });
                this.addChild(btn);
                btn.zIndex = 500;
                btn.y = MAX_HEIGHT - 200;

                graph = this.cd_ = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0, .5);
                graph.drawCircle(25, 25, 50);
                graph.endFill();
                this.addChild(graph);
                graph.zIndex = 500;
                graph.pivot.x = CENTER_WIDTH * .5;
                graph.pivot.y = CENTER_HEIGHT * .5;
                graph.x = MAX_WIDTH * .5;
                graph.y = MAX_HEIGHT * .5;
                graph.x = MAX_WIDTH;
                graph.y = MAX_HEIGHT - 260;

                text = graph.text_ = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 48,
                    fill: '#dedede',
                    //stroke: '#0066ff',
                    //strokeThickness: 2,
                });
                text.anchor.set(.5);
                graph.addChild(text);
                text.x = 25;
                text.y = 25;
                graph.visible = false;

                // 吃碰杠和花过弃按钮，最多同时亮5个，预留6个位（吃碰杠和过弃）
                // 此处从右往左排
                let actionBtns = new Array(6);
                for (let i = 0; i < 6; ++i) {
                    let ab = actionBtns[i] = new ActionButton();
                    this.addChild(ab);
                    ab.zIndex = 500;
                    ab.x = MAX_WIDTH - 190 * i - 260;
                    ab.y = MAX_HEIGHT - 300;
                    ab.visible = false;
                }
                this.actionBtns_ = actionBtns;

                let view = this.historyView_ = new HistoryView(MAX_WIDTH, MAX_HEIGHT);
                this.addChild(view);
                view.zIndex = 500;
                view.visible = false;

                view = this.chaseView_ = new ChaseView(MAX_WIDTH, MAX_HEIGHT);
                this.addChild(view);
                view.zIndex = 500;
                view.visible = false;

                view = this.callView_ = new CallView(MAX_WIDTH, MAX_HEIGHT, (cf, ign, rw)=>{
                    this.callFlags_ = cf;
                    this.ignoreSD_ = ign;
                    this.rightWaive_ = rw;
                });
                this.addChild(view);
                view.zIndex = 500;
                view.visible = false;

                text = this.timeout_ = new PIXI.Text('你已超时，服务器自动托管，刷新页面可解除', {
                    fontFamily: FF,
                    fontSize: 50,
                    fill: '#dedede',
                    //stroke: '#0066ff',
                    //strokeThickness: 2,
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.zIndex = 500;
                text.x = MAX_WIDTH * .5;
                text.y = MAX_HEIGHT - 200;
                text.visible = false;
                scaleText(text, MAX_WIDTH - 50);

                this.sortChildren();
            }

            /**
             * 开始当前局计时
             * @param {number} ts 当前时间戳（服务器传过来）
             */
            startup(ts) {
                if (this.cstr_) {
                    clearInterval(this.cstr_);
                    this.cstr_ = null;
                }
                this.stts_ = Math.min(ts, new Date().getTime());
                this.cstr_ = setInterval(()=>{
                    let s = Math.floor((new Date().getTime() - this.stts_) / 1000);
                    let m = Math.floor(s / 60);
                    s -= m * 60;
                    this.cst_.text = `${pad2(m)}:${pad2(s)}`;
                }, 200);
            }

            /**
             * 设置当前桌配置信息
             * @param {object} cfg 配置
             */
            setCfg(cfg) {
                this.cfgText1_.text = `${cfg['n']}盘 ${cfg['l']}番 (${cfg['b']}) ${cfg['r30']}/${cfg['r12']}秒`;
                this.cfgText2_.text = `${((cfg['s'])?'有':'无')}战术鸣牌 结束${(cfg['o'])?'':'不'}显示手牌\n错和${(cfg['fa'])?'-30/+10':'-40/+0'} ${cfg['fc']?'':'不'}允许鸣牌`;
            }

            /**
             * 设置整个牌池（用于重联时载入数据）
             * @param {array} t 牌池
             */
            setupPool(t) {
                for (let i = 0; i < 4; ++i) {
                    let ti = t[(this.seat_ + i) & 3];
                    for (let k = 0; k < 24 && k < ti.length; ++k) {
                        let spk = this.pools_[i][k];
                        spk.visible = spk.v_ = true;
                        spk.update(ti[k]);
                    }
                    for (let k = ti.length; k < 24; ++k) {
                        let spk = this.pools_[i][k];
                        spk.visible = spk.v_ = false;
                    }
                }
            }

            clear() {
                for (let i = 0; i < 4; ++i) {
                    for (let k = 0; k < 24; ++k) {
                        let sp = this.pools_[i][k];
                        sp.visible = sp.v_ = false;
                    }

                    if (showWall) {
                        for (let k = 0; k < 36; ++k) {
                            this.walls_[i][k].visible = true;
                        }
                    }

                    this.flowers_[i] = 0;
                    this.falseWin_[i] = false;
                    this.infoPanels_[i].reset();
                    this.ready_[i].visible = false;

                    let sp;
                    while (sp = this.packs_[i].pop()) {
                        sp.dstry();
                    }

                    while (sp = this.openTiles_[i].pop()) {
                        sp.dstry();
                    }

                    this.openPos_[i] = this.origin_[i][0];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[0][k];
                    sp.visible = false;
                    sp.x = this.origin_[0][k];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[1][k];
                    sp.visible = false;
                    sp.y = this.origin_[1][k];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[2][k];
                    sp.visible = false;
                    sp.x = this.origin_[2][k];
                }

                for (let k = 0; k < 14; ++k) {
                    let sp = this.standing_[3][k];
                    sp.visible = false;
                    sp.y = this.origin_[3][k];
                }

                if (this.flyTile_) {
                    this.flyTile_.dstry();
                    this.flyTile_ = null;
                }

                this.packData_ = [[], [], [], []];
                this.stopFlower_ = false;
                this.timeout_.visible = false;
                this.callFlags_ = new Array(34);
                this.ignoreSD_ = false;
                this.rightWaive_ = false;
                this.callView_.reset_ = true;
            }

            /**
             * 发牌
             * @param {array} d 骰子
             * @param {array} h 手牌
             */
            sendHandTiles(d, h) {
                this.rdfsh_ = false;
                this.closeSettleView();

                this.remainText_.text = '牌墙剩余：144';

                let seat = this.seat_;
                for (let i = 0; i < 4; ++i) {
                    let k = (seat + i) & 3;
                    this.windTexts_[i].text = WIND[k] + ' ' + this.players_[k]['s'];
                }
                this.setTurn(0);

                let dir = (d[0] + d[1] - 1 + 4 - seat) & 3;
                let off = d[0] + d[1] + d[2] + d[3];
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                this.backPier_ = off > 0 ? {'dir':dir,'off':off - 1,'down':false} : {'dir':(dir+1)&3,'off':17,'down':false};
                this.openPier_ = {'dir':dir, 'off':off, 'down':false};
                this.remainCnt_ = 144;

                // 骰子
                let dss = [null, null];
                for (let i = 0; i < 2; ++i) {
                    let ds = createDice(d[i]);
                    this.addChild(ds);
                    ds.zIndex = 499;
                    ds.x = 600 - 25 + i * 50;
                    ds.y = 450 - 25 + i * 50;
                    dss[i] = ds;
                }

                play_snd('snd/02-dice.wav');
                let dir2 = (d[0] + d[1] - 1 + 4) & 3;
                setTimeout(()=>{
                    dss[0].dstry();
                    dss[1].dstry();
                    this.setTurn(dir2);
                    play_snd('snd/02-dice.wav');

                    for (let i = 0; i < 2; ++i) {
                        let ds = createDice(d[i + 2]);
                        this.addChild(ds);
                        ds.zIndex = 499;
                        ds.x = 600 - 25 + i * 50;
                        ds.y = 450 - 25 + i * 50;
                        dss[i] = ds;
                    }
                }, 1000);
                setTimeout(()=>{
                    dss[0].dstry();
                    dss[1].dstry();
                    this.setTurn(0);
                }, 2000);

                const DICE_TIME = 2000;

                // 每人3手*4张
                for (let i = 0; i < 12; ++i) {
                    for (let k = 0; k < 2; ++k) {
                        let sp1 = this.walls_[dir][off * 2];
                        setTimeout(()=>{
                            this.setTurn(i & 3);
                            --this.remainCnt_;
                            this._drawEffect((i + 4 - seat) & 3, sp1, (i & 0xFC) + k * 2);
                        }, DICE_TIME + i * DRAW_DT);

                        let sp2 = this.walls_[dir][off * 2 + 1];
                        setTimeout(()=>{
                            --this.remainCnt_;
                            this._drawEffect((i + 4 - seat) & 3, sp2, (i & 0xFC) + k * 2 + 1);
                        }, DICE_TIME + i * DRAW_DT);

                        ++off;
                        if (off >= 18) {
                            off -= 18;
                            dir = (dir + 3) & 3;
                        }
                    }
                }

                // 跳牌
                let sp1 = this.walls_[dir][off * 2];
                setTimeout(()=>{
                    this.setTurn(0);
                    --this.remainCnt_;
                    this._drawEffect((4 - seat) & 3, sp1, 12);
                }, DICE_TIME + 12 * DRAW_DT);

                let sp2 = this.walls_[dir][off * 2 + 1];
                setTimeout(()=>{
                    this.setTurn(1);
                    --this.remainCnt_;
                    this._drawEffect((5 - seat) & 3, sp2, 12);
                }, DICE_TIME + 13 * DRAW_DT);

                ++off;
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                let sp3 = this.walls_[dir][off * 2];
                setTimeout(()=>{
                    this.setTurn(2);
                    --this.remainCnt_;
                    this._drawEffect((6 - seat) & 3, sp3, 12);
                }, DICE_TIME + 14 * DRAW_DT);

                let sp4 = this.walls_[dir][off * 2 + 1];
                setTimeout(()=>{
                    this.setTurn(3);
                    --this.remainCnt_;
                    this._drawEffect((7 - seat) & 3, sp4, 12);
                }, DICE_TIME + 15 * DRAW_DT);

                ++off;
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                let sp5 = this.walls_[dir][off * 2];
                setTimeout(()=>{
                    --this.remainCnt_;
                    this._drawEffect((4 - seat) & 3, sp5, 13);
                }, DICE_TIME + 12 * DRAW_DT);

                this.frontPier_ = {'dir':dir,'off':off,'down':true};

                // 理牌
                for (let i = 0; i < 13; ++i) {
                    let sp = this.standing_[0][i];
                    sp.update(h[i]);
                }
                if (this.seat_ == 0) {
                    this.standing_[0][13].update(h[13]);
                }
                else {
                    this.standing_[0][13].t_ = 0xFF;
                }

                setTimeout(()=>{
                    this.setTurn(0);

                    let sta, ori;

                    // 上家
                    ori = this.origin_[3];
                    sta = this.standing_[3];

                    shuffle_array(sta, 0, 13);
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 260 + i;
                        if (sp.y != ori[i]) {
                            (new TWEEN.Tween(sp)).to({y:ori[i]}, SORT_DT).start();
                        }
                    }

                    // 对家
                    ori = this.origin_[2];
                    sta = this.standing_[2];

                    shuffle_array(sta, 0, 13);
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 190 + i;
                        if (sp.x != ori[i]) {
                            (new TWEEN.Tween(sp)).to({x:ori[i]}, SORT_DT).start();
                        }
                    }

                    // 下家
                    ori = this.origin_[1];
                    sta = this.standing_[1];

                    shuffle_array(sta, 0, 13);
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 130 + 13 - i;
                        if (sp.y != ori[i]) {
                            (new TWEEN.Tween(sp)).to({y:ori[i]}, SORT_DT).start();
                        }
                    }

                    // 自己
                    ori = this.origin_[0];
                    sta = this.standing_[0];

                    sta.sort(function(a, b) { return a.t_ - b.t_; });
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 360 + i;
                        if (sp.x != ori[i]) {
                            (new TWEEN.Tween(sp)).to({x:ori[i]}, SORT_DT).start();
                        }
                    }

                    this.sortChildren();
                }, DICE_TIME + 18 * DRAW_DT);
            }

            /**
             * 发牌（用于换圈后，多一个提示的过程）
             * @param {array} d 骰子
             * @param {array} h 手牌
             */
            sendHandTiles2(d, h) {
                let ww = this.width_, hh = this.height_, w2 = 500, h2 = 400;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.beginFill(0, 0);
                bg.drawRect(0, 0, ww, hh);
                bg.endFill();

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect((ww - w2) * .5, (hh - h2) * .5, w2, h2);
                bg.endFill();

                let text = new PIXI.Text(WIND[this.rd_ >> 2] + '风圈', {
                    fontFamily: FF,
                    fontSize: 128,
                    fill: '#ffffff',
                    fontWeight:'bold',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                text.anchor.set(.5);
                text.x = ww * .5;
                text.y = hh * .5;
                bg.addChild(text);

                (new TWEEN.Tween(bg)).to({alpha:0}, 200).delay(1300).start();

                setTimeout(()=>{ bg.dstry(); this.sendHandTiles(d, h); }, 1500);
                play_snd(this.rd_ ? 'snd/25-xchg.wav' : 'snd/01-start.wav');
            }

            /**
             * 设置轮次：轮到谁出牌
             * @param {number} t 轮次
             */
            setTurn(t) {
                this.turn_ = t;
                let n = (t + 4 - this.seat_) & 3;
                for (let i = 0; i < 4; ++i) {
                    this.windTexts_[i].style.fill = (i != n) ? '#888888' : '#ff6a6a';
                }
            }


            /**
             * 添加读秒
             * @param {number} sec 时间（秒）
             */
            addCD(sec) {
                let cd = this.cd_;
                let t = cd.text_;
                if (t.timer_) {
                    clearInterval(t.timer_);
                    delete t.timer_;
                }
                t.text = sec;

                t.end_ = new Date().getTime() + sec * 1000;
                t.timer_ = setInterval(()=>{
                    let n = (t.end_ - new Date().getTime());
                    let s = Math.round(n / 1000);
                    if (s > 0) {
                        let tt = parseInt(t.text);
                        if (tt != s) {
                            t.text = s;
                            if (!tz.mutecd && s <= 3) {
                                play_snd('snd/03-cd.wav');
                            }
                        }
                    }
                    else {
                        cd.visible = false;
                        clearInterval(t.timer_);
                        delete t.timer_;
                    }
                }, 100);
                cd.visible = true;
            }

            /**
             * 移除读秒
             */
            rmCD() {
                let cd = this.cd_;
                let t = cd.text_;
                if (t.timer_) {
                    clearInterval(t.timer_);
                    delete t.timer_;
                }
                cd.visible = false;
            }

            /**
             * 添加鸣牌按钮
             * @param {array} a 可选择的鸣牌
             */
            addBtns(a) {
                let selfDrawn = (this.turn_ == this.seat_);

                // 别人打牌，设置了不鸣这张，直接过或者弃
                if (!selfDrawn && this.flyTile_ != null && this.callFlags_[this.flyTile_.t_>>2]) {
                    tz.ws.send(this.rightWaive_ ? '{"m":2,"r":10,"v":0}' : '{"m":2,"r":9,"v":0}');
                    this.rmCD();
                    return;
                }

                let status = this.option_.status();

                if (!a) {
                    if (status[6] && selfDrawn) {  // 自动摸打
                        setTimeout(()=>{
                            this._discard(this.standing_[0][13]);
                        }, DISCARD_DT + 1000);
                    }
                    return;
                }

                let dict = {}, size = 0;
                for (let i = 0, len = a.length; i < len; ++i) {
                    let ac = a[i];
                    let type = (ac >> 16) & 0xFFFF, data = (ac & 0xFFFF);
                    if (dict[type] == undefined) {
                        dict[type] = [data];
                        ++size;
                    } else {
                        dict[type].push(data);
                    }
                }
                if (size == 0) {
                    return;
                }

                if (status[0] && dict[1] && !this.stopFlower_ ) {  // 自动补花
                    setTimeout(()=>{
                        tz.ws.send('{"m":2,"r":1,"v":0}');
                        this.rmCD();
                    }, DISCARD_DT * 2);
                    return;
                }

                if (status[1] && dict[3]) {  // 不吃
                    --size;
                    delete dict[3];
                }
                if (status[2] && dict[4]) {  // 不碰
                    --size;
                    delete dict[4];
                }
                if (status[3] && dict[5]) {  // 不杠
                    --size;
                    delete dict[5];
                }

                // 可和
                if (dict[6]) {
                    let skp = false;
                    if (status[4] && !selfDrawn) {  // 只和自摸
                        --size;
                        delete dict[6];
                        skp = true;
                    }

                    if (selfDrawn && this.ignoreSD_ && this.callFlags_[this.standing_[0][13].t_>>2]) {
                        --size;
                        delete dict[6];
                        skp = true;
                    }

                    if (!skp && status[5]) {  // 自动和牌
                        setTimeout(()=>{
                            tz.ws.send(`{"m":2,"r":6,"v":${dict[6][0]}}`);
                            this.rmCD();
                        }, DISCARD_DT * 2);
                        return;
                    }
                }

                if (status[6]) {  // 自动摸打
                    if (!dict[6] && !dict[5] &&!dict[1] && selfDrawn) {
                        setTimeout(()=>{
                            this._discard(this.standing_[0][13]);
                        }, DISCARD_DT + 1000);
                        return;
                    }
                }

                // 过滤之后没有动作了
                if (size == 0) {
                    if (!selfDrawn) {
                        tz.ws.send(this.rightWaive_ ? '{"m":2,"r":10,"v":0}' : '{"m":2,"r":9,"v":0}');
                        this.rmCD();
                    }
                    return;
                }

                // 插入“过”
                dict[9] = [];
                ++size;

                dict[10] = [];
                ++size;

                const types = [10, 9, 1, 6, 5, 4, 3];
                let cnt = 0;
                for (let i = 0; i < 7; ++i) {
                    let val = dict[types[i]];
                    if (val) {
                        let ab = this.actionBtns_[cnt];
                        ab.visible = true;
                        ab.setup(6 - i, (ab)=>{
                            //console.log(ab.data_);
                            switch (ab.data_.length) {
                            case 0:
                                this.rmBtns();
                                tz.ws.send(`{"m":2,"r":${types[i]},"v":0}`);
                                this.rmCD();
                                break;
                            case 1:
                                this.rmBtns();
                                tz.ws.send(`{"m":2,"r":${types[i]},"v":${ab.data_[0]}}`);
                                this.rmCD();
                                break;
                            default: {
                                let view = this.selectionView_;
                                if (view) {
                                    view.dstry();
                                }
                                view = new SelectionView(this.width_, this.height_, types[i], ab.data_, (a)=>{
                                    if (a != undefined) {
                                        tz.ws.send(`{"m":2,"r":${types[i]},"v":${a}}`);
                                    }
                                    else {
                                        if (!selfDrawn) {
                                            tz.ws.send('{"m":2,"r":10,"v":0}');
                                        }
                                    }
                                    this.rmBtns();
                                    this.rmCD();
                                });
                                this.addChild(view);
                                this.selectionView_ = view;
                                break;
                            }
                            }
                        });
                        ab.data_ = val;
                        ++cnt;
                    }
                }

                if (this.isDiscarding_) {
                    // 轮到自己打牌时，隐藏“过”和“弃”
                    if (selfDrawn) {
                        this.actionBtns_[0].visible = false;
                        this.actionBtns_[1].visible = false;
                        cnt -= 2;
                    }
                    else if (!this.cfg_['s'] || ((this.turn_ + 1) & 3) == this.seat_) {
                        // 无战术鸣牌或者上家打牌后，隐藏“过”
                        this.actionBtns_[1].visible = false;
                        --cnt;
                    }
                }
                else {
                    // 补花时，隐藏“弃”
                    this.actionBtns_[0].visible = false;
                    --cnt;
                }

                if (!tz.mutecall && cnt > 0) {
                    play_snd('snd/08-inquire.wav');
                }
            }

            /**
             * 移除鸣牌按钮
             */
            rmBtns() {
                let v = this.selectionView_;
                if (v) {
                    v.dstry();
                    delete this.selectionView_;
                }

                for (let i = 0; i < 6; ++i) {
                    this.actionBtns_[i].visible = false;
                }
            }

            rightclick() {
                if (this.actionBtns_[0].visible) {
                    this.rmBtns();
                    tz.ws.send(this.rightWaive_ ? '{"m":2,"r":10,"v":0}' : '{"m":2,"r":9,"v":0}');
                    this.rmCD();
                }
            }

            /**
             * 抓牌效果
             * @param {number} n 玩家
             * @param {object} tw 牌墙上的牌
             * @param {number} idx 放入手牌的位置
             */
            _drawEffect(n, tw, idx) {
                play_snd('snd/05-draw.wav');

                tw.visible = false;
                let sp = (n % 2 == 0) ? create_w02() : create_w13();
                this.addChild(sp);
                sp.anchor.set(.5);
                sp.x = tw.x + tw.width * .5;
                sp.y = tw.y + tw.height * .5;
                let dst = this.standing_[n][idx];
                sp.zIndex = dst.zIndex;
                this.sortChildren();

                let x, y;
                switch (n) {
                case 0:
                    x = this.origin_[0][idx] + dst.width * .5;
                    y = dst.y - dst.height * .5;
                    (new TWEEN.Tween(sp.scale)).to({x:HAND_SCALE, y:HAND_SCALE}, DRAW_DT).start();
                    break;
                case 1:
                    x = dst.x;
                    y = this.openPos_[1] - idx * HEIGHT_13 + HEIGHT_13;
                    if (idx == 13) y -= GAP_W;
                    break;
                case 2:
                    x = this.openPos_[2] - idx * WIDTH_02 + WIDTH_02 * .5;
                    y = dst.y + dst.height * .5;
                    if (idx == 13) x -= GAP_W;
                    break;
                case 3:
                    x = dst.x + WIDTH_13 * .5;
                    y = this.openPos_[3] + idx * HEIGHT_13 + HEIGHT_13;
                    if (idx == 13) y += GAP_W;
                    break;
                }

                (new TWEEN.Tween(sp)).to({x:x,y:y}, DRAW_DT).delay(10).onComplete(()=>{
                    dst.visible = true;
                    this.remainText_.text = '牌墙剩余：' + this.remainCnt_;
                    sp.dstry();
                }).start();
            }

            /**
             * 出牌后整理手牌效果公共部分，插入手牌
             * @param {number} n 玩家
             * @param {number} o 出牌位置
             * @param {number} p 新抓到的牌要插入的位置
             */
            _insert(n, o, p) {
                let sta = this.standing_[n];
                if (o < p) {
                    let tmp = sta[o];
                    for (let i = o; i < p; ++i) {
                        sta[i] = sta[i + 1];
                    }
                    sta[p] = sta[13];
                    sta[13] = tmp;
                } else if (o > p) {
                    let tmp = sta[o];
                    for (let i = o; i > p; --i) {
                        sta[i] = sta[i - 1];
                    }
                    sta[p] = sta[13];
                    sta[13] = tmp;
                } else {
                    let tmp = sta[o];
                    sta[o] = sta[13];
                    sta[13] = tmp;
                }
            }

            /**
             * 上家出牌后整理手牌效果
             * @param {number} o 出牌位置
             * @param {number} p 新抓到的牌要插入的位置
             */
            _srt_ist3(o, p) {
                let sta = this.standing_[3];
                let op = this.openPos_[3];
                let zi = sta[0].zIndex;

                this._insert(3, o, p);

                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    sp.zIndex = zi + i;
                    let dp = op + i * HEIGHT_13;
                    if (i == 13) dp += GAP_T;
                    if (sp.y != dp) {
                        (new TWEEN.Tween(sp)).to({y:dp}, DISCARD_DT).start();
                    }
                }
                this.sortChildren();
            }

            /**
             * 对家出牌后整理手牌效果
             * @param {number} o 出牌位置
             * @param {number} p 新抓到的牌要插入的位置
             */
             _srt_ist2(o, p) {
                let sta = this.standing_[2];
                let op = this.openPos_[2];
                let zi = sta[0].zIndex;

                this._insert(2, o, p);

                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    sp.zIndex = zi + i;
                    let dp = op - i * WIDTH_02;
                    if (i == 13) dp -= GAP_T;
                    if (sp.x != dp) {
                        (new TWEEN.Tween(sp)).to({x:dp}, DISCARD_DT).start();
                    }
                }
                this.sortChildren();
            }

            /**
             * 下家出牌后整理手牌效果
             * @param {number} o 出牌位置
             * @param {number} p 新抓到的牌要插入的位置
             */
             _srt_ist1(o, p) {
                let sta = this.standing_[1];
                let op = this.openPos_[1];
                let zi = sta[0].zIndex;

                this._insert(1, o, p);

                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    sp.zIndex = zi - i;
                    let dp = op - i * HEIGHT_13;
                    if (i == 13) dp -= GAP_T;
                    if (sp.y != dp) {
                        (new TWEEN.Tween(sp)).to({y:dp}, DISCARD_DT).start();
                    }
                }
                this.sortChildren();
            }

            /**
             * 找玩家牌池的最后一张牌，当前要打的牌将要去向的目的地
             * @param {number} n 玩家
             * @returns {object} 牌
             */
            _findPoolDest(n) {
                for (let k = 0; k < 24; ++k) {
                    let sp = this.pools_[n][k];
                    if (!sp.v_) {
                        return sp;
                    }
                }
                return null;
            }

            /**
             * 随机玩家手牌的下标
             * @param {number} n 玩家
             * @returns {number}
             */
            _randomIdx(n) {
                let hd = this.packData_[n].length * 3;
                if (hd < 12) {
                    return Math.floor(Math.random() * (13 - hd)) + hd;
                }
                return 12;
            }

            /**
             * 寻找手中的指定牌（精准匹配）
             * @param {number} b 开始位置
             * @param {number} t 待搜索的牌
             * @returns {number} 下标或者-1
             */
            _findIdx(b, t) {
                let sta = this.standing_[0];
                for (let i = b, len = sta.length; i < len; ++i) {
                    let sp = sta[i];
                    if (sp.visible && sp.t_ == t) {
                        return i;
                    }
                }
                return -1;
            }

            /**
             * 寻找手中的指定牌（匹配牌面相等）
             * @param {number} b 开始位置
             * @param {number} t 待搜索的牌
             * @returns {number} 下标或者-1
             */
            _findIdxA(b, t) {
                let sta = this.standing_[0];
                for (let i = b, len = sta.length; i < len; ++i) {
                    let sp = sta[i];
                    if (sp.visible && (sp.t_ & 0xFC) == (t & 0xFC)) {
                        return i;
                    }
                }
                return -1;
            }

            /**
             * 寻找手中的指定牌（匹配牌面相等，但不精准匹配）
             * @param {number} b 开始位置
             * @param {number} t 待搜索的牌
             * @returns {number} 下标或者-1
             */
            _findIdxN(b, t) {
                let sta = this.standing_[0];
                for (let i = b, len = sta.length; i < len; ++i) {
                    let sp = sta[i];
                    if (sp.visible && (sp.t_ & 0xFC) == (t & 0xFC) && (sp.t_ != t)) {
                        return i;
                    }
                }
                return -1;
            }

            /**
             * 出牌
             * @param {number} n 玩家
             * @param {number} t 牌
             * @param {boolean} h 手切true，摸切false
             */
            discard(n, t, h) {
                play_snd('snd/06-discard.wav');
                this.rmCD();
                this.rmBtns();

                this.rmFly();

                let sta = this.standing_[n];
                if (!sta[13].visible) {
                    console.log('sta 13 is not visible', n);
                    sta[13].visible = true;
                }

                let dst = this._findPoolDest(n);
                if (dst == null) {
                    console.log('dst is null', n);
                    return;
                }

                let idx;
                if (n) {
                    idx = h ? this._randomIdx(n) : 13;
                }
                else {
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        if (sp.visible && sp.t_ == t) {
                            idx = i;
                            break;
                        }
                    }
                }
                let src = sta[idx];
                if (src == undefined) {
                    console.log('ui error');
                    reenter();
                    return;
                }
                src.visible = false;

                dst.update(t);
                dst.v_ = true;

                let sp = new (CTOR_PT[n])(t);
                sp.x = src.x;
                sp.y = src.y;
                if (n == 1) sp.x -= (WIDTH_13 - WIDTH_13S);
                else if (n == 0) sp.y -= src.height;
                this.flyTile_ = sp;
                this.addChild(sp);
                sp.zIndex = dst.zIndex;
                sp.dst_ = dst;
                (new TWEEN.Tween(sp)).to({x:(dst.x + DOX[n]),y:(dst.y + DOY[n])}, DISCARD_DT).onComplete(()=>{
                    sp.cplt_ = true;
                    if (!sp.visible) sp.dstry();
                }).start();
                if (n == 0) {
                    sp.scale.set(HAND_SCALE);
                    (new TWEEN.Tween(sp.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    this.stopFlower_ = false;
                }

                if (idx != 13) {
                    // 插入手牌的动画
                    setTimeout(()=>{
                        if (n) {
                            this['_srt_ist' + n].call(this, idx, 12);
                            sta[idx].visible = true;
                            sta[13].visible = false;
                        }
                        else {
                            let op = this.origin_[0][0];
                            let dx = WIDTH_02 * HAND_SCALE;

                            src.t_ = 0xFF;
                            src.visible = false;
                            sta.sort(function(a, b) { return a.t_ - b.t_; });

                            for (let i = 0; i < 14; ++i) {
                                let sp = sta[i];
                                sp.zIndex = 360 + i;
                                let dp = op + i * dx;
                                if (i == 13) dp += GAP_W;
                                if (sp.x != dp) {
                                    (new TWEEN.Tween(sp)).to({x:dp}, DISCARD_DT).start();
                                }
                            }
                        }
                    }, 400);
                }

                this.sortChildren();
            }

            /**
             * 自己出牌（点击牌张后）
             * @param {object} sp 牌张（精灵）
             */
            _discard(sp) {
                //this.discard(0, sp);
                let t = sp.t_;
                if (t != 0xFF && this.standing_[0][13].visible) {
                    tz.ws.send(`{"m":2,"r":2,"v":${t}}`);
                    this.rmCD();
                }
            }

            /**
             * 点击手牌
             * @param {object} sp 牌张（精灵）
             */
            _click(sp) {
                let sta = this.standing_[0];
                if (sp.isHighlight()) {
                    this._discard(sp);
                    sp.setHighlight(false);
                }
                else {
                    for (let i = 0; i < 14; ++i) {
                        let st = sta[i];
                        st.setHighlight(st == sp);
                    }
                }

                if (this.piano3_.visible) {
                    this.piano3_.refresh();
                }
                else if (this.piano2_.visible) {
                    this.piano2_.refresh();
                }
            }

            /**
             * 正向摸牌
             * @param {number} n 玩家
             */
            _draw_f(n) {
                let pier = this.frontPier_;
                let dir = pier['dir'];
                let off = pier['off'];

                let pierB = this.backPier_;
                if (!pier['down']) {
                    let wt = this.walls_[dir][off * 2];
                    if (n != undefined) {
                        this._drawEffect(n, wt, 13);
                    }
                    else {
                        wt.visible = false;
                    }

                    this.frontPier_['down'] = true;
                    if (pierB['dir'] == pier['dir'] && pierB['off'] == pier['off']) {
                        this.backPier_['down'] = true;
                    }
                }
                else {
                    let wt = this.walls_[dir][off * 2 + 1];
                    if (n != undefined) {
                        this._drawEffect(n, wt, 13);
                    }
                    else {
                        wt.visible = false;
                    }

                    ++off;
                    if (off >= 18) {
                        off -= 18;
                        dir = (dir + 3) & 3;
                    }
                    this.frontPier_ = {
                        'dir':dir,
                        'off':off,
                        'down':((pierB['dir'] != dir || pierB['off'] != off) ? false : pierB['down'])
                    };
                }
            }

            /**
             * 逆向摸牌
             * @param {number} n 玩家
             * @param {number} idx 摸上的牌将要到达的位置
             */
            _draw_b(n, idx) {
                let pier = this.backPier_;
                let dir = pier['dir'];
                let off = pier['off'];

                let pierF = this.frontPier_;
                if (!pier['down']) {
                    let wt = this.walls_[dir][off * 2];
                    if (n != undefined) {
                        this._drawEffect(n, wt, idx);
                    }
                    else {
                        wt.visible = false;
                    }

                    this.backPier_['down'] = true;
                    if (pierF['dir'] == pier['dir'] && pierF['off'] == pier['off']) {
                        this.frontPier_['down'] = true;
                    }
                }
                else {
                    let wt = this.walls_[dir][off * 2 + 1];
                    if (n != undefined) {
                        this._drawEffect(n, wt, idx);
                    }
                    else {
                        wt.visible = false;
                    }

                    if (off > 0) {
                        --off;
                    }
                    else {
                        off = 17;
                        dir = (dir + 1) & 3;
                    }
                    this.backPier_ = {
                        'dir':dir,
                        'off':off,
                        'down':((pierF['dir'] != dir || pierF['off'] != off) ? false : pierF['down'])
                    };
                }
            }

            /**
             * 摸牌
             * @param {number} n 玩家
             * @param {boolean} b 正向false，逆向true
             * @param {number} t 牌张（对于其他三家而言，该值无意义）
             * @param {number} rm 牌墙剩余
             */
            draw(n, b, t, rm) {
                this.rmBtns();

                this.setTurn((this.seat_ + n) & 3);
                this.remainCnt_ = rm;

                let sp = this.flyTile_;
                if (sp) {
                    let dst = sp.dst_;
                    if (dst) {
                        // 普通打牌
                        (new TWEEN.Tween(sp)).to({x:dst.x,y:dst.y}, DISCARD_DT).onComplete(()=>{
                            dst.visible = true;
                            this.flyTile_ = null;
                            if (sp.cplt_) sp.dstry();
                            else sp.visible = false;
                        }).start();
                    }
                    else {
                        // 加杠
                        (new TWEEN.Tween(sp)).to({x:sp.dstx_,y:sp.dsty_}, DISCARD_DT).onComplete(()=>{
                            this.flyTile_ = null;
                        }).start();
                    }
                }

                // 摸牌动画
                if (!this.standing_[n][13].visible) {
                    if (n == 0) {
                        this.standing_[n][13].update(t);
                    }
                    !b ? this._draw_f(n) : this._draw_b(n, 13);
                }
            }

            /**
             * 删除当前活动的牌
             */
            rmFly() {
                let sp = this.flyTile_;
                if (sp) {
                    console.log('active tile is not null');

                    this.flyTile_ = null;

                    let dst = sp.dst_;
                    if (dst) {
                        // 普通打牌
                        sp.x = dst.x;
                        sp.y = dst.y;
                        dst.visible = true;
                        if (sp.cplt_) sp.dstry();
                        else sp.visible = false;
                    }
                    else {
                        // 加杠
                        sp.x = sp.dstx_;
                        sp.y = sp.dsty_;
                    }
                }
            }

            /**
             * 显示鸣牌字样
             * @param {number} n 玩家
             * @param {string} s 文本
             */
            showCall(n, s) {
                let pos = this.callTextPos_[n];
                let text = new PIXI.extras.BitmapText(s, { font:'128px STXingkai' });
                text.anchor.x = pos['ax'];
                text.anchor.y = pos['ay'];
                text.x = pos['x'];
                text.y = pos['y'];
                this.addChild(text);
                text.zIndex = 500;

                text.scale.set(2);
                (new TWEEN.Tween(text)).to({alpha:1}, 100).start();
                (new TWEEN.Tween(text.scale)).to({x:1,y:1}, 100).onComplete(()=>{
                    (new TWEEN.Tween(text)).to({alpha:0}, 100).delay(1200).start();
                    (new TWEEN.Tween(text.scale)).to({x:2,y:2}, 100).delay(1200).onComplete(()=>{
                        text.dstry();
                    }).start();
                }).start();

                this.sortChildren();
            }

            /**
             * 下家、对家、上家补花
             * @param {number} n 玩家
             * @param {number} rm 牌墙剩余
             */
            flower123(n, rm) {
                this.showCall(n, '花');
                this.infoPanels_[n].setFlower(++this.flowers_[n]);
                this.remainCnt_ = rm;

                let sta = this.standing_[n];
                if (sta[13].visible) {
                    sta[13].visible = false;
                    this._draw_b(n, 13);
                }
                else {
                    let idx = this._randomIdx(n);
                    this._draw_b(n, idx);

                    let pos = this._randomIdx(n);
                    switch (n) {
                    case 1:
                        if (pos != idx) {
                            let y0 = this.openPos_[1];
                            for (let i = Math.min(idx, pos + 1), c = Math.max(pos, idx); i < c; ++i) {
                                let y1 = y0 - (i + 1) * HEIGHT_13;
                                sta[i].y = y1;
                                (new TWEEN.Tween(sta[i])).to({y:(y1 + HEIGHT_13)}, DISCARD_DT).delay(DISCARD_DT).start();
                            }
                        }
                        break;
                    case 2:
                        if (pos != idx) {
                            let x0 = this.openPos_[2];
                            for (let i = Math.min(idx, pos + 1), c = Math.max(pos, idx); i < c; ++i) {
                                let x1 = x0 - (i + 1) * WIDTH_02;
                                sta[i].x = x1;
                                (new TWEEN.Tween(sta[i])).to({x:(x1 + WIDTH_02)}, DISCARD_DT).delay(DISCARD_DT).start();
                            }
                        }
                        break;
                    case 3:
                        if (pos != idx) {
                            let y0 = this.openPos_[3];
                            for (let i = Math.min(idx, pos + 1), c = Math.max(pos, idx); i < c; ++i) {
                                let y1 = y0 + (i + 1) * HEIGHT_13;
                                sta[i].y = y1;
                                (new TWEEN.Tween(sta[i])).to({y:(y1 - HEIGHT_13)}, DISCARD_DT).delay(DISCARD_DT).start();
                            }
                        }
                        break;
                    }

                    sta[idx].visible = false;
                }
            }

            /**
             * 自己补花
             * @param {number} ot 使用的花牌
             * @param {number} nt 抓回来的新牌
             * @param {number} rm 牌墙剩余
             */
            flower0(ot, nt, rm) {
                this.showCall(0, '花');
                this.infoPanels_[0].setFlower(++this.flowers_[0]);
                this.remainCnt_ = rm;

                let idx = this._findIdx(0, ot);
                if (idx == -1) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[0];

                let src = sta[idx];
                src.t_ = 0xFF;
                src.visible = false;

                this.stopFlower_ = false;

                if (idx == 13) {
                    this._draw_b(0, 13);
                    sta[13].update(nt);
                }
                else if (sta[13].visible) {
                    sta[idx].t_ = 0xFF;
                    sta.sort(function(a, b) { return a.t_ - b.t_; });

                    let ori = this.origin_[0];
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 360 + i;
                        let dp = ori[i];
                        if (sp.x != dp) {
                            (new TWEEN.Tween(sp)).to({x:dp}, DISCARD_DT).start();
                        }
                    }

                    this._draw_b(0, 13);
                    sta[13].update(nt);
                }
                else {
                    sta[13].t_ = 0xFF;

                    this._draw_b(0, idx);
                    sta[idx].update(nt);
                    sta.sort(function(a, b) { return a.t_ - b.t_; });

                    let ori = this.origin_[0];
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 360 + i;
                        let dp = ori[i];
                        if (sp.x != dp) {
                            (new TWEEN.Tween(sp)).to({x:dp}, DISCARD_DT).start();
                        }
                    }
                }

                this.sortChildren();
            }

            /**
             * 缩减手牌
             * @param {number} n 玩家
             * @param {array} indices 缩减的下标
             */
            _shrink(n, indices) {
                let sta = this.standing_[n];
                for (let i = 0; i < 3; ++i) {
                    let tmp = sta[indices[i]];
                    for (let k = indices[i]; k > 0; --k) {
                        sta[k] = sta[k - 1];
                    }
                    sta[0] = tmp;
                    tmp.t_ = -1;
                }

                if (indices.length == 4) {
                    let tmp = sta[indices[3]];
                    for (let k = indices[3]; k < 13; ++k) {
                        sta[k] = sta[k + 1];
                    }
                    sta[13] = tmp;
                    tmp.t_ = -1;
                }
            }

            /**
             * 自己缩减手牌后整理手牌效果
             */
            _srt_shrk0() {
                let sta = this.standing_[0];
                let hdn = this.packData_[0].length * 3;
                let zi = sta[0].zIndex;
                let dp = this.origin_[0];
                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    sp.zIndex = zi + i;
                    if (i < hdn) {
                        sp.visible = false;
                        sp.x = dp[i];
                    }
                    else {
                        sp.visible = true;
                        if (sp.x != dp[i]) {
                            (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                        }
                    }
                }
            }

            /**
             * 下家缩减手牌后整理手牌效果
             */
            _srt_shrk1() {
                let sta = this.standing_[1];
                let hdn = this.packData_[1].length * 3;
                let zi = sta[0].zIndex;
                let dp0 = this.openPos_[1];
                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    sp.zIndex = zi - i;
                    let dp1 = dp0 - HEIGHT_13 * i;
                    if (i == 13) dp1 -= GAP_W;
                    if (i < hdn) {
                        sp.visible = false;
                        sp.y = dp1;
                    }
                    else {
                        sp.visible = true;
                        if (sp.y != dp1) {
                            (new TWEEN.Tween(sp)).to({y:dp1}, DISCARD_DT).start();
                        }
                    }
                }
            }

            /**
             * 对家缩减手牌后整理手牌效果
             */
            _srt_shrk2() {
                let sta = this.standing_[2];
                let hdn = this.packData_[2].length * 3;
                let zi = sta[0].zIndex;
                let dp0 = this.openPos_[2];
                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    sp.zIndex = zi + i;
                    let dp1 = dp0 - WIDTH_02 * i;
                    if (i == 13) dp1 -= GAP_W;
                    if (i < hdn) {
                        sp.visible = false;
                        sp.x = dp1;
                    }
                    else {
                        sp.visible = true;
                        if (sp.x != dp1) {
                            (new TWEEN.Tween(sp)).to({x:dp1}, DISCARD_DT).start();
                        }
                    }
                }
            }

            /**
             * 上家缩减手牌后整理手牌效果
             */
            _srt_shrk3() {
                let sta = this.standing_[3];
                let hdn = this.packData_[3].length * 3;
                let zi = sta[0].zIndex;
                let dp0 = this.openPos_[3];
                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    sp.zIndex = zi + i;
                    let dp1 = dp0 + HEIGHT_13 * i;
                    if (i == 13) dp1 += GAP_W;
                    if (i < hdn) {
                        sp.visible = false;
                        sp.y = dp1;
                    }
                    else {
                        sp.visible = true;
                        if (sp.y != dp1) {
                            (new TWEEN.Tween(sp)).to({y:dp1}, DISCARD_DT).start();
                        }
                    }
                }
            }

            /**
             * 上家吃/碰/大明杠
             * @param {number} pack 副露
             */
            cpk3(pack) {
                let type = pack_type(pack);
                let tile = pack_tile(pack);

                this.rmBtns();
                this.rmCD();

                let pplen = this.packData_[3].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[3];
                let ext = (type != 2) ? EXT_CP_13 : EXT_DK_13;

                // 立牌往下，已有的副露往上
                this.openPos_[3] += ext;
                let prev = this.packs_[3];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y - ext)}, DISCARD_DT).start();
                }

                let idx1 = this._randomIdx(3);
                let idx2, idx3;
                do { idx2 = this._randomIdx(3); } while (idx1 == idx2);

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0:
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default: t0 = new PoolTile0(tile - 4); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile + 4); break;
                    case 2: t0 = new PoolTile0(tile); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile + 4); break;
                    case 3: t0 = new PoolTile0(tile + 4); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile); break;
                    }
                    break;
                case 1:
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t2.pr_ = true; break;
                    }
                    break;
                case 2:
                    do { idx3 = this._randomIdx(1); } while (idx1 == idx3 || idx2 == idx3);
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                    case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                    case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile2(tile); break;
                    }
                    break;
                }

                this.addChild(t0); this.packs_[3].push(t0); t0.zIndex = 240 + pplen * 4;
                this.addChild(t1); this.packs_[3].push(t1); t1.zIndex = 241 + pplen * 4;
                this.addChild(t2); this.packs_[3].push(t2); t2.zIndex = 242 + pplen * 4;
                if (type == 2) { this.addChild(t3); this.packs_[3].push(t3); t3.zIndex = 243 + pplen * 4; }

                // 动画
                let yy = sta[hdn + 3].y + ext - GAP_T;

                // 来源牌
                let req = this.flyTile_;
                this.flyTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.y = sta[idx1].y;
                    t2.y = sta[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 2 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    else {
                        t3.y = sta[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 3 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 * 3)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.y = sta[idx1].y;
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.y = sta[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 2 - HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    else {
                        t3.y = sta[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_13 * 3 - HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_13 * 2 - HEIGHT_02),x:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy - HEIGHT_13)}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.y = sta[idx1].y;
                    t1.y = sta[idx2].y;
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_02 - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_02 - HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_02),x:0}, DISCARD_DT).start();
                    }
                    else {
                        t2.y = sta[idx3].y;
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy - HEIGHT_02 - HEIGHT_13 * 3)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy - HEIGHT_02 - HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy - HEIGHT_02 - HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy - HEIGHT_02),x:0}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.dst_.v_ = false;
                    if (req.cplt_) req.dstry();
                    else req.visible = false;
                }

                this.packData_[3].push(pack);
                this._shrink(3, [idx1, idx2, idx3]);
                this._srt_shrk3();
                if (type == 2) sta[13].visible = false;
                else this.setTurn((this.seat_ + 3) & 3);

                setTimeout(()=>{ this.sortChildren(); }, DISCARD_DT);
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 上家暗杠
             * @param {number} h 手牌四张true，抓来暗杠false
             */
            ck3(h) {
                let pplen = this.packData_[3].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[3];
                let ext = EXT_CK_13;

                // 立牌往下，已有的副露往上
                this.openPos_[3] += ext;
                let prev = this.packs_[3];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y - ext)}, DISCARD_DT).start();
                }

                let idx = [this._randomIdx(3), 0, 0, 13];
                do { idx[1] = this._randomIdx(3); } while (idx[1] == idx[0]);
                do { idx[2] = this._randomIdx(3); } while (idx[2] == idx[0] || idx[2] == idx[1]);
                if (h) do { idx[3] = this._randomIdx(3); } while (idx[3] == idx[0] || idx[3] == idx[1] || idx[3] == idx[2]);

                // 生成一组副露
                let yy = sta[hdn + 3].y + ext - GAP_T;

                for (let i = 0; i < 4; ++i) {
                    let t = create_w13();
                    if (i == 1 || i == 2) t.ck_ = true;
                    this.addChild(t);
                    t.zIndex = 240 + pplen * 4 + i;
                    this.packs_[3].push(t);

                    t.y = sta[idx[i]].y;
                    (new TWEEN.Tween(t)).to({y:yy - HEIGHT_13 * (4 - i)}, DISCARD_DT).start();
                }

                this.packData_[3].push(0x300);
                this._shrink(3, idx);
                this._srt_shrk3();
                sta[13].visible = false;

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 上家加杠
             * @param {number} pack 副露
             * @param {number} h 手牌true，抓来false
             */
            pk3(pack, h) {
                let tile = pack_tile(pack);

                let prev = this.packs_[3];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = h ? this._randomIdx(3) : 13;
                let src = this.standing_[3][idx];

                let sp = (pr instanceof PoolTile0) ? new PoolTile0(tile) : new PoolTile2(tile);
                this.addChild(sp);
                sp.zIndex = pr.zIndex;
                this.packs_[3].push(sp);

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y;
                (new TWEEN.Tween(sp)).to({x:(pr.x + WIDTH_02 + 10),y:(pr.y)}, DISCARD_DT).start();
                sp.dstx_ = pr.x + WIDTH_02;
                sp.dsty_ = pr.y;
                this.flyTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    setTimeout(()=>{
                        this._discardEffect(3, idx, 12);
                        this.standing_[3][13].visible = false;
                    }, DISCARD_DT);
                }

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 对家吃/碰/大明杠
             * @param {number} pack 副露
             */
            cpk2(pack) {
                let type = pack_type(pack);
                let tile = pack_tile(pack);

                this.rmBtns();
                this.rmCD();

                let pplen = this.packData_[2].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[2];
                let ext = (type != 2) ? EXT_CP_02 : EXT_DK_02;

                // 立牌往左，已有的副露往右
                this.openPos_[2] -= ext;
                let prev = this.packs_[2];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({x:(sp.x + ext)}, DISCARD_DT).start();
                }

                let idx1 = this._randomIdx(2);
                let idx2, idx3;
                do { idx2 = this._randomIdx(2); } while (idx1 == idx2);

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0:
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default: t0 = new PoolTile3(tile - 4); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile + 4); break;
                    case 2: t0 = new PoolTile3(tile); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile + 4); break;
                    case 3: t0 = new PoolTile3(tile + 4); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile); break;
                    }
                    break;
                case 1:
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t2.pr_ = true; break;
                    }
                    break;
                case 2:
                    do { idx3 = this._randomIdx(1); } while (idx1 == idx3 || idx2 == idx3);
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                    case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                    case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile1(tile); break;
                    }
                    break;
                }

                this.addChild(t0); this.packs_[2].push(t0); t0.zIndex = 170 + pplen * 4;
                this.addChild(t1); this.packs_[2].push(t1); t1.zIndex = 171 + pplen * 4;
                this.addChild(t2); this.packs_[2].push(t2); t2.zIndex = 172 + pplen * 4;
                if (type == 2) { this.addChild(t3); this.packs_[2].push(t3); t3.zIndex = 173 + pplen * 4; }

                // 动画
                let xx = sta[hdn + 3].x - ext + GAP_T + WIDTH_02;

                // 来源牌
                let req = this.flyTile_;
                this.flyTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.x = sta[idx1].x;
                    t2.x = sta[idx2].x;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 * 2),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = sta[idx3].x;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 * 3),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.x = sta[idx1].x;
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.x = sta[idx2].x;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = sta[idx3].x;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_02 * 2 + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02 * 2),y:0}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx)}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.x = sta[idx1].x;
                    t1.x = sta[idx2].x;
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_13 + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx),y:0}, DISCARD_DT).start();
                    }
                    else {
                        t2.x = sta[idx3].x;
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx + WIDTH_13 + WIDTH_02 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13 + WIDTH_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx),y:0}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.dst_.v_ = false;
                    if (req.cplt_) req.dstry();
                    else req.visible = false;
                }

                this.packData_[2].push(pack);
                this._shrink(2, [idx1, idx2, idx3]);
                this._srt_shrk2();
                if (type == 2) sta[13].visible = false;
                else this.setTurn((this.seat_ + 2) & 3);

                setTimeout(()=>{ this.sortChildren(); }, DISCARD_DT);
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 对家暗杠
             * @param {number} h 手牌四张true，抓来暗杠false
             */
            ck2(h) {
                let pplen = this.packData_[2].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[2];
                let ext = EXT_CK_02;

                // 立牌往左，已有的副露往右
                this.openPos_[2] -= ext;
                let prev = this.packs_[2];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({x:(sp.x + ext)}, DISCARD_DT).start();
                }

                let idx = [this._randomIdx(2), 0, 0, 13];
                do { idx[1] = this._randomIdx(2); } while (idx[1] == idx[0]);
                do { idx[2] = this._randomIdx(2); } while (idx[2] == idx[0] || idx[2] == idx[1]);
                if (h) do { idx[3] = this._randomIdx(2); } while (idx[3] == idx[0] || idx[3] == idx[1] || idx[3] == idx[2]);

                // 生成一组副露
                let xx = sta[hdn + 3].x - ext + GAP_T + WIDTH_02;

                for (let i = 0; i < 4; ++i) {
                    let t = create_w02();
                    if (i == 1 || i == 2) t.ck_ = true;
                    this.addChild(t);
                    t.zIndex = 170 + pplen * 4 + i;
                    this.packs_[2].push(t);

                    t.x = sta[idx[i]].x;
                    (new TWEEN.Tween(t)).to({x:(xx + WIDTH_02 * i)}, DISCARD_DT).start();
                }

                this.packData_[2].push(0x300);
                this._shrink(2, idx);
                this._srt_shrk2();
                sta[13].visible = false;

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 对家加杠
             * @param {number} pack 副露
             * @param {number} h 手牌true，抓来false
             */
            pk2(pack, h) {
                let tile = pack_tile(pack);

                let prev = this.packs_[2];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = h ? this._randomIdx(2) : 13;
                let src = this.standing_[2][idx];

                let sp = (pr instanceof PoolTile3) ? new PoolTile3(tile) : new PoolTile1(tile);
                this.addChild(sp);
                sp.zIndex = pr.zIndex;
                this.packs_[2].push(sp);

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y;
                (new TWEEN.Tween(sp)).to({x:pr.x,y:(pr.y + HEIGHT_13 + 10)}, DISCARD_DT).start();
                sp.dstx_ = pr.x;
                sp.dsty_ = pr.y + HEIGHT_13;
                this.flyTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    setTimeout(()=>{
                        this._discardEffect(2, idx, 12);
                        this.standing_[2][13].visible = false;
                    }, DISCARD_DT);
                }

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 下家吃/碰/大明杠
             * @param {number} pack 副露
             */
            cpk1(pack) {
                let type = pack_type(pack);
                let tile = pack_tile(pack);

                this.rmBtns();
                this.rmCD();

                let pplen = this.packData_[1].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[1];
                let ext = (type != 2) ? EXT_CP_13 : EXT_DK_13;

                // 立牌往上，已有的副露往下
                this.openPos_[1] -= ext;
                let prev = this.packs_[1];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y + ext)}, DISCARD_DT).start();
                }

                let xx = sta[0].x;

                let idx1 = this._randomIdx(1);
                let idx2, idx3;
                do { idx2 = this._randomIdx(1); } while (idx1 == idx2);

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0:
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default: t0 = new PoolTile2(tile - 4); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile + 4); break;
                    case 2: t0 = new PoolTile2(tile); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile + 4); break;
                    case 3: t0 = new PoolTile2(tile + 4); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile); break;
                    }
                    break;
                case 1:
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t2.pr_ = true; break;
                    }
                    break;
                case 2:
                    do { idx3 = this._randomIdx(1); } while (idx1 == idx3 || idx2 == idx3);
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                    case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                    case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile0(tile); break;
                    }
                    break;
                }

                this.addChild(t0); this.packs_[1].push(t0); t0.zIndex = 169 - pplen * 4;
                this.addChild(t1); this.packs_[1].push(t1); t1.zIndex = 168 - pplen * 4;
                this.addChild(t2); this.packs_[1].push(t2); t2.zIndex = 167 - pplen * 4;
                if (type == 2) { this.addChild(t3); this.packs_[1].push(t3); t3.zIndex = 166 - pplen * 4; }

                // 动画
                let yy = sta[hdn + 3].y - ext + GAP_T + HEIGHT_13 * 2;

                // 来源牌
                let req = this.flyTile_;
                this.flyTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.x = xx - (WIDTH_13 - WIDTH_13S); t1.y = sta[idx1].y;
                    t2.x = t1.x; t2.y = sta[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 * 2),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = t1.x; t3.y = sta[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 * 3),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.x = xx - (WIDTH_13 - WIDTH_13S); t0.y = sta[idx1].y;
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.x = t0.x; t2.y = sta[idx2].y;
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = t0.x; t3.y = sta[idx3].y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_13 * 2 + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_13 * 2),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy)}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.x = xx - (WIDTH_13 - WIDTH_13S); t0.y = sta[idx1].y;
                    t1.x = t0.x; t1.y = sta[idx2].y;
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_02 + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                    }
                    else {
                        t2.x = t0.x; t2.y = sta[idx3].y;
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({y:(yy + HEIGHT_02 + HEIGHT_13 * 2)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({y:(yy + HEIGHT_02 + HEIGHT_13)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({y:(yy + HEIGHT_02)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({y:(yy),x:(xx - (WIDTH_02 - WIDTH_13S))}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.dst_.v_ = false;
                    if (req.cplt_) req.dstry();
                    else req.visible = false;
                }

                this.packData_[1].push(pack);
                this._shrink(1, [idx1, idx2, idx3]);
                this._srt_shrk1();
                if (type == 2) sta[13].visible = false;
                else this.setTurn((this.seat_ + 1) & 3);

                setTimeout(()=>{ this.sortChildren(); }, DISCARD_DT);
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 下家暗杠
             * @param {number} h 手牌四张true，抓来暗杠false
             */
            ck1(h) {
                let pplen = this.packData_[1].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[1];
                let ext = EXT_CK_13;

                // 立牌往上，已有的副露往下
                this.openPos_[1] -= ext;
                let prev = this.packs_[1];
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    (new TWEEN.Tween(sp)).to({y:(sp.y + ext)}, DISCARD_DT).start();
                }

                let xx = sta[0].x;

                let idx = [this._randomIdx(1), 0, 0, 13];
                do { idx[1] = this._randomIdx(1); } while (idx[1] == idx[0]);
                do { idx[2] = this._randomIdx(1); } while (idx[2] == idx[0] || idx[2] == idx[1]);
                if (h) do { idx[3] = this._randomIdx(1); } while (idx[3] == idx[0] || idx[3] == idx[1] || idx[3] == idx[2]);

                // 生成一组副露
                let yy = sta[hdn + 3].y - ext + GAP_T;

                for (let i = 0; i < 4; ++i) {
                    let t = create_w13();
                    if (i == 1 || i == 2) t.ck_ = true;
                    this.addChild(t);
                    t.zIndex = 169 - pplen * 4 - i;
                    this.packs_[1].push(t);

                    t.x = xx - (WIDTH_13 - WIDTH_13S); t.y = sta[idx[i]].y;
                    (new TWEEN.Tween(t)).to({y:(yy + HEIGHT_13 * (5 - i))}, DISCARD_DT).start();
                }

                this.packData_[1].push(0x300);
                this._shrink(1, idx);
                this._srt_shrk1();
                sta[13].visible = false;

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 下家加杠
             * @param {number} pack 副露
             * @param {number} h 手牌true，抓来false
             */
            pk1(pack, h) {
                let tile = pack_tile(pack);

                let prev = this.packs_[1];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = h ? this._randomIdx(1) : 13;
                let src = this.standing_[1][idx];

                let sp = (pr instanceof PoolTile2) ? new PoolTile2(tile) : new PoolTile0(tile);
                this.addChild(sp);
                sp.zIndex = pr.zIndex;
                this.packs_[1].push(sp);

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y;
                (new TWEEN.Tween(sp)).to({x:(pr.x - WIDTH_02 - 10),y:pr.y}, DISCARD_DT).start();
                sp.dstx_ = pr.x - WIDTH_02;
                sp.dsty_ = pr.y;
                this.flyTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    setTimeout(()=>{
                        this._discardEffect(1, idx, 12);
                        this.standing_[1][13].visible = false;
                    }, DISCARD_DT);
                }

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 自己吃/碰/大明杠
             * @param {number} pack 副露
             */
            cpk0(pack) {
                let type = pack_type(pack);
                let tile = pack_tile(pack);

                this.rmCD();

                let pplen = this.packData_[0].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[0];
                let idx1, idx2, idx3;

                // 生成一组副露
                let t0, t1, t2, t3;
                let hz = 0;
                switch (type) {
                case 0: {
                    let tt0 = tile - 4 + ((pack >> 10) & 3);
                    let tt1 = tile + ((pack >> 12) & 3);
                    let tt2 = tile + 4 + ((pack >> 14) & 3);
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default:
                        idx1 = this._findIdx(0, tt1); idx2 = this._findIdx(0, tt2);
                        t0 = new PoolTile1(tt0); t1 = new PoolTile0(tt1); t2 = new PoolTile0(tt2);
                        break;
                    case 2:
                        idx1 = this._findIdx(0, tt0); idx2 = this._findIdx(0, tt2);
                        t0 = new PoolTile1(tt1); t1 = new PoolTile0(tt0); t2 = new PoolTile0(tt2);
                        break;
                    case 3:
                        idx1 = this._findIdx(0, tt0); idx2 = this._findIdx(0, tt1);
                        t0 = new PoolTile1(tt2); t1 = new PoolTile0(tt0); t2 = new PoolTile0(tt1);
                        break;
                    }
                    break;
                }
                case 1: {
                    let tm = tile + ((pack >> 10) & 3);
                    idx1 = this._findIdxN(0, tm);
                    idx2 = this._findIdxN(idx1 + 1, tm);
                    idx3 = 13;
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t0.pr_ = true; break;
                    case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t1.pr_ = true; break;
                    case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t2.pr_ = true; break;
                    }
                    break;
                }
                case 2:
                    this.stopFlower_ = true;
                    idx1 = this._findIdxA(0, tile);
                    idx2 = this._findIdxA(idx1 + 1, tile);
                    idx3 = this._findIdxA(idx2 + 1, tile);
                    switch (pack_offer(pack)) {
                    default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                    case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                    case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile3(tile); break;
                    }
                    break;
                }

                this.addChild(t0); this.packs_[0].push(t0); t0.zIndex = 340 + pplen * 4;
                this.addChild(t1); this.packs_[0].push(t1); t1.zIndex = 341 + pplen * 4;
                this.addChild(t2); this.packs_[0].push(t2); t2.zIndex = 342 + pplen * 4;
                if (type == 2) { this.addChild(t3); this.packs_[0].push(t3); t3.zIndex = 343 + pplen * 4; }

                // 动画
                let xx = this.openPos_[0];
                let yy = sta[0].y;

                // 来源牌
                let req = this.flyTile_;
                this.flyTile_ = null;

                switch (hz) {
                case 0:
                    if (req) t0.x = req.x, t0.y = req.y;
                    t1.x = sta[idx1].x; t1.y = yy - HEIGHT_02F * HAND_SCALE; t1.scale.set(HAND_SCALE);
                    t2.x = sta[idx2].x; t2.y = yy - HEIGHT_02F * HAND_SCALE; t2.scale.set(HAND_SCALE);
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_13 + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = sta[idx3].x; t3.y = yy - HEIGHT_02F * HAND_SCALE; t3.scale.set(HAND_SCALE);
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_13 + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx + WIDTH_13 + WIDTH_02 * 2),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    break;
                case 1:
                    t0.x = sta[idx1].x; t0.y = yy - HEIGHT_02F * HAND_SCALE; t0.scale.set(HAND_SCALE);
                    if (req) t1.x = req.x, t1.y = req.y;
                    t2.x = sta[idx2].x; t2.y = yy - HEIGHT_02F * HAND_SCALE; t2.scale.set(HAND_SCALE);
                    if (type != 2) {
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    else {
                        t3.x = sta[idx3].x; t3.y = yy - HEIGHT_02F * HAND_SCALE; t3.scale.set(HAND_SCALE);
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx + WIDTH_02 * 2 + WIDTH_13),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    break;
                case 2:
                    t0.x = sta[idx1].x; t0.y = yy - HEIGHT_02F * HAND_SCALE; t0.scale.set(HAND_SCALE);
                    t1.x = sta[idx2].x; t1.y = yy - HEIGHT_02F * HAND_SCALE; t1.scale.set(HAND_SCALE);
                    if (type != 2) {
                        if (req) t2.x = req.x, t2.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 * 2),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    else {
                        t2.x = sta[idx3].x; t2.y = yy - HEIGHT_02F * HAND_SCALE; t2.scale.set(HAND_SCALE);
                        if (req) t3.x = req.x, t3.y = req.y;
                        (new TWEEN.Tween(t0)).to({x:(xx),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1)).to({x:(xx + WIDTH_02),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2)).to({x:(xx + WIDTH_02 * 2),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                        (new TWEEN.Tween(t3)).to({x:(xx + WIDTH_02 * 3),y:(yy - HEIGHT_13F)}, DISCARD_DT).start();

                        (new TWEEN.Tween(t0.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t1.scale)).to({x:1,y:1}, DISCARD_DT).start();
                        (new TWEEN.Tween(t2.scale)).to({x:1,y:1}, DISCARD_DT).start();
                    }
                    break;
                }
                if (req) {
                    req.dst_.v_ = false;
                    if (req.cplt_) req.dstry();
                    else req.visible = false;
                }

                this.packData_[0].push(pack);
                this._shrink(0, [idx1, idx2, idx3]);
                this._srt_shrk0();
                if (type != 2) {
                    this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * 2 + GAP_T;
                    this.setTurn(this.seat_);
                    this.addCD(this.cfg_['r30']);
                }
                else {
                    this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * 3 + GAP_T;
                    sta[13].visible = false;
                }

                setTimeout(()=>{ this.sortChildren(); }, DISCARD_DT);
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 自己暗杠
             * @param {number} pack 副露
             */
            ck0(pack) {
                let pplen = this.packData_[0].length;
                let hdn = pplen * 3;
                if (hdn >= 12) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                let sta = this.standing_[0];
                let tile = pack_tile(pack);

                let idx = [0, 0, 0, 0];
                idx[0] = this._findIdxA(0, tile);
                idx[1] = this._findIdxA(idx[0] + 1, tile);
                idx[2] = this._findIdxA(idx[1] + 1, tile);
                idx[3] = this._findIdxA(idx[2] + 1, tile);

                // 生成一组副露
                let xx = this.openPos_[0];
                let yy = sta[0].y;

                for (let i = 0; i < 4; ++i) {
                    let t = (i == 0 || i == 3) ? create_w02() : new PoolTile0(tile);
                    this.addChild(t);
                    t.zIndex = 340 + pplen * 4 + i;
                    this.packs_[0].push(t);

                    t.x = sta[idx[3 - i]].x;
                    t.y = yy - HEIGHT_02F * HAND_SCALE;
                    t.scale.set(HAND_SCALE);
                    (new TWEEN.Tween(t)).to({x:(xx + WIDTH_02 * i),y:(yy - HEIGHT_02F)}, DISCARD_DT).start();
                    (new TWEEN.Tween(t.scale)).to({x:1,y:1}, DISCARD_DT).start();
                }
                this.openPos_[0] = xx + WIDTH_02 * 4 + GAP_T;

                this.stopFlower_ = true;

                this.packData_[0].push(pack);

                // 插入手牌动画
                if (idx[3] == 13) {
                    this._shrink(0, idx);
                    this._srt_shrk0();
                }
                else {
                    let dp = new Array(14);
                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        dp[i] = sp.x;
                        if (i == idx[0] || i == idx[1] || i == idx[2]) {
                            sp.t_ = -1;
                        }
                        else if (i == idx[3]) {
                            sp.t_ = 0xFF;
                        }
                    }

                    sta.sort(function(a, b) { return a.t_ - b.t_; });

                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 360 + i;
                        if (i < hdn + 3) {
                            sp.visible = false;
                            sp.x = dp[i];
                        }
                        else {
                            sp.visible = true;
                            if (sp.x != dp[i]) {
                                (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                            }
                        }
                    }
                }
                sta[13].visible = false;

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 自己加杠
             * @param {number} pack 副露
             */
            pk0(pack) {
                let tile = pack_tile(pack);

                let prev = this.packs_[0];
                let pr = null;
                for (let i = 0, len = prev.length; i < len; ++i) {
                    let sp = prev[i];
                    if (sp.pr_ && sp.t_ == tile) {
                        pr = sp;
                        break;
                    }
                }

                if (pr == null) {
                    console.log('ui error');
                    reenter();
                    return;
                }

                delete pr.pr_;

                let idx = this._findIdxA(0, tile);
                let src = this.standing_[0][idx];

                let sp = (pr instanceof PoolTile3) ? new PoolTile3(tile) : new PoolTile1(tile);
                this.addChild(sp);
                this.packs_[0].push(sp);
                sp.zIndex = pr.zIndex - 1;

                src.visible = false;
                sp.x = src.x;
                sp.y = src.y - HEIGHT_13F * HAND_SCALE;
                sp.scale.set(HAND_SCALE);
                (new TWEEN.Tween(sp)).to({x:pr.x,y:(pr.y - HEIGHT_13 - 10)}, DISCARD_DT).start();
                (new TWEEN.Tween(sp.scale)).to({x:1,y:1}, DISCARD_DT).start();
                sp.dstx_ = pr.x;
                sp.dsty_ = pr.y - HEIGHT_13;
                this.flyTile_ = sp;

                // 插入手牌动画
                if (idx != 13) {
                    let sta = this.standing_[0];
                    let dp = new Array(14);
                    for (let i = 0; i < 14; ++i) {
                        dp[i] = sta[i].x;
                    }

                    src.t_ = 0xFF;
                    src.visible = false;
                    sta.sort(function(a, b) { return a.t_ - b.t_; });

                    for (let i = 0; i < 14; ++i) {
                        let sp = sta[i];
                        sp.zIndex = 360 + i;
                        if (sp.x != dp[i]) {
                            (new TWEEN.Tween(sp)).to({x:dp[i]}, DISCARD_DT).start();
                        }
                    }
                }

                this.stopFlower_ = true;

                this.sortChildren();
                play_snd('snd/09-cpk.wav');
            }

            /**
             * 显示结算界面
             * @param {object} hand 手牌
             * @param {number} tile 和牌张
             * @param {object} table 番表
             * @param {object} detail 详情
             */
            showSettleView(hand, tile, table, detail) {
                this.closeSettleView();

                let names = [
                    this.infoPanels_[(4 - this.seat_) & 3].getName(),
                    this.infoPanels_[(5 - this.seat_) & 3].getName(),
                    this.infoPanels_[(6 - this.seat_) & 3].getName(),
                    this.infoPanels_[(7 - this.seat_) & 3].getName(),
                ];

                let view = new SettleView(this.width_, this.height_, hand, tile, table, detail, names, this.seat_, this.cfg_['r30'],
                    ()=>{
                        if (!this.rp_) {
                            tz.ws.send('{"m":2,"r":8,"v":0}');
                        }
                        else {
                            this.showResult();
                        }
                        this.closeSettleView();
                    }
                );
                this.addChild(view);
                view.zIndex = 500;
                this.settleView_ = view;

                if (!this.rdfsh_) {
                    let rss = (detail['s'] || [0, 0, 0, 0]), rps = detail['n'];
                    for (let i = 0; i < 4; ++i) {
                        let pl = this.players_[i], rs = rss[i], rp = rps[i];
                        pl['rs'][this.rd_] = rs;
                        pl['rp'][this.rd_] = rp;
                        pl['s'] += (rs + rp);
                    }
                    this.rdfsh_ = true;
                }
            }

            /**
             * 关闭结算界面
             */
            closeSettleView() {
                if (this.settleView_) {
                    this.settleView_.dstry();
                    this.settleView_ = null;
                }
            }

            /**
             * 显示错和界面
             * @param {number} f 错和番数
             * @param {object} table 番表
             */
            showFalseWin(f, table) {
                let view = new FalseWinView(this.width_, this.height_, f, table);
                this.addChild(view);
                view.zIndex = 500;
                if (this.turn_ == this.seat_) {
                    setTimeout(()=>{
                        this.addCD(this.cfg_['r30']);
                    }, 4000);
                }
            }

            /**
             * 设置对局结果（在最后一盘结界界面关闭后再弹出结果界面）
             * @param {object} resp 服务器传回的json
             */
            setResult(resp) {
                if (this.cstr_) {
                    clearInterval(this.cstr_);
                    this.cstr_ = null;
                }
                this.rp_ = resp['p'];
                this.rpt_ = resp['t'];
            }

            /**
             * 显示鸣牌设置界面
             */
            showCallOpt() {
                let cs = this.callView_;
                this.removeChild(cs);
                this.addChild(cs);
                cs.show(this.callFlags_, this.ignoreSD_, this.rightWaive_);
             }

            /**
             * 显示计分表界面
             */
            showHistory() {
                let hv = this.historyView_;
                this.removeChild(hv);
                this.addChild(hv);
                let rd = this.rd_;
                let pl = this.players_;
                let idx = [seat_2_org[rd][0], seat_2_org[rd][1], seat_2_org[rd][2], seat_2_org[rd][3]];
                let ns = [pl[idx[0]]['n'], pl[idx[1]]['n'], pl[seat_2_org[rd][2]]['n'], pl[seat_2_org[rd][3]]['n']];
                let rss = [pl[idx[0]]['rs'], pl[idx[1]]['rs'], pl[idx[2]]['rs'], pl[idx[3]]['rs']];
                let rps = [pl[idx[0]]['rp'], pl[idx[1]]['rp'], pl[idx[2]]['rp'], pl[idx[3]]['rp']];
                hv.show(ns, rss, rps, rd + (this.rdfsh_ ? 1 : 0), this.cfg_['i'], -this.cfg_['b']);
            }

            /**
             * 显示追分策略界面
             */
            showChase() {
                // this.seat_ = 0;
                // this.players_[0]['n'] = '12';
                // this.rp_ = [{'n':'123','s':123},{'n':'12','s':12},{'n':'-12','s':-12},{'n':'-123','s':-123}];
                // this.rpt_ = 0;
                // this.showResult();
                // return;
                let cv = this.chaseView_;
                let fw = this.falseWin_;
                let penalties = [0, 0, 0, 0];
                for (let i = 0; i < 4; ++i) {
                    if (fw[i]) {
                        // 无论-30/+10或者-40/+0，分差都是40
                        penalties[(i + this.seat_) & 3] -= 40;
                    }
                }
                this.removeChild(cv);
                this.addChild(cv);
                cv.show(this.players_, penalties);
            }

            /**
             * 显示对局结果界面
             */
            showResult() {
                if (this.resultView_) {
                    this.resultView_.dstry();
                }

                let view = new ResultView(this.width_, this.height_, this.cfg_['t'], this.seat_, this.rp_, this.rpt_, ()=>{
                    if (this.resultView_) {
                        this.resultView_.dstry();
                        this.resultView_ = null;
                        this.clear();
                        delete this.rp_;
                        delete this.rpt_;
                        tz.ws.send('{"m":1,"r":2}');
                        tz.game.visible = false;
                        tz.lobby.visible = true;
                        delete tz.lobby.seat_;
                        delete tz.lobby.tableid_;
                        this.historyView_.visible = false;
                        this.chaseView_.visible = false;

                        this.roundText_.text = '';
                        this.remainText_.text = '';
                        let wt = this.windTexts_;
                        let ip = this.infoPanels_;
                        for (let i = 0; i < 4; ++i) {
                            wt[i].text = '';
                            ip[i].setName('');
                        }
                    }
                });
                this.addChild(view);
                view.zIndex = 500;
                this.resultView_ = view;
            }

            /**
             * 移除打开的手牌
             * @param {number} n 玩家
             * @param {number} cnt 牌张数
             */
            _rm_ot(n, cnt) {
                let sp;
                while (sp = this.openTiles_[n].pop()) {
                    sp.dstry();
                }

                let hdn = this.packData_[n].length * 3;
                let sta = this.standing_[n];
                for (let i = hdn; i < cnt; ++i) {
                    sta[i].visible = true;
                }

                let packs = this.packs_[n];
                for (let i = 0, len = packs.length; i < len; ++i) {
                    packs[i].visible = true;
                }
            }

            /**
             * 打开手牌
             * @param {array} tiles 四家的手牌
             * @param {boolean} succeed 和牌成功true，错和false
             * @param {number} wp 和牌者
             * @param {number} cp 放炮者
             * @param {number} wt 和牌张
             */
            op_ht(tiles, succeed, wp, cp, wt) {
                if (succeed) {
                    setTimeout(()=>{
                        let p = (this.seat_ + 1) & 3;
                        this._open1(tiles[p], wp == p ? wt : undefined);
                        p = (this.seat_ + 2) & 3;
                        this._open2(tiles[p], wp == p ? wt : undefined);
                        p = (this.seat_ + 3) & 3;
                        this._open3(tiles[p], wp == p ? wt : undefined);
                        this._open0(tiles[this.seat_], wp == this.seat_ ? wt : undefined);
                    }, DISCARD_DT * 2);

                    if (wp != undefined && cp != undefined && wp != cp) {
                        let n0 = (wp + 4 - this.seat_) & 3;
                        let n1 = (cp + 4 - this.seat_) & 3;
                        let src = this.flyTile_;
                        let dst = this.standing_[n0][13];
                        let xx, yy, sp;
                        if (!src) {
                            console.log('ui error');
                            reenter();
                            return;
                        }
                        switch (n0) {
                        case 0:
                            sp = new PoolTile0(wt);
                            sp.anchor.y = 1;
                            sp.layout();
                            sp.x = src.x;
                            sp.y = src.y - HEIGHT_02;
                            xx = dst.x;
                            yy = dst.y;
                            break;
                        case 1:
                            sp = new PoolTile1(wt);
                            sp.x = src.x;
                            sp.y = src.y;
                            xx = dst.x - (WIDTH_13 - WIDTH_13S);
                            yy = dst.y - HEIGHT_13SF + HEIGHT_13F * 2;
                            break;
                        case 2:
                            sp = new PoolTile2(wt);
                            sp.x = src.x;
                            sp.y = src.y;
                            xx = dst.x;
                            yy = dst.y;
                            break;
                        case 3:
                            sp = new PoolTile3(wt);
                            sp.x = src.x;
                            sp.y = src.y;
                            xx = dst.x;
                            yy = dst.y;
                            break;
                        }
                        this.addChild(sp);

                        let pkt = this.packs_[n1].pop();
                        if (pkt && !Object.is(src, pkt)) {
                            this.packs_[n1].push(pkt);
                        }

                        if (src.cplt_) src.dstry();
                        else src.visible = false;
                        this.flyTile_ = null;

                        (new TWEEN.Tween(sp)).to({x:xx,y:yy}, DISCARD_DT).onComplete(()=>{ sp.dstry(); }).start();

                        if (n0 == 0) {
                            (new TWEEN.Tween(sp.scale)).to({x:HAND_SCALE,y:HAND_SCALE}, DISCARD_DT).start();
                        }

                        let pos = this.callTextPos_[n1];
                        let text = new PIXI.extras.BitmapText('点炮', { font:'128px STXingkai' });
                        text.anchor.x = pos['ax'];
                        text.anchor.y = pos['ay'];
                        text.x = pos['x'];
                        text.y = pos['y'];
                        this.addChild(text);
                        text.zIndex = 500;
                        this.openTiles_[n1].push(text);
                    }

                    if (wp != undefined) {
                        let n0 = (wp + 4 - this.seat_) & 3;
                        let pos = this.callTextPos_[n0];
                        let text = new PIXI.extras.BitmapText('和', { font:'128px STXingkai' });
                        text.anchor.x = pos['ax'];
                        text.anchor.y = pos['ay'];
                        text.x = pos['x'];
                        text.y = pos['y'];
                        this.addChild(text);
                        text.zIndex = 500;
                        this.openTiles_[n0].push(text);
                    }

                    this.sortChildren();
                }
                else {
                    let n = (wp + 4 - this.seat_) & 3;
                    this.showCall(n, '错和');
                    switch (n) {
                    case 0: this._open0(tiles[this.seat_], wt); break;
                    case 1: this._open1(tiles[(this.seat_ + 1) & 3], wt); break;
                    case 2: this._open2(tiles[(this.seat_ + 2) & 3], wt); break;
                    case 3: this._open3(tiles[(this.seat_ + 3) & 3], wt); break;
                    }
                    setTimeout(()=>{
                        this._rm_ot(n, (this.turn_ != wp ? 13 : 14));
                    }, 5000);
                }
            }

            /**
             * 打开上家手牌
             * @param {array} ht 手牌
             * @param {number} wt 和牌张
             */
            _open3(ht, wt) {
                let ot = this.openTiles_[3];

                let sta = this.standing_[3];
                let yy = HEIGHT_13SF - HEIGHT_13F;

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                let pos = this.openPos_[3];
                for (let i = 0, len = st.length; i < len; ++i) {
                    let sp0 = sta[offset + i];
                    let sp1 = (st[i] != 255) ? new PoolTile3(st[i]) : create_w13();
                    sp1.x = sp0.x;
                    sp1.y = pos + (offset + i) * HEIGHT_13 + yy;
                    this.addChild(sp1);
                    sp1.zIndex = 260 + i;
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = sta[13];
                    let sp1 = new PoolTile3(wt);
                    sp1.x = sp0.x;
                    sp1.y = pos + 13 * HEIGHT_13 + GAP_T + yy;
                    this.addChild(sp1);
                    sp1.zIndex = 260 + 13;
                    sp0.visible = false;
                    ot.push(sp1);
                }

                let packs = this.packs_[3];
                for (let i = 0, len = ps.length; i < len; ++i) {
                    let p = ps[i];
                    if ((p & 0xFFC0) == 0x200) {
                        for (let k = 0, len2 = packs.length, cnt = 0; k < len2 && cnt < 2; ++k) {
                            let sp0 = packs[k];
                            if (sp0.visible && sp0.ck_) {
                                let sp1 = new PoolTile3(pack_tile(p));
                                sp1.x = sp0.x;
                                sp1.y = sp0.y;
                                this.addChild(sp1);
                                sp1.zIndex = sp0.zIndex;
                                sp0.visible = false;
                                ot.push(sp1);
                                ++cnt;
                            }
                        }
                    }
                }
                this.sortChildren();
            }

            /**
             * 打开对家手牌
             * @param {array} ht 手牌
             * @param {number} wt 和牌张
             */
            _open2(ht, wt) {
                let ot = this.openTiles_[2];

                let sta = this.standing_[2];

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                let pos = this.openPos_[2];
                for (let i = 0, len = st.length; i < len; ++i) {
                    let sp0 = sta[offset + i];
                    let sp1 = (st[i] != 255) ? new PoolTile2(st[i]) : create_w02();
                    sp1.x = pos - (offset + i) * WIDTH_02;
                    sp1.y = sp0.y;
                    this.addChild(sp1);
                    sp1.zIndex = 190 + i;
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = sta[13];
                    let sp1 = new PoolTile2(wt);
                    sp1.x = pos - 13 * WIDTH_02 - GAP_T;
                    sp1.y = sp0.y;
                    this.addChild(sp1);
                    sp1.zIndex = 190 + 13;
                    sp0.visible = false;
                    ot.push(sp1);
                }

                let packs = this.packs_[2];
                for (let i = 0, len = ps.length; i < len; ++i) {
                    let p = ps[i];
                    if ((p & 0xFFC0) == 0x200) {
                        for (let k = 0, len2 = packs.length, cnt = 0; k < len2 && cnt < 2; ++k) {
                            let sp0 = packs[k];
                            if (sp0.visible && sp0.ck_) {
                                let sp1 = new PoolTile2(pack_tile(p));
                                sp1.x = sp0.x;
                                sp1.y = sp0.y;
                                this.addChild(sp1);
                                sp1.zIndex = sp0.zIndex;
                                sp0.visible = false;
                                ot.push(sp1);
                                ++cnt;
                            }
                        }
                    }
                }
                this.sortChildren();
            }

            /**
             * 打开下家手牌
             * @param {array} ht 手牌
             * @param {number} wt 和牌张
             */
            _open1(ht, wt) {
                let ot = this.openTiles_[1];

                let sta = this.standing_[1];
                let xx = WIDTH_13 - WIDTH_13S;
                let yy = HEIGHT_13SF - HEIGHT_13F;

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                let pos = this.openPos_[1];
                for (let i = 0, len = st.length; i < len; ++i) {
                    let sp0 = sta[offset + i];
                    let sp1 = (st[i] != 255) ? new PoolTile1(st[i]) : create_w13();
                    sp1.x = sp0.x - xx;
                    sp1.y = pos - (offset + i - 1) * HEIGHT_13 - yy;
                    this.addChild(sp1);
                    sp1.zIndex = 130 + 13 - i;
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = sta[13];
                    let sp1 = new PoolTile1(wt);
                    sp1.x = sp0.x - xx;
                    sp1.y = pos - 12 * HEIGHT_13 - GAP_T - yy;
                    this.addChild(sp1);
                    sp1.zIndex = 130;
                    sp0.visible = false;
                    ot.push(sp1);
                }

                let packs = this.packs_[1];
                for (let i = 0, len = ps.length; i < len; ++i) {
                    let p = ps[i];
                    if ((p & 0xFFC0) == 0x200) {
                        for (let k = 0, len2 = packs.length, cnt = 0; k < len2 && cnt < 2; ++k) {
                            let sp0 = packs[k];
                            if (sp0.visible && sp0.ck_) {
                                let sp1 = new PoolTile1(pack_tile(p));
                                sp1.x = sp0.x;
                                sp1.y = sp0.y;
                                this.addChild(sp1);
                                sp1.zIndex = sp0.zIndex;
                                sp0.visible = false;
                                ot.push(sp1);
                                ++cnt;
                            }
                        }
                    }
                }
                this.sortChildren();
            }

            /**
             * 打开自己手牌
             * @param {array} ht 手牌
             * @param {number} wt 和牌张
             */
            _open0(ht, wt) {
                let ot = this.openTiles_[0];

                let sta = this.standing_[0];

                let ps = ht['p'] || [];
                let st = ht['s'];
                let offset = ps.length * 3;
                for (let i = 0, len = st.length; i < len; ++i) {
                    if (st[i] == 255) continue;
                    let sp0 = sta[offset + i];
                    let sp1 = new PoolTile0(st[i]);
                    sp1.x = sp0.x;
                    sp1.y = sp0.y;
                    sp1.anchor.y = 1;
                    sp1.layout();
                    sp1.scale.set(HAND_SCALE);
                    this.addChild(sp1);
                    sp1.zIndex = 360 + i;
                    sp0.visible = false;
                    ot.push(sp1);
                }

                if (wt != undefined) {
                    let sp0 = sta[13];
                    let sp1 = new PoolTile0(wt);
                    sp1.x = sp0.x;
                    sp1.y = sp0.y;
                    sp1.anchor.y = 1;
                    sp1.layout();
                    sp1.scale.set(HAND_SCALE);
                    this.addChild(sp1);
                    sp1.zIndex = 360 + 13;
                    sp0.visible = false;
                    ot.push(sp1);
                }
                this.sortChildren();
            }

            /**
             * 重联
             * @param {object} resp 服务器传回的json
             */
            reconnect(resp) {
                this.clear();
                this.option_.reset();

                // 基本信息
                let seat = this.seat_ = resp['v'];
                let users = this.players_ = resp['u'];
                for (let i = 0; i < 4; ++i) {
                    let user = users[i];
                    let k = (i + 4 - seat) & 3;
                    let ip = this.infoPanels_[k];
                    ip.setName(user['n']);
                    ip.setFlower(user['f']);
                    ip.setConnection(!user['o']);
                    ip.setFalseWin(this.falseWin_[k] = user['w']);

                    this.windTexts_[k].text = WIND[i] + ' ' + user['s'];
                }

                let dtl = resp['i'];
                if (dtl == undefined) {
                    return;
                }

                this.step_ = dtl['s'];
                this.setupPool(dtl['p']);

                let rd = this.rd_ = dtl['d'];
                this.roundText_.text = WIND[rd >> 2] + '风' + WIND[rd & 3];
                this.setTurn(dtl['t']);

                this.isDiscarding_ = dtl['e'];

                let at = dtl['at'];
                if (at != undefined) {
                    let n = (this.turn_ + 4 - seat) & 3;
                    let dst = this._findPoolDest(n);
                    if (dst != null) {
                        dst.update(at);
                        dst.v_ = true;

                        let sp = new (CTOR_PT[n])(at);
                        this.flyTile_ = sp;
                        this.addChild(sp);
                        sp.zIndex = dst.zIndex;
                        sp.dst_ = dst;
                        sp.x = dst.x + DOX[n];
                        sp.y = dst.y + DOY[n];
                    }
                }

                // 牌墙
                let w = dtl['w'];
                let dd = w['d'];
                let d = [ dd & 0xF, (dd >> 4) & 0xF, (dd >> 8) & 0xF, (dd >> 12) & 0xF];

                let dir = (d[0] + d[1] - 1 + 4 - seat) & 3;
                let off = d[0] + d[1] + d[2] + d[3];
                if (off >= 18) {
                    off -= 18;
                    dir = (dir + 3) & 3;
                }
                this.backPier_ = off > 0 ? {'dir':dir,'off':off - 1,'down':false} : {'dir':(dir+1)&3,'off':17,'down':false};
                this.openPier_ = {'dir':dir, 'off':off, 'down':false};
                this.frontPier_ = {'dir':dir,'off':off,'down':false};
                let f = w['f'];
                let b = w['b'];
                this.remainCnt_ = 144 - f - b;
                this.remainText_.text = '牌墙剩余：' + this.remainCnt_;
                for (; f > 0; --f) {
                    this._draw_f();
                }
                for (; b > 0; --b) {
                    this._draw_b();
                }

                // 自己手牌
                let h = dtl['h'][seat];
                let p = h['p'] || [];
                let s = h['s'];
                let o = p.length * 3;
                let sta = this.standing_[0];
                for (let i = 0; i < 13; ++i) {
                    let sp = sta[i];
                    if (i >= o) {
                        sp.visible = true;
                        sp.update(s[i - o]);
                    }
                    else {
                        sp.t_ = -1;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = sta[13];
                    sp.visible = true;
                    sp.update(s[13 - o]);
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_type(pack);
                    let tile = pack_tile(pack);
                    let pplen = this.packData_[0].length;
                    let ext = (3 * WIDTH_02 * HAND_SCALE) - (WIDTH_02 * 2 + WIDTH_13 + GAP_T);
                    if (type == 2) {
                        ext -= WIDTH_02;
                        if (pack_offer(pack) == 0) {
                            ext += (WIDTH_13 - WIDTH_02);
                        }
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_offer(pack)) {
                        default: t0 = new PoolTile1(tile - 4); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile + 4); break;
                        case 2: t0 = new PoolTile1(tile); t1 = new PoolTile0(tile - 4); t2 = new PoolTile0(tile + 4); break;
                        case 3: t0 = new PoolTile1(tile + 4); t1 = new PoolTile0(tile - 4); t2 = new PoolTile0(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile1(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        case 2: hz = 1; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        case 3: hz = 2; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile3(tile); break;
                        case 0: hz = 3; t0 = create_w02(); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = create_w02(); break;
                        }
                        break;
                    case 3:
                        switch (pack_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        case 2: hz = 5; t0 = new PoolTile0(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile0(tile); break;
                        case 3: hz = 6; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        }
                        break;
                    }

                    this.addChild(t0); this.packs_[0].push(t0); t0.zIndex = 340 + pplen * 4;
                    this.addChild(t1); this.packs_[0].push(t1); t1.zIndex = 341 + pplen * 4;
                    this.addChild(t2); this.packs_[0].push(t2); t2.zIndex = 342 + pplen * 4;
                    if (t3 != undefined) { this.addChildAt(t3); this.packs_[0].push(t3); t3.zIndex = 343 + pplen * 4; }

                    // 不是动画
                    let xx = this.openPos_[0];
                    let yy = sta[0].y;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.position.set(xx, yy - HEIGHT_13F);
                            t1.position.set(xx + WIDTH_13, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                        }
                        else {
                            t0.position.set(xx, yy - HEIGHT_13F);
                            t1.position.set(xx + WIDTH_13, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                            t3.position.set(xx + WIDTH_13 + WIDTH_02 * 2, yy - HEIGHT_02F);
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_13F);
                            t2.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                        }
                        else {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_13F);
                            t2.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_02F);
                            t3.position.set(xx + WIDTH_02 * 2 + WIDTH_13, yy - HEIGHT_02F);
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_02 * 2, yy - HEIGHT_13F);
                        }
                        else {
                            t0.position.set(xx, yy - HEIGHT_02F);
                            t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                            t2.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_02F);
                            t3.position.set(xx + WIDTH_02 * 2 + WIDTH_13, yy - HEIGHT_13F);
                        }
                        break;
                    case 3:
                        t0.position.set(xx, yy - HEIGHT_02F);
                        t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                        t2.position.set(xx + WIDTH_02 * 2, yy - HEIGHT_02F);
                        t3.position.set(xx + WIDTH_02 * 3, yy - HEIGHT_02F);
                        break;
                    case 4:
                        t0.position.set(xx, yy - HEIGHT_13F - HEIGHT_13);
                        t1.position.set(xx, yy - HEIGHT_13F);
                        t2.position.set(xx + WIDTH_13, yy - HEIGHT_02F);
                        t3.position.set(xx + WIDTH_13 + WIDTH_02, yy - HEIGHT_02F);
                        break;
                    case 5:
                        t0.position.set(xx, yy - HEIGHT_02F);
                        t1.position.set(xx + WIDTH_02, yy - HEIGHT_13F - HEIGHT_13);
                        t2.position.set(xx + WIDTH_02, yy - HEIGHT_13F);
                        t3.position.set(xx + WIDTH_02 + WIDTH_13, yy - HEIGHT_02F);
                        break;
                    case 6:
                        t0.position.set(xx, yy - HEIGHT_02F);
                        t1.position.set(xx + WIDTH_02, yy - HEIGHT_02F);
                        t2.position.set(xx + WIDTH_02 * 2, yy - HEIGHT_13F - HEIGHT_13);
                        t3.position.set(xx + WIDTH_02 * 2, yy - HEIGHT_13F);
                        break;
                    }

                    this.packData_[0].push(pack);

                    if (hz < 3) {
                        this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * (t3 == undefined ? 2 : 3) + GAP_T;
                    }
                    else if (hz == 3) {
                        this.openPos_[0] = xx + WIDTH_02 * 4 + GAP_T;
                    }
                    else {
                        this.openPos_[0] = xx + WIDTH_13 + WIDTH_02 * 2 + GAP_T;
                    }
                }

                // 下家手牌
                h = dtl['h'][(seat + 1) & 3];
                p = h['p'] || [];
                s = h['s'];
                o = p.length * 3;
                sta = this.standing_[1];
                for (let i = 0; i < 13; ++i) {
                    let sp = sta[i];
                    if (i >= o) {
                        sp.visible = true;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = sta[13];
                    sp.visible = true;
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_type(pack);
                    let tile = pack_tile(pack);
                    let pplen = this.packData_[1].length;
                    let hdn = pplen * 3;
                    let ext = (HEIGHT_02 - HEIGHT_13 + GAP_T) * .5;
                    if (type == 2) {
                        ext += HEIGHT_13 * .5;
                        if (pack_offer(pack) == 0) {
                            ext -= (HEIGHT_02 - HEIGHT_13) * .5;
                        }
                    }

                    // 立牌往上，已有的副露往下
                    this.openPos_[1] -= ext;
                    let prev = this.packs_[1];
                    for (let i = 0, len = prev.length; i < len; ++i) {
                        let sp = prev[i];
                        sp.y += ext;
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_offer(pack)) {
                        default: t0 = new PoolTile2(tile - 4); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile + 4); break;
                        case 2: t0 = new PoolTile2(tile); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile + 4); break;
                        case 3: t0 = new PoolTile2(tile + 4); t1 = new PoolTile1(tile - 4); t2 = new PoolTile1(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile2(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        case 2: hz = 1; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        case 3: hz = 2; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile1(tile); t3 = new PoolTile0(tile); break;
                        case 0: hz = 3; t0 = create_w13(); t1 = create_w13(); t2 = create_w13(); t3 = create_w13(); t1.ck_ = true; t2.ck_ = true; break;
                        }
                        break;
                    case 3:
                        switch (pack_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        case 2: hz = 5; t0 = new PoolTile1(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile1(tile); break;
                        case 3: hz = 6; t0 = new PoolTile1(tile); t1 = new PoolTile1(tile); t2 = new PoolTile0(tile); t3 = new PoolTile0(tile); break;
                        }
                        break;
                    }

                    this.addChild(t0); this.packs_[1].push(t0); t0.zIndex = 169 - pplen * 4;
                    this.addChild(t1); this.packs_[1].push(t1); t1.zIndex = 168 - pplen * 4;
                    this.addChild(t2); this.packs_[1].push(t2); t2.zIndex = 167 - pplen * 4;
                    if (t3 != undefined) { this.addChild(t3); this.packs_[1].push(t3); t3.zIndex = 166 - pplen * 4; }

                    // 不是动画
                    let xx = sta[0].x;
                    let x0 = xx - (WIDTH_13 - WIDTH_13S);
                    let yy = sta[hdn + 3].y - ext + GAP_T + HEIGHT_13 * 2;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 2);
                            t1.position.set(x0, yy + HEIGHT_13);
                            t2.position.set(x0, yy);
                        }
                        else {
                            t0.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 3);
                            t1.position.set(x0, yy + HEIGHT_13 * 2);
                            t2.position.set(x0, yy + HEIGHT_13);
                            t3.position.set(x0, yy);
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.position.set(x0, yy + HEIGHT_13 + HEIGHT_02);
                            t1.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13);
                            t2.position.set(x0, yy);
                        }
                        else {
                            t0.position.set(x0, yy + HEIGHT_13 * 2 + HEIGHT_02);
                            t1.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 2);
                            t2.position.set(x0, yy + HEIGHT_13);
                            t3.position.set(x0, yy);
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.position.set(x0, yy + HEIGHT_02 + HEIGHT_13);
                            t1.position.set(x0, yy + HEIGHT_02);
                            t2.position.set(xx - (WIDTH_02 - WIDTH_13S), yy);
                        }
                        else {
                            t0.position.set(x0, yy + HEIGHT_02 + HEIGHT_13 * 2);
                            t1.position.set(x0, yy + HEIGHT_02 + HEIGHT_13);
                            t2.position.set(x0, yy + HEIGHT_02);
                            t3.position.set(xx - (WIDTH_02 - WIDTH_13S), yy);
                        }
                        break;
                    case 3:
                        t0.position.set(x0, yy + HEIGHT_13 * 3);
                        t1.position.set(x0, yy + HEIGHT_13 * 2);
                        t2.position.set(x0, yy + HEIGHT_13);
                        t3.position.set(x0, yy);
                        break;
                    case 4:
                        t0.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13 * 2);
                        t1.position.set(xx - (WIDTH_02 * 2 - WIDTH_13S), yy + HEIGHT_13 * 2);
                        t2.position.set(x0, yy + HEIGHT_13);
                        t3.position.set(x0, yy);
                        break;
                    case 5:
                        t0.position.set(x0, yy + HEIGHT_13 + HEIGHT_02);
                        t1.position.set(xx - (WIDTH_02 - WIDTH_13S), yy + HEIGHT_13);
                        t2.position.set(xx - (WIDTH_02 * 2 - WIDTH_13S), yy + HEIGHT_13);
                        t3.position.set(x0, yy);
                        break;
                    case 6:
                        t0.position.set(x0, yy + HEIGHT_02 + HEIGHT_13);
                        t1.position.set(x0, yy + HEIGHT_02);
                        t2.position.set(xx - (WIDTH_02 - WIDTH_13S), yy);
                        t3.position.set(xx - (WIDTH_02 * 2 - WIDTH_13S), yy);
                        break;
                    }

                    this.packData_[1].push(pack);

                    // 移动余下立牌
                    for (let i = 0; i < 14; ++i) {
                        sta[i].y -= ext;
                    }
                }

                // 对家手牌
                h = dtl['h'][(seat + 2) & 3];
                p = h['p'] || [];
                s = h['s'];
                o = p.length * 3;
                sta = this.standing_[2];
                for (let i = 0; i < 13; ++i) {
                    let sp = sta[i];
                    if (i >= o) {
                        sp.visible = true;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = sta[13];
                    sp.visible = true;
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_type(pack);
                    let tile = pack_tile(pack);
                    let pplen = this.packData_[2].length;
                    let hdn = pplen * 3;
                    let ext = (WIDTH_13 - WIDTH_02 + GAP_T) * .5;
                    if (type == 2) {
                        ext += WIDTH_02 * .5;
                        if (pack_offer(pack) == 0) {
                            ext -= (WIDTH_13 - WIDTH_02) * .5;
                        }
                    }

                    // 立牌往左，已有的副露往右
                    this.openPos_[2] -= ext;
                    let prev = this.packs_[2];
                    for (let i = 0, len = prev.length; i < len; ++i) {
                        let sp = prev[i];
                        sp.x += ext;
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_offer(pack)) {
                        default: t0 = new PoolTile3(tile - 4); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile + 4); break;
                        case 2: t0 = new PoolTile3(tile); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile + 4); break;
                        case 3: t0 = new PoolTile3(tile + 4); t1 = new PoolTile2(tile - 4); t2 = new PoolTile2(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile3(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        case 2: hz = 1; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        case 3: hz = 2; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile2(tile); t3 = new PoolTile1(tile); break;
                        case 0: hz = 3; t0 = create_w02(); t1 = create_w02(); t2 = create_w02(); t3 = create_w02(); t1.ck_ = true; t2.ck_ = true; break;
                        }
                        break;
                    case 3:
                        switch (pack_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        case 2: hz = 5; t0 = new PoolTile2(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile2(tile); break;
                        case 3: hz = 6; t0 = new PoolTile2(tile); t1 = new PoolTile2(tile); t2 = new PoolTile1(tile); t3 = new PoolTile1(tile); break;
                        }
                        break;
                    }

                    this.addChild(t0); this.packs_[2].push(t0); t0.zIndex = 170 + pplen * 4;
                    this.addChild(t1); this.packs_[2].push(t1); t1.zIndex = 171 + pplen * 4;
                    this.addChild(t2); this.packs_[2].push(t2); t2.zIndex = 172 + pplen * 4;
                    if (t3 != undefined) { this.addChild(t3); this.packs_[2].push(t3); t3.zIndex = 173 + pplen * 4; }

                    // 不是动画
                    let xx = sta[hdn + 3].x - ext + GAP_T + WIDTH_02;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.x = xx + WIDTH_02 * 2;
                            t1.x = xx + WIDTH_02;
                            t2.x = xx;
                        }
                        else {
                            t0.x = xx + WIDTH_02 * 3;
                            t1.x = xx + WIDTH_02 * 2;
                            t2.x = xx + WIDTH_02;
                            t3.x = xx;
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.x = xx + WIDTH_02 + WIDTH_13;
                            t1.x = xx + WIDTH_02;
                            t2.x = xx;
                        }
                        else {
                            t0.x = xx + WIDTH_02 * 2 + WIDTH_13;
                            t1.x = xx + WIDTH_02 * 2;
                            t2.x = xx + WIDTH_02;
                            t3.x = xx;
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.x = xx + WIDTH_13 + WIDTH_02;
                            t1.x = xx + WIDTH_13;
                            t2.x = xx;
                        }
                        else {
                            t0.x = xx + WIDTH_13 + WIDTH_02 * 2;
                            t1.x = xx + WIDTH_13 + WIDTH_02;
                            t2.x = xx + WIDTH_13;
                            t3.x = xx;
                        }
                        break;
                    case 3:
                        t0.x = xx + WIDTH_02 * 3;
                        t1.x = xx + WIDTH_02 * 2;
                        t2.x = xx + WIDTH_02;
                        t3.x = xx;
                        break;
                    case 4:
                        t0.x = xx + WIDTH_02 * 2;
                        t1.position.set(xx + WIDTH_02 * 2, HEIGHT_13);
                        t2.x = xx + WIDTH_02;
                        t3.x = xx;
                        break;
                    case 5:
                        t0.x = xx + WIDTH_02 + WIDTH_13;
                        t1.x = xx + WIDTH_02;
                        t2.position.set(xx + WIDTH_02, HEIGHT_13);
                        t3.x = xx;
                        break;
                    case 6:
                        t0.x = xx + WIDTH_13 + WIDTH_02;
                        t1.x = xx + WIDTH_13;
                        t2.x = xx;
                        t3.position.set(xx, HEIGHT_13);
                        break;
                    }

                    this.packData_[2].push(pack);

                    // 移动余下立牌
                    for (let i = 0; i < 14; ++i) {
                        sta[i].x -= ext;
                    }
                }

                // 上家手牌
                h = dtl['h'][(seat + 3) & 3];
                p = h['p'] || [];
                s = h['s'];
                o = p.length * 3;
                sta = this.standing_[3];
                for (let i = 0; i < 13; ++i) {
                    let sp = sta[i];
                    if (i >= o) {
                        sp.visible = true;
                    }
                }
                if (s[13 - o] != undefined) {
                    let sp = sta[13];
                    sp.visible = true;
                }

                for (let k = 0; k < p.length; ++k) {
                    let pack = p[k];
                    let type = pack_type(pack);
                    let tile = pack_tile(pack);
                    let pplen = this.packData_[3].length;
                    let hdn = pplen * 3;
                    let ext = (HEIGHT_02 - HEIGHT_13 + GAP_T) * .5;
                    if (type == 2) {
                        ext += HEIGHT_13 * .5;
                        if (pack_offer(pack) == 0) {
                            ext -= (HEIGHT_02 - HEIGHT_13) * .5;
                        }
                    }

                    // 立牌往下，已有的副露往上
                    this.openPos_[3] += ext;
                    let prev = this.packs_[3];
                    for (let i = 0, len = prev.length; i < len; ++i) {
                        let sp = prev[i];
                        sp.y -= ext;
                    }

                    // 生成一组副露
                    let t0, t1, t2, t3;
                    let hz = 0;
                    switch (type) {
                    case 0:
                        switch (pack_offer(pack)) {
                        default: t0 = new PoolTile0(tile - 4); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile + 4); break;
                        case 2: t0 = new PoolTile0(tile); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile + 4); break;
                        case 3: t0 = new PoolTile0(tile + 4); t1 = new PoolTile3(tile - 4); t2 = new PoolTile3(tile); break;
                        }
                        break;
                    case 1:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t0.pr_ = true; break;
                        case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t1.pr_ = true; break;
                        case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t2.pr_ = true; break;
                        }
                        break;
                    case 2:
                        switch (pack_offer(pack)) {
                        default: hz = 0; t0 = new PoolTile0(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        case 2: hz = 1; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        case 3: hz = 2; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile3(tile); t3 = new PoolTile2(tile); break;
                        case 0: hz = 3; t0 = create_w13(); t1 = create_w13(); t2 = create_w13(); t3 = create_w13(); t1.ck_ = true; t2.ck_ = true; break;
                        }
                        break;
                    case 3:
                        switch (pack_offer(pack)) {
                        default: hz = 4; t0 = new PoolTile0(tile); t1 = new PoolTile0(tile); t2 = new PoolTile3(tile); t3 = new PoolTile3(tile); break;
                        case 2: hz = 5; t0 = new PoolTile3(tile); t1 = new PoolTile0(tile); t2 = new PoolTile0(tile); t3 = new PoolTile3(tile); break;
                        case 3: hz = 6; t0 = new PoolTile3(tile); t1 = new PoolTile3(tile); t2 = new PoolTile2(tile); t3 = new PoolTile2(tile); break;
                        }
                        break;
                    }

                    this.addChild(t0); this.packs_[3].push(t0); t0.zIndex = 240 + pplen * 4;
                    this.addChild(t1); this.packs_[3].push(t1); t1.zIndex = 241 + pplen * 4;
                    this.addChild(t2); this.packs_[3].push(t2); t2.zIndex = 242 + pplen * 4;
                    if (t3 != undefined) { this.addChild(t3); this.packs_[3].push(t3); t3.zIndex = 243 + pplen * 4; }

                    // 不是动画
                    let yy = sta[hdn + 3].y + ext - GAP_T;

                    switch (hz) {
                    case 0:
                        if (t3 == undefined) {
                            t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 * 2;
                            t2.y = yy - HEIGHT_13;
                        }
                        else {
                            t0.y = yy - HEIGHT_13 * 3 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 * 3;
                            t2.y = yy - HEIGHT_13 * 2;
                            t3.y = yy - HEIGHT_13;
                        }
                        break;
                    case 1:
                        if (t3 == undefined) {
                            t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 - HEIGHT_02;
                            t2.y = yy - HEIGHT_13;
                        }
                        else {
                            t0.y = yy - HEIGHT_13 * 3 - HEIGHT_02;
                            t1.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                            t2.y = yy - HEIGHT_13 * 2;
                            t3.y = yy - HEIGHT_13;
                        }
                        break;
                    case 2:
                        if (t3 == undefined) {
                            t0.y = yy - HEIGHT_02 - HEIGHT_13 * 2;
                            t1.y = yy - HEIGHT_02 - HEIGHT_13;
                            t2.y = yy - HEIGHT_02;
                        }
                        else {
                            t0.y = yy - HEIGHT_02 - HEIGHT_13 * 3;
                            t1.y = yy - HEIGHT_02 - HEIGHT_13 * 2;
                            t2.y = yy - HEIGHT_02 - HEIGHT_13;
                            t3.y = yy - HEIGHT_02;
                        }
                        break;
                    case 3:
                        t0.y = yy - HEIGHT_13 * 4;
                        t1.y = yy - HEIGHT_13 * 3;
                        t2.y = yy - HEIGHT_13 * 2;
                        t3.y = yy - HEIGHT_13;
                        break;
                    case 4:
                        t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                        t1.position.set(WIDTH_02, t0.y);
                        t2.y = yy - HEIGHT_13 * 2;
                        t3.y = yy - HEIGHT_13;
                        break;
                    case 5:
                        t0.y = yy - HEIGHT_13 * 2 - HEIGHT_02;
                        t1.y = yy - HEIGHT_13 - HEIGHT_02;
                        t2.position.set(WIDTH_02, t1.y);
                        t3.y = yy - HEIGHT_13;
                        break;
                    case 6:
                        t0.y = yy - HEIGHT_02 - HEIGHT_13 * 2;
                        t1.y = yy - HEIGHT_02 - HEIGHT_13;
                        t2.y = yy - HEIGHT_02;
                        t3.position.set(WIDTH_02, t2.y);
                        break;
                    }

                    this.packData_[3].push(pack);

                    // 移动余下立牌
                    for (let i = 0; i < 14; ++i) {
                        sta[i].y += ext;
                    }
                }

                this.addBtns(dtl['a']);
                this.sortChildren();
            }

        }

        Pool.readyTex = base64Tex('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAB3RJTUUH5AMRFScVQ/GOCwAAAAZiS0dEAP8A/wD/oL2nkwAAD8pJREFUeNrtnXt0HNV9xz/3zuyutKuXJRvbsiXZxsZQi5jQmIJjbDAQXi2EgAklTkpympASaHwAEwLhEXJo3TQk5FEnUJK0B0II1E1iH1KKT0OA8MYBAyXY2NRgsB62JVmynrszt3/MzGp2Je3sEmW1s7nfc/YcPWZnduc739/r3vu7oKGhoaGhoaGhoaGhoaGhoVEmEGX+3aqAGvfnXqAPUJrgcMMAjgM+DiwHZrrfsxN4DngIeB5IaX2HD1XA9cA+V6njvfYDXwPq9O0KF2LABmAkB7neKwVsdB8IbaJDgk8AdwNxgIZ6g7/8SDUnLosjBbz48iBbHumjvTNtmUeAdcD3tTamHhJYAFzsmuCbgM8BfwFUAvXAbz2FtjRF1C/va1Yj7UuU6mpVqqtVJTuWqK3/OU8tXhjzK3k7MEff3qlFI3A7sBtI+sixgS5gE3CjFyGbplAb/7lRqYOtKtW5JOOlulrVT+6aqyoqhHeOYeDCcldGKeNo4F7gy66CzSz3Mg34GHCL50/nNUU4+4wqlBqbDdmW4vRVVRy9MOb9KQocW84EmyX82Y4A7gRWe3+oqZbMb44Siwnea0vR1pHEtgGIeMdMbzCprTYYh1+UgqqE5IgZGV+7zn1YZgMtQDXQD+x1o/GUJviPg8uAMwCEgNNWVnHdVdNZemwFEVPQ1pHk3p/1sPFHXfT22aMqtdW46vXOY9uK4ZGM/zcB3wTOcv1x1HUF7cDjwD1u3mxrgicPM9xChQQ4+cQ493y7kZbmKLblkDOtLsZtN8ykusrglg2dpKz8ClS2gmQy49jz3OKIyEq5Frqvc928+V9d4rUPngQsBhYBRKOCK/62gZbmKFZKoZRjai0LTAM+s7aOY5fERr+QFAgxcfbnvFdlP+QCoKJCMK3OIF6ZcVtmAf8EfForeHIj5zjA9HqD41orUPY4QZMNMxpMjmut5KVXhtJmOAe/2Dae304jEZesOb+Gi86vZc4sk/0HLbY80sd9D/bQfcjyKmQ34JQ6t2uC/3CkTaZhCCJm7npMNCJ8Cg4w0bbC8hEciwpuunYGX7y8gYpK6UhcCE5dkWBpawVXf6XN8/EtwNqwEVyqJtr2m1SVw71KCfG4yAikghU8esJTT07wd5+pJxoVWCmFZYGVUkgJay+u5YJza/xvP9UtqmiCJ0HBaQJzqVIIQUVs9AApxIQEC5wAa3h4lOCVyxPU1IxNq5SCWEzykdVVGIbwu44jNMGT4zrEaNAUbHbTJMocChaQSimSqdHjq+K5b0FdjYE56sgibhqlCZ6szyUleRDse6PIPYIipED6DjCM3OceGlbYVvrXJM4ghSZ4shRsSEfFE0PhD7CFdB2xmljt/gfCZ34nSKuU/1ReDVsTPHkKdk20mpDfDBPt+WCVIw/2DhcCTLOcZy2FJcgSufSbaaILiaKFCDbR40TwWsGTTbCQue+q30RLmdsHK5Vpok2jIAWHbsLeVBY66oGlOGXJKqAHeB142U+wIQUyoPTor3IVUskSQgQqOOxzMKeC4DiwBrgc+ACQ8N3KPuAZf6RacBQdEEbbPp8t8lCwCjnJxSa4Fmdk5rNAxTh1iBrgTP8t9Uw0eZpoEZAm2bYzUOFdMVDBIde0WeRrXQ9c4ZngaEQwpzFCbbXkYLdFW3vKG/YTfkXmDLKyo2jJhAwLL03yRdEyDx8cZitdTIJXuWbZAFi4IMr6K6dzxilVVFdJurotNj/Sx7e+f4B97SkKMdEqo9AhJlawcNTr99mGLCiK1kFWjqj4Upw5VMyZHeGuOxpZvaoKZTtjvA31Btdc2UDTnAifv3ofPb1WuhCRu9AxNorOBcvKVLBhFJwH6zRpHEzHmeIKwCUfq+WUFQmslJOyOGbWUeJHz6nmzNOqMgmxg0x0NsETF6Mta1SVgvflg3WhYxw0uCRjmoLlJ8TH9X3eCM6CeaP1/J5em4FBOyD1yc8HA1iuxchXwSrkYXSxCDa8axkSKmK5oyb/lBrbR0g+laycPhjHB3sPhJTC8cFKK/gPhfKnlDlNLr40BudhiJg5Bv0VYwcbAnxwWsGyYB+sBxtyXEemU5M8SEhLP48gS2Wb6AAFewTLfGvRSis4HxMtRv1e/kGTaYicpKlxKlm5/LU/aHNMdHnnwUVXsBSuIlW+Cg5QpVL5p0kCLNunYAnSKGd6i0vwqIJlbgWnfD44rzw4Yzw4nzxYpQnOL4rWPrgggoPKg3YBCh6bB+cuRmf6YDeKLuMwuuhpUj4Ktsb44NwmvZDxYMtS6dJmWsE6TZpkBRcURTvHq5xBVqEm2p8m5eZXz+goOE0Kjlz9ebBp5i5coDIHG0TAuVMW6dWHUpBXFK3TpIJ9cICJ9ik4YooCB/wJTJP8/joois6KqpQmOI9CR6CC7SwFB026U/kXOlKpzDQpUMEh98/FDLLSZlHmiFyzFWyaAePBamwtOl//LmX5z+iYkkpW7jRJjfHBuRiWEiorRr9GVULmfCBSvlq0IfMog4Y8ijaLrWAhco/gKJwhvXyDrGhU8KlL6ti9Z4TaaskF51YHBlkZEboIYFHPqixQwTKo9JhpcoOCLNuG886q5qQPVdqmKUT9NEPkGq1KpTKDrKA512Gnu+gEOz5Y5LxTfj4DfbCLI2Y4a1BUAAXRiLu0RUG8MnhxufbBhQZZAUtRTFPQ0pzuisS85mjgxDiP2CByla1Y9eEEq09O0Dw3wifW1DGtzsg9oUCb6AIV7JrFCZ84AesubyBeIamslFz213XY+d3kQCnaNixaEOWBe5ro7bOZ02jmZR2Unvg+eQq2FSyYF2XDrTMReSqzIPuqoH6aQUO9kXNmyQT2OHSjScUiWI4qOLic6M2i+GPdyYIeGqXHgws20bK8l+T+SRIs/T5WhIjgSdTvNGA+o4vtyorgcqkbvB/MwlmyswWn9+XPgGXl5oOV/6cwuTXx/syNAJpxelF/Emj13esmnF6cF+F0tC0vgsMWs3guRY0uKRYBFnERcIn7OmoCK7kMp8/1t8uFYNsl2Wm1HioFj1GmnOA+tuK0OrwQp+1h+p2xmOCED1bSfcjmtd8Peec5DfgBTtf50Ptgn4JVqPxwVkuIbAVHgZOA7wG/Aq4B5nnHJOKSM1dX8ePvzmHz/S2svbjWf+oFOAvey9BEh4jhrIERj9wYsAKnafnZOIvr0qitMVh9coLLLq1j1fIEtTUGSJiZ2Wm+krFdDnSQNRVBlk/BEZwG4acAp2crcHqDwdmnV/M3H6/jxGVxEnHpdLe1FIYQGZ3pcbrmJcuJYN9CTBUigj3hKnAakX6DrH6VjbNMzju7hk9eXMefL60gFhslNs3miGLby4P+t+3D2U+x/Ex0mBScNY9eeuQKAfOaolx0fg2XXljLkqMriEQElqWyO8pjGIKnnu/n0ccO+//8LDBQngSHKMiKRNzFb+5MEEPCUQtjXHJBLWs+WstRR0aRBtjWmK0C0sfv3D3Ml27t8O+6th/YXJ6FjhBZaGUrWo+JcfzSCra/Nswxi2OsXeM0CW9uirhde/B3ox0ToLXvt1h/czvPvjjg//b/BrxQbgSrsCnYtmF+S5T7725izzsjLF4UY/YsMz2tSAX47sP9Nrdu6GTLf/f5//Vz4OujNqHsTHS4bLRSMK85wvyWqNNjKw9ahNt4/JsbD/Kj+7v9McdTwHrgQLE+v/bBeSq50E/97w/0cMe/HPDv0fQGzm6nbxU1SCzWPcqw1WU8pGRIeHhrHzf/Yyd9h9Nfuw24Gnix6FnAVBQ6ynXM0DAEz20b5NqbMiLmXpzdUf9rStK8Il0n6anYspxNMUQZKnfHrmHW3djOzt3p8YMRN6C6d8ry+CJdp9clmaFhRc8hK1zTOoJuooS2jhTX3JSRDtk4G1veyRTuYFosgg8ChwEGBhVtHamy2VxeCOjts7nx9k5+tTUjHfoFzr7G/VP68BXpOvuBTs9E79g1XBZ+WAgYGVFsuHM/9z7Y4w8enwCuLWY6NNUE9wA7vV9+98oQQ0N26Am2bfjBj7v4zt1d/jVPrwFfBP6vJNxHEYOsdIqw/dUh3t2XDFysXep+98FfHOK2b+xnYDD9sL7jkvtyyXzOIl7rKTfY4p33kjz57EDgBPjSTYdg62P9fOmrHXT3WP444zrg1yX1IBbxWq8Cr3h+eNOWXg4ftkIXTBuG4PnfDbLuxjbe3Zcerx8AbgMeKjlLU8Rr9QC/TEchT/fz5DMDgSvsS025b+wc5u+vb+P3O9O5bgr4FnAXvopdyXzmIl+vEzgHqB8ZURzqszn3jGpisdInWUrY+16SK9a38cTTGUN/P3TToYGSfCiLfL0unA2xTgHYszfJ3MYIH/pgZUnXp6WEzgMW625oyx7624Qzk7K7ZK3OFFxzj0vwLMuC13cMc9KyOE1zoiVJspTQ1W1x3Vfb+emmQ/5//Q/wBZyBBDTBozjkRtNnAdGeQxZv7h5h1YoE9dOMkiLZMKC9I8X6Wzq476Ee/3ri53DWG+0u+bhhiq77Js4mHScA4u29Sd7em2TFiQnqamVJkGwYgtffGOaq69vZtKXXT+6rwOe8jEATPD4s4CVgCc5aHnbsGubNt0Y44fg4DfXmlJEspdNp7+FH+/jCdW389tmM2Gm7q9wXCAmmctegfpzq1vE4K/HYuWuEF14a5KgjozTPjRQ1R/a22HmvLcXXv3OAm/+hkz17M+alP+GSuy1UefsUX/+g688+4JH87r4kjz7WjwAWL4qRSBhFIba3z2bT5l6u/ko7/7H5EAODaROSBH4KXAXsIGQolQR0Ic6Kgb/yii8RU7ByeZwrP9vAaSsTVFcbKFvl1Tglny8tpLMs5WBXil8/2c8P7+vm8af7GRrK8A3twB1uEaOPEKKUKgzTcYbYPo+zDS0AiYRk1fIEl15Yy6oPJ5g908QwRXrPw3x8tbdC0FvMPTBos+utEbb+5jA/f7iXbdsHs4lNumnQ7cDTpVihCiPB4CzuOgf4Ms4i6XQpNRoRLDoyyqrlCVYuT3Dsn8WYPTNCVUK63fCy9mpw+UqlFENDNge7LXbvGeHFlwZ58pkBtm0fpKMzld2Dywb+F9gIPIBTXg01SrVGOBv4FPBpN8rOqJlHTMH06QYtc6PMb4kwtzHCjAaT6ipJxBRYtuJwv83BLot9HUne2Zvk7XeTtHekGBiwx5trkMLZXv4nrr/di0ZRHr75rtl+DqfWqybxZePMuHjYfZAay/UmhgENONvTngksB450/XSho2GDQIdbrHgc+I2r3MFyVknYPu80nPYHrcAxrspnuoRXuqmfDQzhlEQPuCb3TZzVBTtx6sfD/AmgHOY2GjitECrcIE26BKdcEocowkp6DQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDY1Jw/8DfzHUjiF21CoAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDMtMTdUMjE6Mzk6MTIrMDA6MDDXr5I5AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTAzLTE3VDIxOjM5OjEyKzAwOjAwpvIqhQAAAABJRU5ErkJggg==');

        /**
         * 立牌
         * @typedef {object} StandingTile
         */
        class StandingTile extends PIXI.Sprite {
            /**
             * @param {number} t 牌张
             * @param {function(StandingTile):void} cb 点击回调
             */
            constructor(t, cb) {
                let ti = all_tiles[t];
                let tex = StandingTile.tex0.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                super(tex);
                this.t_ = t;

                if (tz.nht) {
                    let ht = this.ht_ = new PIXI.extras.BitmapText(hint_text[t >> 2], { font: '24px shsb'});
                    this.addChild(ht);
                    ht.x = 4;
                    ht.y = 18;
                }

                if (!cb) {
                    return;
                }

                tex = StandingTile.tex0.clone();
                tex.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * 7 + 2, (HEIGHT_02F + 2) * 3 + 2,
                    WIDTH_02, HEIGHT_02F);
                let fg = new PIXI.Sprite(tex);
                this.addChild(fg);
                fg.anchor.y = 1;
                fg.alpha = .3;
                this.fg_ = fg;
                fg.visible = false;

                this.cb_ = cb;
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                this.interactive = true;
                this.on('click', this.click);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', this.click);
                //this.on('touchstart', hlt);
                //this.on('touchendoutside', nml);
                //this.on('touchend', nml);
            }

            /**
             * 更新牌张
             * @param {number} t 牌张
             */
            update(t) {
                update_t02(this, t);
            }

            /**
             * 重新布局，需在改变锚点后调用
             */
            layout() {
                if (tz.nht) {
                    let ht = this.ht_;
                    if (ht) {
                        ht.x = 4 - WIDTH_02 * this.anchor.x;
                        ht.y = 18 - HEIGHT_02F * this.anchor.y;
                    }
                }
            }

            /**
             * 设置高亮状态
             * @param {boolean} h 高亮状态
             */
            setHighlight(h) {
                this.fg_.visible = h;
            }

            /**
             * 获取高亮状态
             * @returns {boolean}
             */
            isHighlight() {
                return this.fg_.visible;
            }

            /**
             * 点击这张牌
             */
            click() {
                this.cb_(this);
            }
        }

        /**
         * 更新牌张（自己、对家）
         * @param {object} sp 要更新的牌（精灵）
         * @param {number} t 牌张
         */
        function update_t02(sp, t) {
            if (sp.t_ != t) {
                let ti = all_tiles[t];
                sp.texture.frame = new PIXI.Rectangle(
                    (WIDTH_02 + 2) * (ti & 0xF) + 2, (HEIGHT_02F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_02, HEIGHT_02F);
                sp.t_ = t;

                let ht = sp.ht_;
                if (tz.nht && ht) {
                    ht.text = hint_text[t >> 2];
                }
            }
        }

        /**
         * 更新牌张（下家、上家）
         * @param {object} sp 要更新的牌（精灵）
         * @param {number} t 牌张
         */
        function update_t13(sp, t) {
            if (sp.t_ != t) {
                let ti = all_tiles[t];
                sp.texture.frame = new PIXI.Rectangle(
                    (WIDTH_13 + 2) * (ti & 0xF) + 2, (HEIGHT_13F + 2) * ((ti & 0xF0) >> 4) + 2,
                    WIDTH_13, HEIGHT_13F);
                sp.t_ = t;

                let ht = sp.ht_;
                if (tz.nht && ht) {
                    ht.text = hint_text[t >> 2];
                }
            }
        }

        /**
         * 创建牌墙（自己、对家）
         */
        function create_w02() {
            let tex = PoolTile.tex0.clone();
            tex.frame = new PIXI.Rectangle(
                (WIDTH_02 + 2) * 8 + 2, (HEIGHT_02F + 2) * 4 + 2,
                WIDTH_02, HEIGHT_02F);
            return new PIXI.Sprite(tex);
        }

        /**
         * 创建牌墙（下家、上家）
         */
        function create_w13() {
            let tex = PoolTile.tex1.clone();
            tex.frame = new PIXI.Rectangle(
                (WIDTH_13 + 2) * 8 + 2, (HEIGHT_13F + 2) * 4 + 2,
                WIDTH_13, HEIGHT_13F);
            return new PIXI.Sprite(tex);
        }

        /**
         * 创建立牌（下家）
         */
        function create_st1() {
            return new PIXI.Sprite(StandingTile.tex1);
        }

        /**
         * 创建立牌（对家）
         */
        function create_st2() {
            let tex = PoolTile.tex2.clone();
            tex.frame = new PIXI.Rectangle(
                (WIDTH_02 + 2) * 8 + 2, (HEIGHT_02F + 2) * 4 + 2,
                WIDTH_02, HEIGHT_02F);
            return new PIXI.Sprite(tex);
        }

        /**
         * 创建立牌（上家）
         */
        function create_st3() {
            let tex = StandingTile.tex3;
            return new PIXI.Sprite(StandingTile.tex3);
        }

        const rcs = [
            new PIXI.Rectangle(2, 2, 72, 200), new PIXI.Rectangle(76, 2, 90, 200), new PIXI.Rectangle(168, 2, 70, 200),
            new PIXI.Rectangle(240, 2, 70, 200), new PIXI.Rectangle(312, 2, 70, 200), new PIXI.Rectangle(384, 2, 70, 200),
            new PIXI.Rectangle(2, 204, 70, 200), new PIXI.Rectangle(74, 204, 70, 200), new PIXI.Rectangle(146, 204, 58, 200),
        ];

        /**
         * 创建骰子
         */
        function createDice(n) {
            let tex = PIXI.loader.resources[`img/dice/${n}.png`].texture;
            let frames = [];
            for (let i = 0; i < 9; ++i) {
                let f = new PIXI.Texture(tex, rcs[i]);
                frames.push(f);
            }
            let asp = new PIXI.extras.AnimatedSprite(frames);
            asp.x = 100;
            asp.y = 100;
            asp.animationSpeed = .4;
            asp.loop = false;
            asp.play();
            return asp;
        }

        /**
         * 选项栏
         * @typedef {object} OptionPanel
         */
        class OptionPanel extends PIXI.Container {
            constructor() {
                super();

                let btns = new Array(7);
                const btnTitle = ['自动补花', '不 吃', '不 碰', '不 杠', '只和自摸', '自动和牌', '自动摸打'];
                for (let i = 0; i < 7; ++i) {
                    let cb = new CheckBox(btnTitle[i]);
                    this.addChild(cb);
                    cb.x = 200 * i;
                    btns[i] = cb;
                }
                this.btns_ = btns;

                // 加这个布局才正常
                //let bg = new PIXI.Graphics();
                //this.addChild(bg);
                //bg.drawRect(0, 0, 1100, 45);
            }

            /**
             * 重置
             */
            reset() {
                for (let i = 0; i < 7; ++i) {
                    let cb = this.btns_[i];
                    cb.setSelected(i == 0);
                }
            }

            /**
             * 获取
             * @returns {array}
             */
            status() {
                let s = new Array(7);
                for (let i = 0; i < 7; ++i) {
                    s[i] = this.btns_[i].isSelected();
                }
                return s;
            }
        }

        /**
         * 玩家信息栏
         * @typedef {object} InfoPanel
         */
        class InfoPanel extends PIXI.Container {
            constructor() {
                super();

                const width = 180, height = 160;
                //this.width = width;
                //this.height = height;
                this.pivot.x = width;

                {
                let graph = new PIXI.Graphics();
                //graph.lineStyle(2, 0x0000FF, 1);
                graph.beginFill(0x000000, .25);
                graph.drawRect(0, 0, width, height);
                graph.endFill();
                this.addChild(graph);
                }

                let text = this.lcText_ = new PIXI.Text('掉线', {
                    fontFamily: FF,
                    fontSize: 60,
                    fill: '#ffffff'
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5;
                text.y = height * .5;
                text.alpha = .2;
                text.visible = false;

                text = this.nameText_ = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 28,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5;
                text.y = height * .5;

                let flw = new PIXI.Sprite(WinHand.flwTex);
                this.addChild(flw);
                flw.scale.set(.8);
                flw.anchor.set(.5);
                flw.x = width * .5 - 23;
                flw.y = height - 25;

                text = this.flowerText_ = new PIXI.Text('\u00D7 0', {
                    fontFamily: FF,
                    fontSize: 26,
                    fill: '#ffffff'
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5 + 17;
                text.y = height - 25;

                text = this.fwText_ = new PIXI.Text('错和', {
                    fontFamily: FF,
                    fontSize: 26,
                    fill: '#ffffff'
                });
                text.anchor.set(.5);
                this.addChild(text);
                text.x = width * .5;
                text.y = 30;
                text.visible = false;
            }

            /**
             * 重置
             */
            reset() {
                this.flowerText_.text = '\u00D7 0';
                this.fwText_.visible = false;
            }

            /**
             * 设置名字
             * @param {string} s 名字
             */
            setName(s) {
                let t = this.nameText_;
                t.text = s;
                scaleText(t, 170);
            }

            /**
             * 获取名字
             * @returns {string}
             */
            getName() {
                return this.nameText_.text;
            }

            /**
             * 设置花牌数
             * @param {number} f 花牌数
             */
            setFlower(f) {
                this.flowerText_.text = '\u00D7 ' + parseInt(f);
            }

            /**
             * 设置掉线状态
             * @param {boolean} lc 掉线状态
             */
            setConnection(lc) {
                this.lcText_.visible = !lc;
            }

            /**
             * 设置错和状态
             * @param {number} fw 错和状态
             */
            setFalseWin(fw) {
                this.fwText_.visible = fw;
            }
        }

        /**
         * 复选框
         * @typedef {object} CheckBox
         */
        class CheckBox extends PIXI.Container {
            /**
             * @param {string} s 文本
             * @param {function(CheckBox):void} cb 回调
             */
            constructor(s, cb) {
                super();

                let bg = new PIXI.Sprite(CheckBox.bgTex);
                this.addChild(bg);
                bg.x = 5;

                let tk = this.tk_ = new PIXI.Sprite(CheckBox.tkTex);
                this.addChild(tk);
                tk.x = 5;
                tk.visible = false;

                let width, height;
                if (s) {
                    let text = this.text_ = new PIXI.Text(s, {
                        fontFamily: FF,
                        fontSize: 30,
                        fill: '#ffffff',
                        stroke: '#000000',
                        strokeThickness: 3,
                    });
                    this.addChild(text);
                    text.x = bg.width + 10;

                    /*this.width =*/ width = bg.width + 10 + text.width + 10;
                    /*this.height =*/ height = Math.max(bg.height, text.height) + 10;
                    text.anchor.y = .5;
                    text.y = height * .5;
                }
                else {
                    /*this.width =*/ width = bg.width + 10;
                    /*this.height =*/ height = bg.height + 10;
                }
                bg.anchor.y = .5;
                tk.anchor.y = .5;
                bg.y = height * .5;
                tk.y = height * .5;

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawRect(0, 0, width, height);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                let clk = ()=>{
                    let tk = this.tk_;
                    if (tk.visible) {
                        tk.visible = false;
                        if (this.text_) {
                            this.text_.style.stroke = '#000000';
                        }
                    }
                    else {
                        tk.visible = true;
                        if (this.text_) {
                            this.text_.style.stroke = '#0066ff';
                        }
                    }

                    if (cb) {
                        cb(this);
                    }
                };
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }

            isSelected() {
                return this.tk_.visible;
            }

            setSelected(s) {
                this.tk_.visible = s;
                if (this.text_) {
                    this.text_.style.stroke = s ? '#0066ff' : '#000000';
                }
            }
        }

        CheckBox.bgTex = base64Tex('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAB+0KVeAAAAIVBMVEUmJij19fnn5+s6Ojy6ur2cnJ8rKy2bm56VlZg5OTw8PD5Ii9qAAAAAQElEQVQoz2NIVRREA0JhDIWCGECCQdGZAQ2YCDEIGqALMgsyCDJggFHBUcHBI4iRaDkFGRQ90QWXCGHNCFizDACdVg4t30uVKQAAAABJRU5ErkJggg==');
        CheckBox.tkTex = base64Tex('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAB+0KVeAAAAGFBMVEUAAAD19fn19fn19fn19fn19fn19fn19fn8h/qnAAAAB3RSTlMAJeSAcaBJxjzuQwAAAGRJREFUKM/lzrENgDAMRNEgGCBCMEAaaOlo6dgHilsfich8YTIBuc7nJ8uhygyFrpmXb9nrLEBps6GLBnVEK9f0wGRde+8d3DMAIoDcMvimQOgEhEpAKBDqIT96mqGnQDLG8ONcEMQfjD5vxOcAAAAASUVORK5CYII=');

        /**
         * 矩形空按钮
         * @typedef {object} EmptyButton
         */
        class EmptyButton extends PIXI.Container {
            /**
             * @param {number} w 宽
             * @param {number} h 高
             * @param {function():void} cb 点击回调
             */
            constructor(w, h, cb) {
                super();

                //this.width = width;
                //this.height = height;

                let clk = cb.bind(this);
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                let bg = new PIXI.Graphics();
                bg.beginFill(0x000000, .25);
                bg.drawRect(0, 0, w, h);
                bg.endFill();
                this.addChild(bg);

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawRect(0, 0, w, h);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }
        }

        /**
         * 文本按钮
         * @typedef {object} TextButton
         */
        class TextButton extends EmptyButton {
            /**
             * @param {string} t 文本
             * @param {object} s 文本样式
             * @param {number} w 宽
             * @param {number} h 高
             * @param {function():void} cb 回调
             */
            constructor(t, s, w, h, cb) {
                super(w, h, cb);

                let f = this.face_ = new PIXI.Text(t, s);
                f.anchor.set(.5);
                f.x = w * .5;
                f.y = h * .5;
                this.addChild(f);
            }
        }

        /**
         * 鸣牌按钮
         * @typedef {object} ActionButton
         */
        class ActionButton extends PIXI.Container {
            constructor() {
                super();

                //this.width = 150;
                //this.height = 150;

                let clk = ()=>{ this.cb_(this); };
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                let bg = this.bg_ = new PIXI.Graphics();
                this.addChild(bg);

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawCircle(75, 75, 75);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                let f = this.face_ = new PIXI.extras.BitmapText('', { font:'100px STXingkai' });
                f.anchor.set(.5);
                f.x = 75;
                f.y = 75;
                this.addChild(f);

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }

            /**
             * 设置
             * @param {number} idx ACTION数组中的索引
             * @param {function(ActionButton):void} cb 点击回调
             */
            setup(idx, cb) {
                this.face_.text = ACTION[idx];
                this.cb_ = cb;

                let bg = this.bg_;
                bg.clear();
                bg.beginFill(idx != 6 ? (idx != 3 ? 0 : 0xFF6A6A) : 0x00CD66, .25);
                bg.drawCircle(75, 75, 75);
                bg.endFill();
            }
        }

        /**
         * 鸣牌选择界面
         * @typedef {object} SelectionView
         */
        class SelectionView extends PIXI.Container {
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             * @param {number} t 鸣牌类型，吃=3，杠=5
             * @param {array} a 可选择的鸣牌
             * @param {function(number):void} cb 回调
             */
            constructor(w, h, t, a, cb) {
                super();

                const w0 = WIDTH_02 * HAND_SCALE, h0 = HEIGHT_02F * HAND_SCALE;
                const width = w0 * 2 + 50;
                const height = h0 + 50;

                //this.width = width * (a.length + 1) + a.length * 10;
                //this.height = height;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();
                ctn.interactive = true;

                let x = (w - ((width + 10) * a.length + width)) * .5;

                for (let i = 0, c = a.length + 1; i < c; ++i) {
                    let ai = a[i];
                    let btn = new EmptyButton(width, height, ()=>{
                        //console.log('click action', a[i]);
                        cb(ai);
                    });
                    this.addChild(btn);
                    btn.x = x + (width + 10) * i;
                    btn.y = h - 550;

                    let tl = '';
                    let t0, py = 25;
                    if (ai != undefined) {
                        switch (t) {
                        case 3:
                            tl = '吃';

                            t0 = new StandingTile(hi_byte(ai));
                            btn.addChild(t0);
                            t0.scale.set(HAND_SCALE);
                            t0.x = 25;
                            t0.y = height - h0 - 5;

                            t0 = new StandingTile(lo_byte(ai));
                            btn.addChild(t0);
                            t0.scale.set(HAND_SCALE);
                            t0.x = 25 + w0;
                            t0.y = height - h0 - 5;
                            break;
                        case 5:
                            tl = '杠';
                            t0 = new StandingTile(lo_byte(ai));
                            btn.addChild(t0);
                            t0.scale.set(HAND_SCALE);
                            t0.x = 25 + w0 * .5;
                            t0.y = height - h0 - 5;
                            break;
                        default:
                            break;
                        }
                    }
                    else {
                        tl = '取消';
                        py = height * .5;
                    }

                    let tx = new PIXI.Text(tl, {
                        fontFamily: FF,
                        fontSize: 32,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    btn.addChild(tx);
                    tx.anchor.set(.5);
                    tx.x = width * .5;
                    tx.y = py;
                }
            }
        }

        /**
         * 一手和牌
         * @typedef {object} WinHand
         */
        class WinHand extends PIXI.Container {
            /**
             * @param {object} ht 手牌
             * @param {number} wt 和牌
             * @param {number} flw 花
             */
            constructor(ht, wt, flw) {
                super();

                const height = Math.max(HEIGHT_13 + HEIGHT_13F, HEIGHT_02 + 40);
                //this.height = height;

                // 加这个布局才正常
                //let bg = new PIXI.Graphics();
                //this.addChild(bg);

                let width = 0;
                if (ht != undefined) {
                    // 副露
                    let ps = ht['p'];
                    if (ps != undefined) {
                        for (let i = 0; i < ps.length; ++i) {
                            let p = ps[i];
                            let o = pack_offer(p);
                            let t = pack_tile(p);
                            switch (pack_type(p)) {
                            case 0: {  // 吃
                                let cls = [PoolTile1, PoolTile0, PoolTile0];
                                let tt;
                                switch (o) {
                                default: tt = [t-4, t, t+4]; break;
                                case 2: tt = [t, t-4, t+4]; break;
                                case 3: tt = [t+4, t-4, t]; break;
                                }
                                for (let i = 0; i < 3; ++i) {
                                    let s = new (cls[i])(tt[i]);
                                    this.addChild(s);
                                    s.anchor.y = 1;
                                    s.layout();
                                    s.x = width;
                                    s.y = height;
                                    width += s.width;
                                }
                                break;
                            }
                            case 1: {  // 碰
                                let cls = [PoolTile0, PoolTile0, PoolTile0];
                                cls[o - 1] = (o == 1) ? PoolTile1 : PoolTile3;
                                for (let i = 0; i < 3; ++i) {
                                    let s = new (cls[i])(t);
                                    this.addChild(s);
                                    s.anchor.y = 1;
                                    s.layout();
                                    s.x = width;
                                    s.y = height;
                                    width += s.width;
                                }
                                break;
                            }
                            case 2: {  // 杠
                                if (o == 0) {  // 暗杠
                                    for (let i = 0; i < 4; ++i) {
                                        let s = (i == 0 || i == 3) ? create_w02() : new PoolTile0(t);
                                        this.addChild(s);
                                        s.anchor.y = 1;
                                        if (i == 1 || i == 2) s.layout();
                                        s.x = width;
                                        s.y = height;
                                        width += s.width;
                                    }
                                }
                                else {  // 明杠（直杠）
                                    let cls = [PoolTile0, PoolTile0, PoolTile0, PoolTile0];
                                    switch (o) {
                                    case 1: cls[0] = PoolTile1; break;
                                    case 2: cls[1] = PoolTile1; break;
                                    case 3: cls[3] = PoolTile3; break;
                                    default: break;
                                    }
                                    for (let i = 0; i < 4; ++i) {
                                        let s = new (cls[i])(t);
                                        this.addChild(s);
                                        s.anchor.y = 1;
                                        s.layout();
                                        s.x = width;
                                        s.y = height;
                                        width += s.width;
                                    }
                                }
                                break;
                            }
                            case 3:  {  // 加杠
                                let cls = [PoolTile0, PoolTile0, PoolTile0];
                                cls[o - 1] = (o == 1) ? PoolTile1 : PoolTile3;

                                let s = new (cls[o - 1])(t);
                                this.addChild(s);
                                s.anchor.y = 1;
                                s.layout();
                                s.x = width + WIDTH_02 * (o - 1);
                                s.y = height - HEIGHT_13;

                                for (let i = 0; i < 3; ++i) {
                                    let s = new (cls[i])(t);
                                    this.addChild(s);
                                    s.anchor.y = 1;
                                    s.layout();
                                    s.x = width;
                                    s.y = height;
                                    width += s.width;
                                }
                                break;
                            }
                            default:
                                break;
                            }

                            width += GAP_T;
                        }
                    }

                    // 立牌
                    let ss = ht['s'];
                    if (ss != undefined) {
                        for (let i = 0; i < ss.length; ++i) {
                            let s = new PoolTile0(ss[i]);
                            this.addChild(s);
                            s.anchor.y = 1;
                            s.layout();
                            s.x = width;
                            s.y = height;
                            width += s.width;
                        }
                        width += GAP_T;
                    }

                    // 和牌
                    if (wt != undefined) {
                        let s = new PoolTile0(wt);
                        this.addChild(s);
                        s.anchor.y = 1;
                        s.layout();
                        s.x = width;
                        s.y = height;
                        width += s.width;
                    }

                    // 花
                    if (flw != undefined && flw > 0) {
                        let s = new PIXI.Sprite(WinHand.flwTex);
                        this.addChild(s);
                        s.scale.set(.6);
                        s.anchor.set(.5);
                        s.x = width - 55;
                        s.y = 15;

                        let t = new PIXI.Text(`\u00D7 ${((flw>>8)&0xFF)+1}`, {
                            fontFamily: FF,
                            fontSize: 18,
                            fill: '#ffffff'
                        });
                        this.addChild(t);
                        t.anchor.set(.5);
                        t.x = width - 25;
                        t.y = 15;
                    }
                }
                //this.width = width;

                //{
                //bg.lineStyle(2, 0x0000FF, 1);
                //bg.beginFill(0xFF00BB, .25);
                //bg.drawRect(0, 0, width, height);
                //bg.endFill();
                //}
            }
        }

        WinHand.flwTex = base64Tex('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAE/0lEQVR42sVYfWwTZRzuxBgiEfUfo4nGL/4yaqKJiYliJEHUZBEzg4kGNSoiEiYiCDLYum8mDhkb2xhsdrR3vWshwGY/7rbBnB/xH6JAkLBkQjJBhTHMHGzd1vbxeXsbXffR3smKTd703u/nnt/32WzX98uADRljnZN27y1izPY//DJGZN/CiKK1se0UA72SNDei6L+wtYzI2oIbhgRe7yyCKIHaMgxPC/gfCruDyyKqXh3rs0U5F3FrBbDbb0o7IF60npdGxy6fvumRsKKvSTM72jyKpD81GKORtb5BZ/ODaWQnWGwWzDVQSktu+hhS9e8sA1L1w2kBY6eCUoFPWWdIO3Hdl/dKgblDkv+xYVfwqUHJf7+wrBhDHv2oVUBRVftpzDrBs8SZQ6rv0Z6GpttSAgm5hNJqDiruRWElhlnroaiq/8wxuzFulSH9z4iq5VF0x3jO0JgF8vkC5+oh+x6aEkzYrb/Khb2mLpIDsApseh3TLkHVMhPAjEj+Z6Iek+b8+WZg8ctAcbnRVzSgbh+wwwGUVRCsH9bFqv8Dd+sTcXNWtP2mD1j6BrBoPrBypdHPrwKyC4BMglz0LJCT91+Y6h1yBx+Pm7MSfIAoT5vaXOsCNmwC/D6g4SDwcREBFQKvZQEvPU/mvrQuNreWN9npqYw9Vg5q6wD2NRtgBKitZCq3DKg/gFFjsCKyk2ElsBxS4F6hP88JkTEgXjGlzCW7qEfbgKIa4NAhYH2ZAarRCawtpR7VAwXVZJE6VrzLkgHQEiuF/nxhmpXS3XFGRPtsC5lQgMJcoEniWGHivHgu22PFRZTawmowyzSgTdvjl8UaL+T7oItsnNnJNWsnzLPl7jANKCxri21/Ow7eQRmeM7VpW2MiAxvzgeMfAd1k52wdcGINRZU/bg3/K1xm/VG3iBCGU1S0D6555mRNKGqlDORVAqtLqE9kpotAushSJ8V2SrDhBiSuqW4A9ngA1zd0BXbgq9pk50bC7sB7cbNn4KQulYuJpIDqeUEu33rvfvb5vJvOsIpAflwF/JBNBnOAVZzfSKBNrUDH9wSyFXiB/umVFwnUN5WFRWJ6PDG7FANhJfgWPXbXtBnhu+8YTvH9t+PWlU3RrC40WvYUylz1NZCVCaxYQSa08edFaVVdTH+X2pOluqhrvhUebQGdVdUkQMIhZi6kt16WqLif0to+KUkYi64rp9UcMfa5A+P9EoFoFaIQOM+7TKcg1Ks3JzElDnU2GT5mPKAaleLam6DwoZxGXJT6EFa/ncg0z9Ret5QPiRyIdPZMq0siZGxmIN3AMLHdaQAVQXYL/dS6sph7uNpwFH9IUfTIfdSTtolKfGFA0e8znzuTUlNuYKrwIICNjve7O3FJvkyTPjxVJlluCoyoPpnl/TZT+U6S+NUJe/vNKQFddWn38A0H0g+o5Uq/88BdKQENMOISfSjdgOiIB+D135261KEpijz4BojsdzjaZ5urvxTdk25AVGrZtJUNS4GnxUcEC6XOaVpmp6m1Hj3KswdFOWStbFb0fCr3ZVJ7JgWYblG/h9TAw0iVNah6B8PHk3QN862XzaJSlX13wtt6u6ihpsnwjjHtfGRsjygueenxJGKqnZmPDIpeJMpow3vr59g/EpYDy/9yOudMehGnPocB80OKsJ0vcn50z68EUxNyNc2bsdreu2TJLHHZWYdjttk9Yq3YY+XD1b94sRp9iYCMcwAAAABJRU5ErkJggg==');

        const FAN_NAME = ['无',
            '大四喜', '大三元', '绿一色', '九莲宝灯', '四杠', '连七对', '十三幺',
            '清幺九', '小四喜', '小三元', '字一色', '四暗刻', '一色双龙会',
            '一色四同顺', '一色四节高',
            '一色四步高', '三杠', '混幺九',
            '七对', '七星不靠', '全双刻', '清一色', '一色三同顺', '一色三节高', '全大', '全中', '全小',
            '清龙', '三色双龙会', '一色三步高', '全带五', '三同刻', '三暗刻',
            '全不靠', '组合龙', '大于五', '小于五', '三风刻',
            '花龙', '推不倒', '三色三同顺', '三色三节高', '无番和', '妙手回春', '海底捞月', '杠上开花', '抢杠和',
            '碰碰和', '混一色', '三色三步高', '五门齐', '全求人', '双暗杠', '双箭刻',
            '全带幺', '不求人', '双明杠', '和绝张',
            '箭刻', '圈风刻', '门风刻', '门前清', '平和', '四归一', '双同刻', '双暗刻', '暗杠', '断幺',
            '一般高', '喜相逢', '连六', '老少副', '幺九刻', '明杠', '缺一门', '无字', '边张', '嵌张', '单钓将', '自摸',
            '花牌'
            , '明暗杠'
        ];

        /**
         * 结算界面中的每一项番
         * @param {number} f 番种索引
         * @param {number} v 番值
         */
        function fan_item(f, v) {
            let c = ((v >> 8) & 0xFF) + 1;
            return `${FAN_NAME[f]} ${c==1?`${v&0xFF}番`:`${v&0xFF}番\x20\u00D7\x20${c}`}`;
        }

        /**
         * 结算界面
         * @typedef {object} SettleView
         */
        class SettleView extends PIXI.Container {
            // ht = {"s":[22,22,22,23,35,35,35,38,39,40,52,53,54]}
            // wt = 21
            // ft = {"50":6,"62":2,"68":2}
            // dt = {"r":0,"f":10,"p":0x0103,"t":[34,-8,-8,-18],"s":[34,-8,-8,-18],"n":[0,0,0,0]}
            // ns = ['东','南','西','北']
            // vs = 1
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             * @param {object} ht 手牌
             * @param {number} wt 和牌
             * @param {object} ft 番表
             * @param {object} dt 详情
             * @param {array} ns 玩家名字
             * @param {number} vs 视角
             * @param {number} cd 倒时计
             * @param {function():void} cb 关闭回调
             */
            constructor(w, h, ht, wt, ft, dt, ns, vs, cd, cb) {
                super();

                const w0 = 700, h0 = 640, gap = 20;

                //this.height = h0;
                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();

                let bg = new PIXI.Graphics();
                this.addChild(bg);
                bg.interactive = true;

                ctn.interactive = true;
                ctn.on('pointerdown', ()=>bg.visible = false);
                ctn.on('pointerup', ()=>bg.visible = true);
                ctn.on('pointerupoutside', ()=>bg.visible = true);

                let t = new WinHand(ht, wt, ft != undefined ? ft['81'] : 0);
                bg.addChild(t);
                t.y = gap;
                if (t.width > w0 - gap * 2) {
                    t.scale.set((w0 - gap * 2) / t.width);
                    t.x = gap;
                }
                else {
                    t.x = (w0 - t.width) * .5;
                }

                let p = dt['p'], cl = -1, wn = -1;
                if (p == undefined) {
                    p = -1;
                }
                if (p >= 0) {
                    cl = lo_byte(p);
                    wn = hi_byte(p);
                }

                let y = 125;
                {
                    let tx = '';
                    let f = dt['f'];
                    if (p < 0) {
                        tx = '荒庄';
                    }
                    else {
                        tx = `「${ns[wn]}」${cl!=wn?`和牌 「${ns[cl]}」点炮`:'自摸'}  ${f}番`;
                    }
                    let t = new PIXI.Text(tx, {
                        fontFamily: FF,
                        fontSize: 26,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    bg.addChild(t);
                    t.anchor.x = .5;
                    t.x = w0 * .5;
                    t.y = y;
                    scaleText(t, w0 - gap * 2);

                    y += t.height + gap;
                }

                let i = 0;
                const frp = (w0 - gap * 2) / 3;
                for (let f in ft) {
                    let x0 = gap + 5 + (i % 3) * frp;
                    let y0 = y + 5 + 35 * Math.floor(i / 3);

                    let v = ft[f];
                    let t = new PIXI.Text(fan_item(f, v), {
                        fontFamily: FF,
                        fontSize: 22,
                        fill: '#99ffff'
                    });
                    bg.addChild(t);
                    t.anchor.y = .5;
                    t.x = x0;
                    //t.x = frp + gap; t.anchor.x = 1;
                    t.y = y0;

                    ++i;
                }


                const x1 = 200, /*y1 = 400,*/ w1 = 200, h1 = 100;
                let cx = [w0 * .5, w0 - gap - x1 * .5, w0 * .5, gap + x1 * .5];
                let cy = [h0 - gap - h1 * .5, h0 - h1 - gap * 2.5, h0 - h1 * 1.5 - gap * 4, h0 - h1 - gap * 2.5];

                {
                    let rd = dt['r'];
                    let t = new PIXI.extras.BitmapText(WIND[rd >> 2] + '风' + WIND[rd & 3], { font: '48px SourceHanSansBold' });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = w0 * .5;
                    t.y = cy[1];
                }

                let ts = dt['t'];
                let ss = dt['s'];
                let ps = dt['n'];
                for (let i = 0; i < 4; ++i) {
                    let ri = (i + vs) & 3;

                    let g = new PIXI.Graphics();
                    //g.lineStyle(2, 0x0000FF, 1);
                    g.beginFill(ri != wn ? (ri != cl ? 0xBBDED6 : 0x89A4C7) : 0xFFAAA5, .5);
                    g.drawRect(0, 0, w1, h1);
                    g.endFill();
                    bg.addChild(g);
                    g.x = cx[i] - w1 * .5;
                    g.y = cy[i] - h1 * .5;

                    let t = new PIXI.extras.BitmapText(WIND[ri], { font: '64px SourceHanSansBold'});
                    bg.addChild(t);
                    t.anchor.y = .5;
                    t.x = cx[i] - w1 * .5 + 10;
                    t.y = cy[i] + 15;

                    // t = new PIXI.Text(i, {
                    //     fontFamily: FF,
                    //     fontSize: 24,
                    //     fill: '#ffffff',
                    //     stroke: '#0066ff',
                    //     strokeThickness: 2,
                    // });
                    // this.addChild(t);
                    // t.anchor.set(.5);
                    // t.x = cx[i];
                    // t.y = cy[i];

                    t = new PIXI.Text(ns[ri], {
                        fontFamily: FF,
                        fontSize: 24,
                        fontWeight:'bold',
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = cx[i];
                    t.y = cy[i] - 30;
                    scaleText(t, w1 - 10);

                    let xx = cx[i] + 25;
                    if (ss == undefined) {
                        ss = [0,0,0,0];
                    }
                    let ss0 = ss[ri], ps0 = ps[ri];
                    t = new PIXI.Text(`本盘 ${plus_sign(ss0)}${ps0==0?'':plus_sign(ps0)}`, {
                        fontFamily: FF,
                        fontSize: 20,
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = xx;
                    t.y = cy[i] + 2;

                    let ts0 = ts[ri];
                    t = new PIXI.Text(`累计 ${plus_sign(ts0)}`, {
                        fontFamily: FF,
                        fontSize: 20,
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = xx;
                    t.y = cy[i] + 32;

                    if (ps0 < 0) {
                        t = new PIXI.Text('错和', {
                            fontFamily: FF,
                            fontSize: 16,
                            fill: '#ffffff',
                            stroke: '#0066ff',
                            strokeThickness: 2,
                        });
                        bg.addChild(t);
                        t.anchor.y = .5;
                        t.x = cx[i] - w1 * .5 + 10;
                        t.y = cy[i] + 35;
                    }
                }

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();

                const wb0 = 120, wh0 = 50;
                let btn = new TextButton('OK', {
                    fontFamily: FF,
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(); });
                bg.addChild(btn);
                btn.x = w0 - wb0 - gap;
                btn.y = h0 - wh0 - gap;

                t = new PIXI.Text(cd, {
                    fontFamily: FF,
                    fontSize: 18,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                t.anchor.set(1);
                t.x = wb0;
                t.y = wh0;
                btn.addChild(t);

                t.end_ = new Date().getTime() + cd * 1000;
                t.timer_ = setInterval(()=>{
                    let n = (t.end_ - new Date().getTime());
                    let s = Math.round(n / 1000);
                    if (s > 0) {
                        t.text = s;
                    }
                    else {
                        cb();
                        clearInterval(t.timer_);
                    }
                }, 100);

                bg.scale.set(1.25);
                bg.x = (w - w0 * 1.25) * .5;
                bg.y = (h - h0 * 1.25) * .5;
            }
        }

        /**
         * 错和界面
         * @typedef {object} FalseWinView
         */
        class FalseWinView extends PIXI.Container {
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             * @param {number} fn 番数
             * @param {object} ft 番表
             */
            constructor(w, h, fn, ft) {
                super();

                const w0 = 500, gap = 20;
                let y = 0;
                //this.width = w0;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();

                let bg = new PIXI.Graphics();
                this.addChild(bg);
                bg.interactive = true;

                ctn.interactive = true;
                ctn.on('pointerdown', ()=>bg.visible = false);
                ctn.on('pointerup', ()=>bg.visible = true);
                ctn.on('pointerupoutside', ()=>bg.visible = true);

                let t = new PIXI.Text(fn + '番错和', {
                    fontFamily: FF,
                    fontSize: 26,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.x = .5;
                t.x = w0 * .5;
                t.y = gap;

                let i = 0;
                const frp = (w0 - gap * 2) / 2;
                for (let f in ft) {
                    let x0 = gap + (i & 1) * frp;
                    let y0 = 70 + 35 * (i >> 1);

                    let v = ft[f];
                    let t = new PIXI.Text(fan_item(f, v), {
                        fontFamily: FF,
                        fontSize: 22,
                        fill: '#99ffff'
                    });
                    bg.addChild(t);
                    t.x = x0;
                    //t.x = frp + gap; t.anchor.x = 1;
                    t.y = y0;
                    y = y0;

                    ++i;
                }

                t = new PIXI.Text('你已错和，本盘失去和牌权', {
                    fontFamily: FF,
                    fontSize: 22,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.x = .5;
                t.x = w0 * .5;
                t.y = 220;
                scaleText(t, w0 - gap * 2);

                let h0 = Math.max(y + 110, 340);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();

                const wb0 = 120, wh0 = 50;
                let btn = new TextButton('OK', {
                    fontFamily: FF,
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ this.dstry(); });
                bg.addChild(btn);
                btn.x = w0 - wb0 - gap;
                btn.y = h0 - wh0 - gap;

                bg.scale.set(1.25);
                bg.x = (w - w0 * 1.25) * .5;
                bg.y = (h - h0 * 1.25) * .5;
            }
        }

        /**
         * 格式化时间
         * @param {Date} ud 时间
         * @returns {string}
         */
        function fmt_date(ud) {
            let y = ud.getFullYear(),
                m = ud.getMonth() + 1,
                d = ud.getDate(),
                h = ud.getHours(),
                mm = ud.getMinutes(),
                s = ud.getSeconds(),
                o = ud.getTimezoneOffset();
            let oa = Math.abs(o), oh = Math.floor(oa / 60), om = oa - oh * 60;
            return `${y}-${pad2(m)}-${pad2(d)} ${pad2(h)}:${pad2(mm)}:${pad2(s)}  UTC${o<=0?'+':'-'}${pad2(oh)}:${pad2(om)}`;
        }
        /**
         * 对局结果界面
         * @typedef {object} ResultView
         */
        class ResultView extends PIXI.Container {
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             * @param {string} ti 标题
             * @param {number} vs 视角
             * @param {array} pl 玩家
             * @param {Date} tm 时间戳（服务器）
             * @param {function():void} cb 关闭回调
             */
            constructor(w, h, ti, vs, pl, tm, cb) {
                super();

                const w0 = 600, h0 = 540, gap = 50;
                const oy = 110, gy = 60;

                //this.width = w0;
                //this.height = h0;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();

                let bg = new PIXI.Graphics();
                this.addChild(bg);
                //bg.interactive = true;

                bg.scale.set(1.25);
                bg.x = (w - w0 * 1.25) * .5;
                bg.y = (h - h0 * 1.25) * .5;

                //ctn.interactive = true;
                //ctn.on('pointerdown', ()=>bg.visible = false);
                //ctn.on('pointerup', ()=>bg.visible = true);
                //ctn.on('pointerupoutside', ()=>bg.visible = true);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();

                bg.lineStyle(2, 0x808080, 1);
                bg.moveTo(gap, oy);
                bg.lineTo(gap, oy + gy * 5);
                bg.lineTo(w0 - gap, oy + gy * 5);
                bg.lineTo(w0 - gap, oy);
                bg.lineTo(gap, oy);

                for (let i = 1; i < 5; ++i) {
                    bg.moveTo(gap, oy + gy * i);
                    bg.lineTo(w0 - gap, oy + gy * i);
                }

                bg.moveTo(gap + 80, oy);
                bg.lineTo(gap + 80, oy + gy * 5);

                bg.moveTo(w0 - gap - 120, oy);
                bg.lineTo(w0 - gap - 120, oy + gy * 5);

                let t = new PIXI.Text(ti + '\n对战结果', {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                    align: 'center'
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = 60;
                scaleText(t, w0 - 20);

                const pfx = ['名次', '昵称', '分数'];
                let xx = [gap + 40, w0 * .5 + 40 - 60, w0 - gap - 60];
                let yy = oy + gy * .5;
                for (let i = 0; i < 3; ++i) {
                    t = new PIXI.Text(pfx[i], {
                        fontFamily: FF,
                        fontSize: 24,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = xx[i];
                    t.y = yy;
                }

                for (let k = 0; k < 4; ++k) {
                    let yy = oy + gy * (k + 1.5);
                    let vl = [k + 1, pl[k]['n'], pl[k]['s']];
                    for (let i = 0; i < 3; ++i) {
                        t = new PIXI.Text(vl[i], {
                            fontFamily: FF,
                            fontSize: 24,
                            fontWeight: i != 1 ? 'bold' : '',
                            fill: (vs != pl[k]['w']) ? '#ffffff' : '#5cdbd3'
                        });
                        bg.addChild(t);
                        t.anchor.set(.5);
                        t.x = xx[i];
                        t.y = yy;
                        if (i == 1) scaleText(t, 280);
                    }
                }

                t = new PIXI.Text(fmt_date(new Date(tm)), {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = h0 - 105;

                const wb0 = 120, wh0 = 50;
                let btn = new TextButton('OK', {
                    fontFamily: FF,
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(); });
                bg.addChild(btn);
                btn.x = (w0 - wb0) * .5;
                btn.y = h0 - wh0 - 30;
            }
        }

        /**
         * 计分表界面
         * @typedef {object} HistoryView
         */
        class HistoryView extends PIXI.Container {
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             */
            constructor(w, h) {
                super();

                const w0 = 710, h0 = 920;
                // 40+70*9+40

                //this.width = w;
                //this.height = h;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();
                ctn.interactive = true;
                ctn.on('click', ()=>this.visible = false);

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();
                bg.x = (w - w0) * .5;
                bg.y = (h - h0) * .5;
                bg.interactive = true;

                let t = new PIXI.Text('计分表', {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = 35;

                bg.lineStyle(2, 0x808080, 1);
                bg.moveTo(40, 70);
                bg.lineTo(40, 830);
                bg.lineTo(w0 - 40, 830);
                bg.lineTo(w0 - 40, 70);
                bg.lineTo(40, 70);

                t = new PIXI.Text('昵称', {
                    fontFamily: FF,
                    fontSize: 20,
                    fontWeight: 'bold',
                    fill: '#DCDCDC',
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = 75;
                t.y = 90;

                let ntt = new Array(4), ttt = new Array(4);
                for (let i = 0; i < 4; ++i) {
                    t = ntt[i] = new PIXI.Text('', {
                        fontFamily: FF,
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#FFD700',
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = 180 + 140 * i;
                    t.y = 90;

                    t = ttt[i] = new PIXI.Text('', {
                        fontFamily: FF,
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#FFD700',
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = 180 + 140 * i;
                    t.y = 810;
                }
                this.ntt_ = ntt;
                this.ttt_ = ttt;

                t = new PIXI.Text('盘序', {
                    fontFamily: FF,
                    fontSize: 20,
                    fontWeight: 'bold',
                    fill: '#DCDCDC',
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = 75;
                t.y = 130;

                for (let i = 0; i < 8; ++i) {
                    t = new PIXI.Text(i & 1 ? '累计' : '本盘', {
                        fontFamily: FF,
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#DCDCDC',
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = 145 + i * 70;
                    t.y = 130;
                }

                bg.moveTo(40, 110);
                bg.lineTo(w0 - 40, 110);

                let rtt = new Array(16);
                for (let i = 0; i < 16; ++i) {
                    let yy = 170 + i * 40;
                    t = new PIXI.Text(WIND[i >> 2] + '风' + WIND[i & 3], {
                        fontFamily: FF,
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: '#DCDCDC',
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = 75;
                    t.y = yy;

                    rtt[i] = new Array(8);
                    for (let k = 0; k < 8; ++k) {
                        t = rtt[i][k] = new PIXI.Text('', {
                            fontFamily: FF,
                            fontSize: 20,
                            fontWeight: 'bold'
                        });
                        bg.addChild(t);
                        t.anchor.set(.5);
                        t.x = 145 + k * 70;
                        t.y = yy;
                    }

                    bg.moveTo(40, yy - 20);
                    bg.lineTo(w0 - 40, yy - 20);
                }
                this.rtt_ = rtt;

                t = new PIXI.Text('合计', {
                    fontFamily: FF,
                    fontSize: 20,
                    fontWeight: 'bold',
                    fill: '#DCDCDC',
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = 75;
                t.y = 810;

                bg.moveTo(40, 790);
                bg.lineTo(w0 - 40, 790);

                for (let i = 0; i < 4; ++i) {
                    let xx = 110 + 140 * i;
                    bg.moveTo(xx, 70);
                    bg.lineTo(xx, 830);
                    xx += 70;
                    bg.moveTo(xx, 110);
                    bg.lineTo(xx, 790);
                }

                const wb0 = 120, wh0 = 50;
                let btn = new TextButton('OK', {
                    fontFamily: FF,
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ this.visible = false; });
                bg.addChild(btn);
                btn.x = (w0 - wb0) * .5;
                btn.y = h0 - wh0 - 20;
            }

            /**
             * 显示
             * @param {Array} ns 名字
             * @param {Array} rss 得分
             * @param {Array} rps 罚分
             * @param {number} rd 盘序
             * @param {number} is 初始分
             * @param {number} nbp 负底分（底分的相反数）
             */
            show(ns, rss, rps, rd, is, nbp) {
                this.visible = true;

                let ntt = this.ntt_, ttt = this.ttt_, rtt = this.rtt_;

                let tl = [is, is, is, is];
                let rssi = [0, 0, 0, 0];
                let rspi = [0, 0, 0, 0];
                for (let i = 0; i < 16; ++i) {
                    if (i < rd) {
                        for (let n = 0; n < 4; ++n) {
                            rssi[n] = rss[n][i];
                            rspi[n] = rps[n][i];
                        }
                        let sd = rssi.every((rs)=>rs != nbp);
                        let tie = rssi.every((rs)=>rs == 0);
                        for (let k = 0; k < 8; ++k) {
                            let tx = '', cl = '#DCDCDC';
                            let rs = rssi[k >> 1], rp = rspi[k >> 1];
                            let rr = rs + rp;
                            if (k & 1) {
                                tl[k >> 1] += rr;
                                rr = tl[k >> 1];
                            }
                            else {
                                if (!tie) {
                                    cl = (rs < 0) ? ((rs == nbp || sd) ? '#00CD66' : '#00BFFF') : '#FF6A6A';
                                }
                            }
                            tx = rr;

                            let t = rtt[i][k];
                            t.text = tx;
                            t.style.fill = cl;
                            t.visible = true;
                        }
                    }
                    else {
                        for (let k = 0; k < 8; ++k) {
                            rtt[i][k].visible = false;
                        }
                    }
                }

                for (let i = 0; i < 4; ++i) {
                    let t = ntt[i];
                    t.text = ns[i];
                    scaleText(t, 130);

                    t = ttt[i];
                    t.text = tl[i];
                }
            }
        }

        /**
         * 追分策略界面
         * @typedef {object} ChaseView
         */
        class ChaseView extends PIXI.Container {
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             */
            constructor(w, h) {
                super();

                const w0 = 640, h0 = 680;
                // 40+120*2+80*4+40 40*10

                //this.width = w;
                //this.height = h;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();
                ctn.interactive = true;
                ctn.on('click', ()=>this.visible = false);

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();
                bg.x = (w - w0) * .5;
                bg.y = (h - h0) * .5;
                bg.interactive = true;

                let t = new PIXI.Text('追分策略', {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = 35;

                bg.lineStyle(2, 0x808080, 1);
                bg.moveTo(40, 70);
                bg.lineTo(40, 470);
                bg.lineTo(w0 - 40, 470);
                bg.lineTo(w0 - 40, 70);
                bg.lineTo(40, 70);

                const xps1 = [40, 40, 40, 40, 160, 40, 40, 160, 160];
                for (let i = 0; i < 9; ++i) {
                    let yy = 110 + 40 * i;
                    bg.moveTo(xps1[i], yy);
                    bg.lineTo(w0 - 40, yy);
                }

                const xps = [160, 280, 360, 440, 520];
                for (let i = 0; i < 5; ++i) {
                    let xx = xps[i];
                    bg.moveTo(xx, 70);
                    bg.lineTo(xx, 110);

                    bg.moveTo(xx, 150);
                    bg.lineTo(xx, 190);

                    bg.moveTo(xx, 230);
                    bg.lineTo(xx, 310);

                    bg.moveTo(xx, 350);
                    bg.lineTo(xx, 470);
                }

                const cls = ['#FFD700', '#FFD700', '#DCDCDC', '#FF6A6A', '#00BFFF', '#00CD66'];
                const tix = ['追者', '被追', '分差', '自摸', '对点', '旁点'];
                const xps2 = [100, 220, 320, 400, 480, 560];
                for (let i = 0; i < 6; ++i) {
                    t = new PIXI.Text(tix[i], {
                        fontFamily: FF,
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: cls[i]
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = xps2[i];
                    t.y = 90;
                }

                const yps1 = [170, 270, 410];
                const yps2 = [170, 250, 370];
                let texts = [[null, new Array(1)], [null, new Array(2)], [null, new Array(3)]];
                for (let i = 0; i < 3; ++i) {
                    t = new PIXI.Text('', {
                        fontFamily: FF,
                        fontSize: 20,
                        fontWeight: 'bold',
                        fill: cls[0],
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = xps2[0];
                    t.y = yps1[i];
                    texts[i][0] = t;

                    for (let k = 0; k <= i; ++k) {
                        texts[i][1][k] = new Array(5);
                        for (let l = 0; l < 5; ++l) {
                            t = new PIXI.Text('', {
                                fontFamily: FF,
                                fontSize: 20,
                                fontWeight: 'bold',
                                fill: cls[l + 1],
                            });
                            bg.addChild(t);
                            t.anchor.set(.5);
                            t.x = xps2[l + 1];
                            t.y = yps2[i] + 40 * k;
                            texts[i][1][k][l] = t;
                        }
                    }
                }
                this.texts_ = texts;

                t = new PIXI.Text('自摸：(分差-32) / 4\n对点：(分差-32) / 2\n旁点：(分差-32)', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                    lineHeight: 40
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = h0 - 130;

                const wb0 = 120, wh0 = 50;
                let btn = new TextButton('OK', {
                    fontFamily: FF,
                    fontSize: 36,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ this.visible = false; });
                bg.addChild(btn);
                btn.x = (w0 - wb0) * .5;
                btn.y = h0 - wh0 - 20;
            }

            /**
             * 显示
             * @param {array} pl 玩家
             * @param {array} ps 罚分
             */
            show(pl, ps) {
                this.visible = true;

                let pls = [
                    {'n':pl[0]['n'],'s':pl[0]['s'] + ps[0]},
                    {'n':pl[1]['n'],'s':pl[1]['s'] + ps[1]},
                    {'n':pl[2]['n'],'s':pl[2]['s'] + ps[2]},
                    {'n':pl[3]['n'],'s':pl[3]['s'] + ps[3]}
                ];
                pls.sort(function(a, b) { return b['s'] - a['s']; });

                let t;
                let texts = this.texts_;
                for (let i = 0; i < 3; ++i) {
                    t = texts[i][0];
                    t.text = pls[i + 1]['n'];
                    scaleText(t, 110);

                    for (let k = 0; k <= i; ++k) {
                        let dt = pls[i - k]['s'] - pls[i + 1]['s'];
                        let sd = 8, dd = 8, od = 8;
                        if (dt > 32) {
                            let oo = dt - 32;
                            sd = Math.max((oo >> 2) + 1, 8);
                            dd = Math.max((oo >> 1) + 1, 8);
                            od = Math.max(oo + 1, 8);
                        }

                        let ctt = [pls[i - k]['n'], dt, sd, dd, od];
                        for (let l = 0; l < 5; ++l) {
                            t = texts[i][1][k][l];
                            t.text = ctt[l];
                            if (l == 0) scaleText(t, 110);
                        }
                    }
                }
            }
        }

        /**
         * 鸣牌设置界面
         * @typedef {object} CallView
         */
        class CallView extends PIXI.Container {
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             * @param {function(array,boolean,boolean):void} callback 确定的回调
             */
            constructor(w, h, callback) {
                super();

                const w0 = (WIDTH_02 + 50) * 9 + 50, h0 = 860;

                //this.width = w;
                //this.height = h;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();
                ctn.interactive = true;
                ctn.on('click', ()=>this.visible = false);

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();
                bg.x = (w - w0) * .5;
                bg.y = (h - h0) * .5;
                bg.interactive = true;

                let t = new PIXI.Text('鸣牌设置', {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = 35;

                t = new PIXI.Text('不询问以下选中的牌：', {
                    fontFamily: FF,
                    fontSize: 28,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                    lineHeight: 40
                });
                bg.addChild(t);
                t.x = 20;
                t.y = 70;

                let tiles = new Array(34), cbs = new Array(34);
                for (let i = 0; i < 34; ++i) {
                    let x = 20 + (i % 9) * (WIDTH_02 + 50), y = 120 + Math.floor(i / 9) * (HEIGHT_02F + 30);

                    // 显示为立牌的形式
                    let t0 = new StandingTile(i << 2);
                    bg.addChild(t0);
                    t0.x = x + 50;
                    t0.y = y;

                    // 灰色前景，当不鸣该牌时显示
                    let tex = PoolTile.tex0.clone();
                    tex.frame = new PIXI.Rectangle(
                        (WIDTH_02 + 2) * 7 + 2, (HEIGHT_02F + 2) * 3 + 2,
                        WIDTH_02, HEIGHT_02F);
                    let t1 = new PIXI.Sprite(tex);
                    bg.addChild(t1);
                    t1.alpha = .5;
                    t1.x = x + 50;
                    t1.y = y;
                    t1.visible = false;
                    tiles[i] = t1;

                    let cb = new CheckBox('', (cb)=>{
                        if (!(t1.visible = cb.isSelected())) {
                            this.cba_[Math.floor(i / 9)].setSelected(false);
                        }
                    });
                    bg.addChild(cb);
                    cb.x = x;
                    cb.y = y;
                    cbs[i] = cb;

                    t0.interactive = true;
                    t0.callback_ = ()=>{
                        cb.setSelected(t1.visible = !cb.isSelected());
                    };
                }
                this.tiles_ = tiles;
                this.cbs_ = cbs;

                const ti = ['所有万子', '所有条子', '所有饼子', '所有字牌'];
                let cba = [null, null, null, null];
                for (let i = 0; i < 4; ++i) {
                    let cb = cba[i] = new CheckBox(ti[i], (cb)=>{
                        let s = cb.isSelected();
                        let tiles = this.tiles_;
                        let cbs = this.cbs_;
                        for (let n = i * 9; n < 34 && n < (i + 1) * 9; ++n) {
                            cbs[n].setSelected(tiles[n].visible = s);
                        }
                    });
                    bg.addChild(cb);
                    cb.x = w0 * .5 + 240 * (i & 1);
                    cb.y = h0 - 310 + 70 * (i >> 1);
                }
                this.cba_ = cba;

                let cb = this.ign_ = new CheckBox('自摸也不询问');
                bg.addChild(cb);
                cb.x = 20;
                cb.y = h0 - 310;

                cb = this.rw_ = new CheckBox('鼠标右键=弃');
                bg.addChild(cb);
                cb.x = 20;
                cb.y = h0 - 230;

                t = new PIXI.Text('注意：此处的设置优先。每盘开始前会重置。', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                    lineHeight: 40
                });
                bg.addChild(t);
                t.anchor.x = .5;
                t.x = w0 * .5;
                t.y = h0 - 160;

                const wb0 = 120, wh0 = 50;
                let btn = new TextButton('取消', {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ this.visible = false; });
                bg.addChild(btn);
                btn.x = w0 * .25 - wb0;
                btn.y = h0 - wh0 - 20;

                btn = new TextButton('确定', {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{
                    this.visible = false;
                    let cf = new Array(34);
                    for (let i = 0; i < 34; ++i) {
                        cf[i] = tiles[i].visible;
                    }
                    callback(cf, this.ign_.isSelected(), this.rw_.isSelected());
                });
                bg.addChild(btn);
                btn.x = w0 * .75;
                btn.y = h0 - wh0 - 20;
                this.reset_ = false;
            }

            /**
             * 显示
             * @param {array} cf 各牌张标记
             * @param {boolean} ign 自摸也不询问
             * @param {boolean} rw 右键=弃
             */
            show(cf, ign, rw) {
                this.visible = true;
                let tiles = this.tiles_;
                let cbs = this.cbs_;
                for (let i = 0; i < 34; ++i) {
                    cbs[i].setSelected(tiles[i].visible = cf[i]);
                }
                let cba = this.cba_;
                if (this.reset_) {
                    for (let i = 0; i < 4; ++i) {
                        cba[i].setSelected(false);
                    }
                    this.reset_ = false;
                }
                else {
                    cba[0].setSelected(cf[0]&&cf[1]&&cf[2]&&cf[3]&&cf[4]&&cf[5]&&cf[6]&&cf[7]&&cf[8]);
                    cba[1].setSelected(cf[9]&&cf[10]&&cf[11]&&cf[12]&&cf[13]&&cf[14]&&cf[15]&&cf[16]&&cf[17]);
                    cba[2].setSelected(cf[18]&&cf[19]&&cf[20]&&cf[21]&&cf[22]&&cf[23]&&cf[24]&&cf[25]&&cf[26]);
                    cba[3].setSelected(cf[27]&&cf[28]&&cf[29]&&cf[30]&&cf[31]&&cf[32]&&cf[33]);
                }
                this.ign_.setSelected(ign);
                this.rw_.setSelected(rw);
            }
        }

        /**
         * 滑动控制条
         * @typedef {object} RangeBar
         */
        class RangeBar extends PIXI.Container {
            /**
             * @param {number} w 总体宽度
             * @param {number} h0 滑块高度
             * @param {number} h1 滑条高度
             * @param {function(number):void} cb 回调
             */
            constructor(w, h0, h1, cb) {
                super();

                //this.width = w;
                //this.height = h0;

                this.min_ = h0 * .5 - 3;
                this.max_ = w - h0 * .5 + 3;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                //bg.lineStyle(2, 0xFFFFFF, 1);
                bg.beginFill(0xffffff, .5);
                bg.drawRect(0, (h0 - h1) * .5, w, h1);
                bg.endFill();

                let thmb = this.thmb_ = new PIXI.Sprite(RangeBar.cycleTex);
                this.addChild(thmb);
                thmb.scale.set(h0 / 64);
                thmb.anchor.set(.5);
                thmb.x = thmb.y = h0 * .5;

                this.dragging_ = false;
                thmb.interactive = true;
                thmb.on('pointerdown', ()=>{ this.dragging_ = true; });
                thmb.on('pointerup', ()=>{ this.dragging_ = false; });
                thmb.on('pointerupoutside', ()=>{ this.dragging_ = false; });
                thmb.on('pointermove', (e)=>{
                    if (!this.dragging_) return;
                    let pt = this.toLocal(e.data.global);
                    let v0 = this.min_, v1 = this.max_;
                    let vx = Math.max(v0, Math.min(v1, pt.x));
                    this.thmb_.x = vx;
                    this.value_ = (vx - v0) * 100 / (v1 - v0);
                    cb(this.value_);
                });
            }

            /**
             * 设置值
             * @param {number} v 值[0-100]
             */
            setValue(v) {
                this.value_ = v;
                this.thmb_.x = this.min_ + (this.max_ - this.min_) * v / 100;
            }

            /**
             * 获取值
             * @returns {number} [0-100]
             */
            getValue() {
                return this.value_;
            }
        }

        RangeBar.cycleTex = base64Tex('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAABr0lEQVR42u1bWZHEIBCNg5EwEiIhEiIhEiIhEiIhEpCwEiIhEuIgvVDVX6mtJQdHX6+KryEM7wFNNzRNYzAYcgMAOl9GX5bjOH7+K6EO1u04E/76MiGhV8A2ptAmB+J9CtIRMXp1xMkK4TvxwTVbC+G/PzVHfYPKwD70pcmPQA9jKfIL0MWSm/wE9DHlIj8AHwzJDR7wQ5+KfOvLzlCA0Oc2xT6/Al+sr/wEJkYvj1HEqS8F95dCSd++ROzwJH6Xhk7l6N+eBXiYIRVfLZb/+Y7AfN+P+gWap398GTD1+dPFCP7HWYEAs6rt79Z2KNwAxg0hKIEJYAKYACaACWB+gAmgLhSOh8QWDGkPh9EObILX/3blREhySDxruxA5o716MiwxLF6lX4c/t/52NSb/eqx7ekPsBJB3bxMkdsbkQ9/fJVIyXwppMs6BZmJkDGkTJ4F2guQZeRImmYiQPVt0IEx+aEqAqAhlyJ/cZQoxwwq1Hk+gn1DTWXJQ68HEH77CWnjU6b0qC3tvzhMlbHtsqANnhEvkRu/YFs93hChGOG53V2YH1nH4Dd/HkwYDD/wCGrE2KfciIV0AAAAASUVORK5CYII=');

        /**
         * 设置界面
         * @typedef {object} SettingView
         */
        class SettingView extends PIXI.Container {
            /**
             * @param {number} w 遮罩宽
             * @param {number} h 遮罩高
             * @param {function():void} cb 关闭回调
             */
            constructor(w, h, cb) {
                super();

                const w0 = 540, h0 = 500;

                //this.width = w;
                //this.height = h;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .1);
                ctn.drawRect(0, 0, w, h);
                ctn.endFill();
                ctn.interactive = true;
                ctn.on('click', ()=>this.visible = false);

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x060F16, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();
                bg.x = (w - w0) * .5;
                bg.y = (h - h0) * .5;
                bg.interactive = true;

                let t = new PIXI.Text('设置', {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = 40;

                t = new PIXI.Text('音量', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.y = .5;
                t.x = 30;
                t.y = 110;

                let t0 = new PIXI.Text('100%', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t0);
                t0.anchor.x = 1;
                t0.anchor.y = .5;
                t0.x = w0 - 30;
                t0.y = 110;

                let rb = new RangeBar(t0.x - t0.width - t.x - t.width - 15, 30, 15, (v)=>{
                    t0.text = Math.round(v) + '%';
                });
                bg.addChild(rb);
                rb.x = t.x + t.width + 10;
                rb.y = 95;
                let volume = localStorage.getItem('volume');
                volume = (volume != undefined) ? Math.max(0, Math.min(100, parseFloat(volume))) : 100;
                t0.text = Math.round(volume) + '%';
                rb.setValue(volume);

                t = new PIXI.Text('倒计时音效', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.y = .5;
                t.x = 30;
                t.y = 160;

                let cb1 = new CheckBox();
                bg.addChild(cb1);
                cb1.scale.set(.75);
                cb1.x = t.x + t.width + 40;
                cb1.y = t.y - 18;
                cb1.setSelected(!tz.mutecd);

                t = new PIXI.Text('鸣牌提示音效', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.y = .5;
                t.x = 30;
                t.y = 210;

                let cb2 = new CheckBox();
                bg.addChild(cb2);
                cb2.scale.set(.75);
                cb2.x = t.x + t.width + 40;
                cb2.y = t.y - 18;
                cb2.setSelected(!tz.mutecall);

                t = new PIXI.Text('牌面上角标（刷新后生效）', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.y = .5;
                t.x = 30;
                t.y = 260;

                let cb3 = new CheckBox();
                bg.addChild(cb3);
                cb3.scale.set(.75);
                cb3.x = t.x + t.width + 40;
                cb3.y = t.y - 18;
                cb3.setSelected(tz.nht);

                t = new PIXI.Text('钢琴键尺寸（刷新后生效）', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.y = .5;
                t.x = 30;
                t.y = 310;

                let ti = ['三格', '两格'];
                let piacbs = [];
                for (let i = 0; i < 2; ++i) {
                    let cbx = new CheckBox(ti[i], ()=>{
                        for (let n = 0; n < 2; ++n) {
                            piacbs[n].setSelected(n == i);
                        }
                    });
                    bg.addChild(cbx);
                    cbx.scale.set(.75);
                    cbx.x = t.x + t.width + 10 + 105 * i;
                    cbx.y = t.y - 18;
                    piacbs.push(cbx);
                }
                piacbs[0].setSelected(!tz.piat);
                piacbs[1].setSelected(tz.piat);

                const wb0 = 120, wh0 = 50;
                let btn = new TextButton('取消', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(); });
                bg.addChild(btn);
                btn.x = 20;
                btn.y = h0 - wh0 - 20;

                btn = new TextButton('确定', {
                    fontFamily: FF,
                    fontSize: 24,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{
                    let volume = rb.getValue();
                    tz.mutecd = cb1.isSelected() ? 0 : 1;
                    tz.mutecall = cb2.isSelected() ? 0 : 1;
                    localStorage.setItem('volume', volume);
                    localStorage.setItem('mutecd', tz.mutecd);
                    localStorage.setItem('mutecall', tz.mutecall);
                    localStorage.setItem('nht', cb3.isSelected() ? 1 : 0);
                    localStorage.setItem('piano', piacbs[0].isSelected() ? 0 : 1);
                    PIXI.sound.volumeAll = volume / 100;
                    cb();
                });
                bg.addChild(btn);
                btn.x = w0 - wb0 - 20;
                btn.y = h0 - wh0 - 20;
            }
        }

        /**
         * 钢琴键
         * @typedef {object} PianoKey
         */
        class PianoKey extends PIXI.Container {
            /**
             * @param {number} w 宽
             * @param {number} h 高
             * @param {function(PianoKey):void} cb 点击回调
             */
            constructor(w, h, cb) {
                super();

                //this.width = w;
                //this.height = h;

                let clk = ()=>{ cb(this); };
                let hlt = ()=>{ this.fg_.visible = true; };
                let nml = ()=>{ this.fg_.visible = false; };

                let bg = new PIXI.Graphics();
                bg.beginFill(0, .25);
                bg.drawRect(0, 0, w, h);
                bg.endFill();
                this.addChild(bg);

                let fg = this.fg_ = new PIXI.Graphics();
                fg.beginFill(0xFFFFFF, .25);
                fg.drawRect(0, 0, w, h);
                fg.endFill();
                this.addChild(fg);
                fg.visible = false;

                this.interactive = true;
                this.on('click', clk);
                this.on('mouseover', hlt);
                this.on('mouseout', nml);
                this.on('tap', clk);
                this.on('touchstart', hlt);
                this.on('touchendoutside', nml);
                this.on('touchend', nml);
            }
        }

        /**
         * 三格钢琴
         * @typedef {object} Piano3
         */
        class Piano3 extends PIXI.Container {
            /**
             * @param {number} w 总宽度
             * @param {array} st 手牌
             */
            constructor(w, st) {
                super();

                //this.width = w;
                //this.height = 400;

                let graph = new PIXI.Graphics();
                this.addChild(graph);
                graph.lineStyle(5, 0x808080, 1);
                graph.beginFill(0x0C1E2C, .85);
                graph.drawRect(0, 0, w, 240);
                graph.drawRect(0, 240, w, 160);
                graph.endFill();
                graph.moveTo(w * .5, 240);
                graph.lineTo(w * .5, 400);

                let btn = new TextButton('<', {
                    fontFamily: FF,
                    fontSize: 64,
                    fill: '#ffffff',
                    strokeThickness: 2,
                }, w * .5, 160, ()=>{ this.offset(-1); });
                btn.y = 240;
                this.addChild(btn);

                btn = new TextButton('>', {
                    fontFamily: FF,
                    fontSize: 64,
                    fill: '#ffffff',
                    strokeThickness: 2,
                }, w * .5, 160, ()=>{ this.offset(1); });
                btn.x = w * .5;
                btn.y = 240;
                this.addChild(btn);

                this.standing_ = st;
                this.btnctns_ = new Array(3);
                this.o_ = -1;
                this.hlt_ = -1;

                const TILE_WIDTH = WIDTH_02 * HAND_SCALE;
                const BTN_WIDTH = TILE_WIDTH * 3;
                let xx = st[0].x - BTN_WIDTH;
                let maxx = w - BTN_WIDTH;

                for (let k = 0; k < 3; ++k) {
                    let btnctn = this.btnctns_[k] = new PIXI.Container();
                    this.addChild(btnctn);

                    let graph = new PIXI.Graphics();
                    btnctn.addChild(graph);

                    let keys = [];
                    for (let i = 0; i < 7; ++i) {
                        let x = xx + BTN_WIDTH * i + k * TILE_WIDTH;
                        let w1 = BTN_WIDTH;
                        let xh = BTN_WIDTH * .5;
                        if (x < 0) {
                            w1 = BTN_WIDTH + x;
                            x = 0;
                            xh = w1 - BTN_WIDTH * .5;
                        }
                        else if (x > maxx) {
                            w1 = BTN_WIDTH - (x - maxx);
                            if (w1 < BTN_WIDTH * .5) {
                                xh = -1;
                            }
                        }
                        else if (x >= w) {
                            break;
                        }

                        let btn = new PianoKey(w, 240, (btn)=>{
                            let sta = this.standing_;
                            let sp = sta[btn.ri_];
                            if (sp && sp.visible) {
                                if (sp.isHighlight()) {
                                    sp.click();
                                    sp.setHighlight(false);
                                }
                                else {
                                    sp.setHighlight(true);
                                    for (let n = 0; n < 14; ++n) {
                                        let st = sta[n];
                                        st.setHighlight(st == sp);
                                    }
                                    let keys = btnctn.keys_;
                                    for (let n = 0, cnt = keys.length; n < cnt; ++n) {
                                        keys[n].fg_.visible = false;
                                    }

                                    btn.fg_.visible = true;
                                }
                            }
                        });
                        btn.x = x;
                        btnctn.addChild(btn);
                        keys.push(btn);
                        btn.ri_ = i * 3 + k - 2;

                        if (xh > 0) {
                            graph.lineStyle(5, 0xffffff, 1);
                            graph.moveTo(x + xh, 0);
                            graph.lineTo(x + xh, 120);

                            // 以下代码：箭头状
                            // graph.moveTo(x + xh + 15, 25);
                            // graph.lineTo(x + xh, 5);
                            // graph.moveTo(x + xh - 15, 25);
                            // graph.lineTo(x + xh, 5);
                        }
                        graph.lineStyle(5, 0x808080, 1);
                        graph.drawRect(x, 0, w1, 240);
                    }
                    btnctn.visible = (k == 0);
                    btnctn.keys_ = keys;
                }
            }

            /**
             * 移动
             * @param {number} o 方向+右，-左
             */
            offset(o) {
                let sta = this.standing_;

                // 找到高亮的牌
                let hlt = -1;
                for (let i = 0; i < 14; ++i) {
                    let sp = sta[i];
                    if (sp && sp.visible && sp.isHighlight()) {
                        hlt = i;
                        break;
                    }
                }

                if (hlt != -1) {
                    // 高亮的牌对应的钢琴
                    let btnctn = this.btnctns_[(hlt + 2) % 3];
                    if (btnctn.visible) {
                        sta[hlt].setHighlight(false);

                        let sp = sta[hlt + o];
                        if (sp && sp.visible) {
                            sp.setHighlight(true);
                        }
                    }
                }

                o = this.o_ + o;
                if (o > 1) o = -1;
                if (o < -1) o = 1;
                this.o_ = o;

                for (let k = 0; k < 3; ++k) {
                    let btnctn = this.btnctns_[k];
                    if (k != (o + 1)) {
                        btnctn.visible = false;
                    }
                    else {
                        btnctn.visible = true;
                        let keys = btnctn.keys_;
                        for (let i = 0, cnt = keys.length; i < cnt; ++i) {
                            let ri = i * 3 + k - 2;
                            let sp = sta[ri];
                            keys[i].fg_.visible = (sp && sp.visible && sp.isHighlight());
                        }
                    }
                }
            }

            /**
             * 刷新
             */
            refresh() {
                for (let k = 0; k < 3; ++k) {
                    let btnctn = this.btnctns_[k];
                    if (btnctn.visible) {
                        let keys = btnctn.keys_;
                        let sta = this.standing_;
                        for (let i = 0, cnt = keys.length; i < cnt; ++i) {
                            let ri = i * 3 + k - 2;
                            let sp = sta[ri];
                            keys[i].fg_.visible = (sp && sp.visible && sp.isHighlight());
                        }
                    }
                }
            }
        }

        /**
         * 二格钢琴
         * @typedef {object} Piano2
         */
        class Piano2 extends PIXI.Container {
            /**
             * @param {number} w 总宽度
             * @param {array} st 手牌
             */
            constructor(w, st) {
                super();

                //this.width = w;
                //this.height = 340;

                let graph = new PIXI.Graphics();
                graph.lineStyle(5, 0x808080, 1);
                graph.beginFill(0x0C1E2C, .85);
                graph.drawRect(0, 0, w, 340);
                graph.endFill();

                this.standing_ = st;
                this.keys_ = new Array(14);
                this.o_ = -1;
                this.hlt_ = -1;

                const TILE_WIDTH = WIDTH_02 * HAND_SCALE;
                const BTN_WIDTH = TILE_WIDTH * 2;
                let cb = (btn)=>{
                    let sta = this.standing_;
                    let sp = sta[btn.ri_];
                    if (sp && sp.visible) {
                        if (sp.isHighlight()) {
                            sp.click();
                            sp.setHighlight(false);
                        }
                        else {
                            sp.setHighlight(true);
                            for (let n = 0; n < 14; ++n) {
                                let st = sta[n];
                                st.setHighlight(st == sp);
                            }
                            let keys = this.keys_;
                            for (let n = 0; n < 14; ++n) {
                                keys[n].fg_.visible = false;
                            }

                            btn.fg_.visible = true;
                        }
                    }
                };

                for (let i = 0; i < 7; ++i) {
                    let x = BTN_WIDTH * i;
                    let btn = new PianoKey(BTN_WIDTH, 170, cb);
                    btn.x = x;
                    this.addChild(btn);
                    btn.ri_ = i * 2;
                    this.keys_[i * 2] = btn;

                    graph.lineStyle(5, 0xffffff, 1);
                    graph.beginFill(0xffffff, 1);
                    graph.drawRect(x, 0, TILE_WIDTH, 20);
                    graph.endFill();

                    graph.lineStyle(5, 0x808080, 1);
                    graph.drawRect(x, 0, BTN_WIDTH, 170);
                }

                for (let i = 0; i < 6; ++i) {
                    let x = TILE_WIDTH + BTN_WIDTH * i;
                    let btn = new PianoKey(BTN_WIDTH, 170, cb);
                    btn.x = x;
                    btn.y = 170;
                    this.addChild(btn);
                    btn.ri_ = i * 2 + 1;
                    this.keys_[i * 2 + 1] = btn;

                    graph.lineStyle(5, 0xffffff, 1);
                    graph.beginFill(0xffffff, 1);
                    graph.drawRect(x, 170, TILE_WIDTH, 20);
                    graph.endFill();

                    graph.lineStyle(5, 0x808080, 1);
                    graph.drawRect(x, 170, BTN_WIDTH, 170);
                }

                {
                    let x = TILE_WIDTH + BTN_WIDTH * 6;
                    let w1 = w - BTN_WIDTH;
                    let btn = new PianoKey(w1, 170, cb);
                    btn.x = x;
                    btn.y = 170;
                    this.addChild(btn);
                    btn.ri_ = 13;
                    this.keys_[13] = btn;

                    graph.lineStyle(5, 0xffffff, 1);
                    graph.beginFill(0xffffff, 1);
                    graph.drawRect(x, 170, TILE_WIDTH, 20);
                    graph.endFill();

                    graph.lineStyle(5, 0x808080, 1);
                    graph.drawRect(x, 170, w1, 170);
                }

                this.addChild(graph);
            }

            /**
             * 刷新
             */
            refresh() {
                let keys = this.keys_;
                let sta = this.standing_;
                for (let i = 0, cnt = keys.length; i < cnt; ++i) {
                    let sp = sta[i];
                    keys[i].fg_.visible = (sp && sp.visible && sp.isHighlight());
                }
            }
        }

        /**
         * 缩小文本以适配宽度
         * @param {object} t 文本
         * @param {number} w 宽度
         */
        function scaleText(t, w) {
            let w0 = t.width / t.scale.x;
            if (w0 > w) {
                t.scale.set(w / w0);
            }
            else {
                t.scale.set(1);
            }
        }

        const LOBBY_WIDTH = 680, LOBBY_HEIGHT = 700;

        /**
         * 字符数（那种中文=2英文=1的计算方式）
         * @param {string} s 字符串
         */
        function bytes_len(s) {
            let r = 0;
            for (let i = 0, len = s.length; i < len; ++i) {
                let c = s.charCodeAt(i);
                if (c >= 0 && c < 256) ++r;
                else r += 2;
            }
            return r;
        }

        /**
         * 大厅
         * @typedef {object} LobbyView
         */
        class LobbyView extends PIXI.Container {
            constructor() {
                super();

                let ctn = this.container_ = new PIXI.Container();
                //ctn.width = LOBBY_WIDTH;
                //ctn.height = LOBBY_HEIGHT;
                this.addChild(ctn);

                {
                let graph = new PIXI.Graphics();
                graph.beginFill(0x89A4C7, .5);
                graph.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                graph.endFill();
                ctn.addChild(graph);
                }

                //let resp = {"m":1,"r":2,"t":{"i":10001,"t":1548852882425,"r":0,"u":false,"p":["游客10002","","",""],"g":{"t":"45679","n":16,"d":false,"i":0,"l":8,"r12":3,"r30":10,"dt":255,"d12":false,"fa":true,"fc":false,"s":true,"o":false,"a":false,"r":true}}};
                //ctn.addChild(new TableInfoView(resp['t']));

                const wb0 = 100, wh0 = 40;
                let btn = this.nameBtn_ = new TextButton('', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ tz.ws.send('{"m":1,"r":10}'); });
                ctn.addChild(btn);
                btn.x = LOBBY_WIDTH - wb0;

                btn = new TextButton('测速', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 70, wh0, ()=>{
                    tz.ws.send(`{"m":5,"t":${new Date().getTime()}}`);
                    this.sp_.ac_ = setTimeout(()=>{
                        this.sp_.text = '-';
                    }, 60000);
                });
                ctn.addChild(btn);
                btn.x = LOBBY_WIDTH - wb0 - 75;

                btn = new TextButton('主页', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 70, wh0, ()=>{ window.open('/', '_blank'); });
                ctn.addChild(btn);

                btn = new TextButton('EN', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 70, wh0, ()=>{ window.open('/1/?lang=en', '_self'); });
                ctn.addChild(btn);
                btn.x = 75;

                let t = this.sp_ = new PIXI.Text('-', {
                    fontFamily: FF,
                    fontSize: 16,
                    fill: '#ffffff',
                });
                ctn.addChild(t);
                t.anchor.x = 1;
                t.anchor.y = .5;
                t.x = LOBBY_WIDTH - wb0 - 80;
                t.y = 20;

                const title = ['空闲：', '等待：', '对局：', '托管：'];
                let status = [null, null, null, null];
                for (let i = 0; i < 4; ++i) {
                    let t0 = new PIXI.Text(title[i], {
                        fontFamily: FF,
                        fontSize: 16,
                        fill: '#ffffff',
                    });
                    ctn.addChild(t0);
                    t0.anchor.y = .5;
                    t0.x = 185 + (i & 1) * 140;
                    t0.y = 12 + (i >> 1) * 20;

                    let t1 = status[i] = new PIXI.Text('0', {
                        fontFamily: FF,
                        fontSize: 16,
                        fill: '#cccccc',
                    });
                    ctn.addChild(t1);
                    t1.anchor.y = .5;
                    t1.x = t0.x + t0.width;
                    t1.y = t0.y;
                }
                this.status_ = status;

                t = new PIXI.Text('文明游戏 禁止赌博', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                });
                ctn.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = LOBBY_HEIGHT - wh0 - 75;

                btn = new TextButton('创建牌桌', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ this._showCreateView(); });
                ctn.addChild(btn);
                btn.x = (LOBBY_WIDTH - wb0) * .5;
                btn.y = LOBBY_HEIGHT - wh0 - 10;

                btn = this.prevBtn_ = new TextButton('上一页', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ this._prevPage(); });
                ctn.addChild(btn);
                btn.x = LOBBY_WIDTH * .25 - wb0 * .5;
                btn.y = LOBBY_HEIGHT - wh0 - 60;

                btn = this.nextBtn_ = new TextButton('下一页', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ this._nextPage(); });
                ctn.addChild(btn);
                btn.x = LOBBY_WIDTH * .75 - wb0 * .5;
                btn.y = LOBBY_HEIGHT - wh0 - 60;

                this.tables_ = [];
                this.page_ = 0;

                t = this.pageText_ = new PIXI.Text('1/1', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                ctn.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = LOBBY_HEIGHT - wh0 - 40;

                this._enable(this.prevBtn_, false);
                this._enable(this.nextBtn_, false);

                let root = this.root_ = new PIXI.Container();
                ctn.addChild(root);
            }

            /**
             * 测速
             * @param {object} resp 服务器传回的json
             */
            speedTest(resp) {
                this.sp_.text = `${new Date().getTime() - resp['t']}ms`;
                clearTimeout(this.sp_.ac_);
            }

            onmessage(resp) {
                let r = resp['r'];
                let topmost = tz.topmost;
                switch (r) {
                case 1:
                    switch (resp['e']) {
                    default: topmost.error('未知错误'); break;
                    case 0: topmost.error('未知错误0'); break;
                    case 1: topmost.error('你已经在桌子上'); break;
                    case 2: topmost.error('你已经在对局中'); break;
                    case 3: topmost.error('桌子不存在'); break;
                    case 4: topmost.error('不正确的位置'); break;
                    case 5: topmost.error('这个位置已经有人了'); break;
                    case 6: topmost.error('密码错误'); break;
                    case 7: topmost.error('你不在桌子上'); break;
                    case 8: topmost.error('你已在别处登录', true); break;
                    case 9: topmost.error('用户名或密码过长'); break;
                    case 10: topmost.error('该桌不允许游客账号加入'); break;
                    case 11: topmost.error('不允许使用特殊字符'); break;
                    case 12: topmost.error('次要时限不能超过首要时限');break;
                    case 13: topmost.error('账号和密码不匹配'); break;
                    case 14: topmost.error('验证码已过期'); break;
                    case 15: topmost.error('验证码错误'); break;
                    case 17: topmost.error('不支持该配置'); break;
                    case 18: topmost.error('该桌IP限制'); break;
                    case 19: topmost.error('账号未激活'); break;
                    case 16: {
                        document.cookie = '__p=;Path=/;Max-Age=0';
                        let un, pw;
                        if (this.tlr_ && (un = localStorage.getItem('username')) && (pw = localStorage.getItem('password'))) {
                            this.tlr_ = false;
                            tz.ws.send(`{"m":1,"r":12,"u":"${un}","p":"${pw}"}`);
                        }
                        else {
                            topmost.error('自动登录失败，请输入账号密码登录');
                        }
                        break;
                    }
                    }
                    break;
                case 2: {
                    let t = this.nameBtn_.face_;
                    t.text = resp['n'] || '';
                    scaleText(t, 95);

                    let tv;
                    while (tv = this.tables_.pop()) {
                        tv.dstry();
                    }
                    // 无需break，接着走case 3一样的逻辑
                }
                case 3: {
                    let ts = resp['t'];
                    for (let i = 0, len = ts.length; i < len; ++i) {
                        let t = ts[i];
                        let tv = new TableInfoView(t, (id, s, p)=>{ this._callback(id, s, p); });
                        tv.x = 10;
                        this.root_.addChild(tv);
                        this.tables_.push(tv);

                        tv.refresh(this.tableid_, this.seat_);
                    }
                    this._refresh();
                    this._refreshStatus(resp['s']);
                    break;
                }
                case 4:
                    this._sitDown(resp['t']);
                    this._standUp(resp['f']);
                    this._refreshStatus(resp['s']);
                    break;
                case 5:
                    this._standUp(resp['t']);
                    this._refreshStatus(resp['s']);
                    break;
                case 6:
                    this._ready(resp['t']);
                    break;
                case 7:
                    this._delete(resp['t']);
                    this._refreshStatus(resp['s']);
                    break;
                case 8: {
                    let t = resp['t'];
                    if (t) {
                        this.tableid_ = t['i'];
                        this.seat_ = t['s'];
                    }
                    this._refreshStatus(resp['s']);
                    break;
                }
                case 9: {
                    let t = this.nameBtn_.face_;
                    t.text = resp['u'];
                    scaleText(t, 95);
                    let k = resp['t'];
                    if (k) {
                        let exp = new Date();
                        exp.setTime(exp.getTime() + 864000);
                        document.cookie=`__p=${k};Path=/;Expires=${exp.toGMTString()}`;
                    }
                    let pw = resp['p'];
                    if (pw) {
                        localStorage.setItem('password', pw);
                    }
                    if (this.tableid_ = resp['i']) {
                        this.seat_ = resp['s'];
                        let i = this._findTable(this.tableid_);
                        if (i != -1) {
                            this.tables_[i].refresh(this.tableid_, this.seat_);
                        }
                    }
                    break;
                }
                case 10:
                    this._showUserView(resp['z']);
                    break;
                case 13:
                    this._progress(resp);
                    break;
                default:
                    break;
                }
            }

            adapt() {
                let sx = window.innerWidth / LOBBY_WIDTH;
                let sy = window.innerHeight / LOBBY_HEIGHT;
                let ss = Math.min(sx, sy);

                this.container_.scale.set(ss);
                let cw = LOBBY_WIDTH * ss;
                if (window.innerWidth > cw) {
                    this.container_.x = (window.innerWidth - cw) * .5;
                } else {
                    this.container_.x = 0;
                }
            }

            /**
             * 显示登录界面
             * @param {string} pzl 验证码
             */
            _showUserView(pzl) {
                if (this.uv_) {
                    return;
                }

                let uv = this.uv_ = new UserView(pzl, (un, pw, sln)=>{
                    console.log('un pw', un, pw);
                    if (un && pw) {
                        tz.ws.send(`{"m":1,"r":9,"u":"${un}","p":"${pw}","z":"${pzl}","s":"${sln}"}`);
                        localStorage.setItem('username', un);
                    }
                    this.uv_.dstry();
                    delete this.uv_;
                });
                this.container_.addChild(uv);
                uv.x = (LOBBY_WIDTH - uv.width) * .5;
                uv.y = (LOBBY_HEIGHT - uv.height) * .5;
            }

            /**
             * 显示创建桌子界面
             */
            _showCreateView() {
                if (this.ctv_) {
                    return;
                }

                let ctv = this.ctv_ = new CreateTableView((cfg)=>{
                    //console.log('cfg', cfg);
                    if (cfg) {
                        let bl = bytes_len(cfg['t']);
                        let topmost = tz.topmost;
                        if (bl == 0) {
                            topmost.error('对局名称不能为空');
                            return;
                        }
                        if (bl > 40) {
                            topmost.error('对局名称最多40个字符');
                            return;
                        }
                        let p = cfg['p'];
                        if (p.length > 0 && !p.match('[0-9a-zA-Z]')) {
                            topmost.error('密码只允许数字和字母');
                            return;
                        }
                        if (p.length > 6) {
                            topmost.error('密码最长6位');
                            return;
                        }
                        tz.ws.send(JSON.stringify({'m':1,'r':3,'g':cfg}));
                    }

                    this.ctv_.dstry();
                    delete this.ctv_;
                });
                this.container_.addChild(ctv);
            }

            /**
             * 加入桌子回调
             * @param {number} id 桌ID
             * @param {number} s 座位
             * @param {string} p 密码
             */
            _callback(id, s, p) {
                //console.log(`{"m":1,"r":4,"v":${id},"s":${s}}`);
                if (s != this.seat_) {
                    if (!p || this.tableid_ == id) {
                        tz.ws.send(`{"m":1,"r":4,"v":${id},"s":${s}}`);
                    }
                    else {
                        if (this.pv_) {
                            return;
                        }
                        let pv = this.pv_ = new PasswordView((p)=>{
                            if (p) {
                                tz.ws.send(`{"m":1,"r":4,"v":${id},"s":${s},"p":"${p}"}`);
                            }
                            this.pv_.dstry();
                            delete this.pv_;
                        });
                        this.container_.addChild(pv);
                    }
                }
                else {
                    tz.ws.send('{"m":1,"r":5}');
                }
            }

            /**
             * 搜索桌子
             * @param {number} i 桌ID
             */
            _findTable(i) {
                let tbs = this.tables_;
                for (let k = 0, len = tbs.length; k < len; ++k) {
                    if (tbs[k].tableid_ == i) {
                        return k;
                    }
                }
                return -1;
            }

            /**
             * 坐下
             * @param {object} t 包含桌ID、座位、名字的json
             */
            _sitDown(t) {
                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tv = this.tables_[i];
                    tv.sitDown(t['s'], t['n']);
                    tv.refresh(this.tableid_, this.seat_);
                }
            }

            /**
             * 站起
             * @param {object} t 包含桌ID、座位的json
             */
            _standUp(t) {
                if (t == undefined) return;

                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tv = this.tables_[i];
                    tv.standUp(t['s']);
                    tv.refresh(this.tableid_, this.seat_);
                }
            }

            /**
             * 准备
             * @param {object} t 包含桌ID、座位、准备状态的json
             */
            _ready(t) {
                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tv = this.tables_[i];
                    tv.ready(t['s'], !!t['r'], this.tableid_);
                }
            }

            /**
             * 进度
             * @param {object} t 包含桌ID、进度、总盘数的json
             */
            _progress(t) {
                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tv = this.tables_[i];
                    tv.progress(t['p'], t['t']);
                }
            }

            /**
             * 删除桌子
             * @param {object} t 包含桌ID的json
             */
            _delete(t) {
                let i = this._findTable(t['i']);
                if (i != -1) {
                    let tbs = this.tables_;
                    let tv = tbs[i];
                    tbs.splice(i, 1);
                    tv.dstry();
                    this._refresh();
                }
            }

            /**
             * 启用/禁用上下一页按钮
             * @param {object} btn 上下一页
             * @param {boolean} e  启用true；禁用false
             */
            _enable(btn, e) {
                let style = btn.face_.style;
                if (e) {
                    style.fill = '#ffffff';
                    style.stroke = '#0066ff';
                    btn.interactive = true;
                }
                else {
                    style.fill = '#cccccc';
                    style.stroke = '#000000';
                    btn.interactive = false;
                    btn.fg_.visible = false;
                }
            }

            /**
             * 刷新
             */
            _refresh() {
                let tbs = this.tables_;
                let maxPage = Math.ceil(tbs.length / 4);
                if (maxPage == 0) {
                    maxPage = 1;
                }

                let page = this.page_;
                if (page >= maxPage) {
                    page = maxPage - 1;
                    this.page_ = page;
                }

                let s = page * 4, e = s + 4;
                tbs.sort((a, b)=>{ return b.time_ - a.time_; });

                for (let k = 0, len = tbs.length; k < len; ++k) {
                    let tv = tbs[k];
                    if (k < s || k >= e) {
                        tv.visible = false;
                    }
                    else {
                        tv.visible = true;
                        tv.y = 50 + (tv.height + 10) * (k - s);
                    }
                }

                this._enable(this.prevBtn_, page > 0);
                this._enable(this.nextBtn_, (page + 1) < maxPage);
                this.pageText_.text = (page + 1) + '/' + maxPage;
            }

            /**
             * 上一页
             */
            _prevPage() {
                if (this.page_ == 0) {
                    return;
                }
                --this.page_;
                this._refresh();
            }

            /**
             * 下一页
             */
            _nextPage() {
                if (this.page_ >= Math.ceil(this.tables_.length / 4)) {
                    return;
                }
                ++this.page_;
                this._refresh();
            }

            /**
             * 刷新大厅状态
             * @param {object} s 包含空闲、等待、对局、托管四种状态人数的json
             */
            _refreshStatus(s) {
                if (s) {
                    this.status_[0].text = s['f'];
                    this.status_[1].text = s['w'];
                    this.status_[2].text = s['p'];
                    this.status_[3].text = s['o'];
                }
            }
        }

        /**
         * 创建桌子界面
         * @typedef {object} CreateTableView
         */
        class CreateTableView extends PIXI.Container {
            /**
             * @param {function(object):void} cb 回调
             */
            constructor(cb) {
                super();

                const gap = 30, offsetY = 80;

                //this.width = LOBBY_WIDTH;
                //this.height = LOBBY_HEIGHT;
                this.interactive = true;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.beginFill(0, .5);
                bg.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                bg.endFill();

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x0C1E2C, .85);
                bg.drawRect(5, 5, LOBBY_WIDTH - 10, LOBBY_HEIGHT - 10);
                bg.endFill();

                let t = new PIXI.Text('创建牌桌', {
                    fontFamily: FF,
                    fontSize: 28,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                this.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = 35;

                const title = [
                    '对局名称',
                    '类型',
                    '起和番',
                    '底分',
                    '首要时限',
                    '次要时限',
                    '战术鸣牌',
                    '一盘结束后显示手牌',
                    '错和处罚策略',
                    '错和后允许鸣牌',
                    '对局初始分',
                    '随机分配初始座位',
                    '对外隐藏玩家昵称',
                    '允许游客加入',
                    '密码（可选）'];
                const option = [
                    undefined,
                    ['全庄', '半庄', '东风'],
                    ['1番', '8番', '16番', '24番', '32番'],
                    ['0', '8'],
                    ['5秒', '8秒', '10秒', '15秒'],
                    ['3秒', '5秒', '8秒', '10秒'],
                    ['有', '无'],
                    ['是', '否'],
                    ['-30/+10', '-40/+0'],
                    ['是', '否'],
                    ['0', '500'],
                    ['是', '否'],
                    ['是', '否'],
                    ['是', '否'],
                    undefined
                ];

                let ctrls = new Array(15);
                for (let i = 0; i < 15; ++i) {
                    let yy = offsetY + 35 * i;
                    t = new PIXI.Text(title[i], {
                        fontFamily: FF,
                        fontSize: 18,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    t.anchor.y = .5;
                    t.x = gap;
                    t.y = yy;
                    this.addChild(t);

                    let xx = Math.max(gap * 2 + t.width, 150);

                    let opt = option[i];
                    if (opt != undefined) {
                        let btns = [];
                        for (let k = 0, len = opt.length; k < len; ++k) {
                            let cb = new CheckBox(opt[k], ()=>{
                                for (let n = 0; n < len; ++n) {
                                    btns[n].setSelected(n == k);
                                }
                            });
                            this.addChild(cb);
                            cb.scale.set(.66);
                            cb.x = xx + (i != 8 ? 95 : 125) * k;
                            cb.y = yy - cb.height * .5;
                            btns.push(cb);
                        }
                        ctrls[i] = btns;
                    }
                    else {
                        let textInput = new PIXI.TextInput({
                            fontSize: '18px',
                            width: (LOBBY_WIDTH - xx - gap * 2) + 'px',
                            height: '18px',
                            padding: '6px',
                        });
                        textInput.x = xx;
                        textInput.y = yy - 15;
                        textInput.substituteText = false;
                        textInput.destroyBoxCache = ()=>{};
                        this.addChild(textInput);
                        ctrls[i] = textInput;
                    }
                }
                this.ctrls_ = ctrls;

                let defcfg = JSON.parse(localStorage.getItem('default_config')) || {};

                function dv(v, d) {
                    if (v != undefined) return v;
                    return d;
                }

                ctrls[0].text = dv(defcfg['t'], '');
                ctrls[1][dv(defcfg['n'], 0)].setSelected(true);
                ctrls[2][dv(defcfg['l'], 1)].setSelected(true);
                ctrls[3][dv(defcfg['b'], 1)].setSelected(true);
                ctrls[4][dv(defcfg['r30'], 2)].setSelected(true);
                ctrls[5][dv(defcfg['r12'], 1)].setSelected(true);
                ctrls[6][dv(defcfg['s'], 0)].setSelected(true);
                ctrls[7][dv(defcfg['o'], 1)].setSelected(true);
                ctrls[8][dv(defcfg['fa'], 0)].setSelected(true);
                ctrls[9][dv(defcfg['fc'], 1)].setSelected(true);
                ctrls[10][dv(defcfg['i'], 0)].setSelected(true);
                ctrls[11][dv(defcfg['r'], 0)].setSelected(true);
                ctrls[12][dv(defcfg['a'], 1)].setSelected(true);
                ctrls[13][dv(defcfg['g'], 1)].setSelected(true);
                ctrls[14].text = dv(defcfg['p'], '');

                const wb0 = 100, wh0 = 40;
                let btn = new TextButton('取消', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(); });
                this.addChild(btn);
                btn.x = gap;
                btn.y = LOBBY_HEIGHT - wh0 - 20;

                btn = new TextButton('确定', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(this._cfg()); });
                this.addChild(btn);
                btn.x = LOBBY_WIDTH - wb0 - gap;
                btn.y = LOBBY_HEIGHT - wh0 - 20;
            }

            /**
             * 获取设置
             */
            _cfg() {
                let ctrls = this.ctrls_;
                function rv(rbs, dv) {
                    for (let i = 0, len = rbs.length; i < len; ++i) {
                        if (rbs[i].isSelected()) {
                            return i;
                        }
                    }
                    return dv;
                }

                let cfg = {
                    't':ctrls[0].text.trim(),
                    'n':rv(ctrls[1], 0),
                    'l':rv(ctrls[2], 1),
                    'b':rv(ctrls[3], 1),
                    'r30':rv(ctrls[4], 2),
                    'r12':rv(ctrls[5], 1),
                    's':rv(ctrls[6], 0),
                    'o':rv(ctrls[7], 1),
                    'fa':rv(ctrls[8], 0),
                    'fc':rv(ctrls[9], 1),
                    'i':rv(ctrls[10], 0),
                    'r':rv(ctrls[11], 0),
                    'a':rv(ctrls[12], 1),
                    'g':rv(ctrls[13], 1),
                    'p':ctrls[14].text
                };
                localStorage.setItem('default_config', JSON.stringify(cfg));
                return cfg;
            }
        }

        /**
         * 配置转成富文本
         * @param {number} fs 字体大小
         * @param {object} cfg 配置
         */
        function cfg_richtext(fs, cfg) {
            let ctn = new PIXI.Container();
            let t, w = 0, gp = fs * .4;

            t = new PIXI.Text(`${cfg['n']}盘 | ${cfg['l']}番 (${cfg['b']})`, {
                fontFamily: FF,
                fontSize: fs,
                fill: '#ffd700',
            });
            t.x = w;
            ctn.addChild(t);
            w += t.width + gp;

            t = new PIXI.Text(`${cfg['r30']}/${cfg['r12']}秒`, {
                fontFamily: FF,
                fontSize: fs,
                fill: '#ff6a6a',
            });
            t.x = w;
            ctn.addChild(t);
            w += t.width + gp;

            t = new PIXI.Text(`${cfg['s']?'有':'无'}战术鸣牌 | 结束${cfg['o']?'':'不'}显示手牌`, {
                fontFamily: FF,
                fontSize: fs,
                fill: '#00bfff',
            });
            t.x = w;
            ctn.addChild(t);
            w += t.width + gp;

            t = new PIXI.Text(`错和${cfg['fa']?'-30/+10':'-40/+0'} ${cfg['fc']?'':'不'}允许鸣牌`, {
                fontFamily: FF,
                fontSize: fs,
                fill: '#cdcdcd',
            });
            t.x = w;
            ctn.addChild(t);
            w += t.width;

            //ctn.height = t.height;
            //ctn.width = w;

            return ctn;
        }

        /**
         * 桌子信息
         * @typedef {object} TableInfoView
         */
        class TableInfoView extends PIXI.Container {
            /**
             * @param {object} d 桌子信息
             * @param {function(number,number,boolean):void} cb 座位回调
             */
            constructor(d, cb) {
                super();

                this.tableid_ = d['i'];
                this.time_ = d['t'];
                this.pw_ = d['u'];

                const w0 = LOBBY_WIDTH - 20, h0 = 120, gap = 10;

                //this.width = width;
                //this.height = height;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0x00FFFF, .25);
                bg.beginFill(0x043c6b, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();

                let cfg = d['g'];
                this.anonym_ = cfg['a'];
                let r30 = cfg['r30'];

                let sp = new PIXI.Sprite(RangeBar.cycleTex);
                sp.scale.set(.4);
                sp.anchor.y = .5;
                sp.x = gap;
                sp.y = 25;
                sp.tint = (r30 == 5 ? 0xffffff : (r30 == 8 ? 0x00bfff : (r30 == 10 ? 0xff6a6a : 0x00cd66)));
                this.addChild(sp);

                if (this.pw_) {
                    sp = new PIXI.Sprite(TableInfoView.lockTex);
                    this.addChild(sp);
                    sp.anchor.set(.5);
                    sp.scale.set(.7);
                    sp.x = gap + 40;
                    sp.y = 25;
                }

                let t = new PIXI.Text(cfg['t'], {
                    fontFamily: FF,
                    fontSize: 26,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                t.anchor.y = .5;
                t.x = gap + 55;
                t.y = 25;
                this.addChild(t);
                scaleText(t, w0 - 120 - gap * 3 - 55);

                this.pro_ = t = new PIXI.Text('', {
                    fontFamily: FF,
                    fontSize: 18,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                t.anchor.x = 1;
                t.anchor.y = .5;
                t.x = w0 - gap;
                t.y = 25;
                this.addChild(t);

                let rd = d['n'];
                if (rd) {
                    t.text = `${rd}/${cfg['n']}`;
                }

                let btn = new TextButton('准备', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, 120, 40, ()=>{
                    //console.log(`{"m":1,"r":6,"v":${this.readyBtn_.value_}}`);
                    tz.ws.send(`{"m":1,"r":6,"v":${this.readyBtn_.value_}}`);
                });
                btn.x = w0 - gap - 120;
                btn.y = 5;
                this.addChild(btn);
                btn.value_ = 1;
                this.readyBtn_ = btn;

                let ctn = cfg_richtext(18, cfg);
                ctn.x = gap;
                ctn.y = 60;
                ctn.pivot.y = ctn.height * .5;
                this.addChild(ctn);
                let xx = ctn.width;
                if (xx + gap * 2 > w0) {
                    ctn.scale.set((w0 - 25 - gap * 2) / xx);
                }

                let name = new Array(4);
                let tick = new Array(4);

                let gapX = (w0 - gap * 2) * .25;
                let p = d['p'];
                let ready = d['r'];
                let rdm = cfg['r'];
                for (let i = 0; i < 4; ++i) {
                    let xx = gap + gapX * i;
                    btn = new EmptyButton(gapX, 35, ()=>{ cb(this.tableid_, i, this.pw_); });
                    btn.x = xx;
                    btn.y = 82;
                    this.addChild(btn);

                    t = new PIXI.Text(rdm ? (i + 1) : WIND[i], {
                        fontFamily: FF,
                        fontSize: 22,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    t.anchor.y = .5;
                    t.x = xx;
                    t.y = 100;
                    this.addChild(t);

                    let sp = new PIXI.Sprite(CheckBox.tkTex);
                    sp.anchor.set(.5);
                    sp.x = xx + 37;
                    sp.y = 100;
                    this.addChild(sp);
                    tick[i] = sp;
                    sp.visible = (ready & (1 << i));

                    t = new PIXI.Text((!this.anonym_ || p[i].length == 0) ? p[i] : '匿名用户', {
                        fontFamily: FF,
                        fontSize: 20,
                        fill: '#ffffff',
                        //stroke: '#0066ff',
                        //strokeThickness: 2,
                    });
                    t.anchor.y = .5;
                    t.x = xx + 50;
                    t.y = 100;
                    this.addChild(t);
                    t.w_ = gapX - 50;
                    name[i] = t;
                    scaleText(t, t.w_);
                }

                this.name_ = name;
                this.tick_ = tick;
            }

            /**
             * 刷新
             * @param {number} id 桌ID
             * @param {number} s 座位
             */
            refresh(id, s) {
                let btn = this.readyBtn_;
                if (id == this.tableid_) {
                    if (this.seat_ != s) {
                        if (!this.tick_[s].visible) {
                            btn.face_.text = '准备';
                            btn.value_ = 1;
                        }
                        else {
                            btn.face_.text = '取消准备';
                            btn.value_ = 0;
                        }
                    }

                    btn.visible = true;
                    this.seat_ = s;

                    //console.log('seat', seat);
                    let nm = this.name_;
                    for (let i = 0; i < 4; ++i) {
                        nm[i].style.fill = (s != i) ? '#ffffff' : '#5cdbd3';
                    }
                }
                else {
                    btn.visible = false;
                    delete this.seat_;

                    let nm = this.name_;
                    for (let i = 0; i < 4; ++i) {
                        nm[i].style.fill = '#ffffff';
                    }
                }
            }

            /**
             * 坐下
             * @param {number} s 座位
             * @param {string} n 用户名
             */
            sitDown(s, n) {
                let t = this.name_[s];
                t.text = !this.anonym_ ? n : '匿名用户';
                scaleText(t, t.w_);
            }

            /**
             * 站起
             * @param {number} s 座位
             */
            standUp(s) {
                this.name_[s].text = '';
                this.tick_[s].visible = false;
            }

            /**
             * 准备
             * @param {number} s 座位
             * @param {boolean} r 准备状态
             * @param {number} id 桌ID
             */
            ready(s, r, id) {
                this.tick_[s].visible = r;
                if (id == this.tableid_ && s == this.seat_) {
                    let btn = this.readyBtn_;
                    if (r) {
                        btn.face_.text = '取消准备';
                        btn.value_ = 0;
                    }
                    else {
                        btn.face_.text = '准备';
                        btn.value_ = 1;
                    }
                }
            }

            /**
             * 进度
             * @param {number} p 当前盘
             * @param {number} r 总盘数
             */
            progress(p, r) {
                this.pro_.text = `${p}/${r}`;
            }
        }

        TableInfoView.lockTex = base64Tex('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADRklEQVR42tWXW0iTURzAN/dtc7Z921rqnHPTlZcphA9lhfWkBgZp6kO+Be4hC42KegvSIKiGqWsGakpW3i+pmfNCXslrkPYSPYQIXTQh27SLW/Pf/8RnEImba2514Af7zs75/j/+/3MO52Ox/sPGRoKRLMSIlCCnEA3is9WB9yM9fD5/MTY21p6WlgYZGekQF7fXLvTzW8L/RpFjCMfdwbnIaQxsyUhPh4b6OujuMkFtTTXUVD+ALlMntLW2gi4rC2iaXsGx1xGROwXOCYVCMN4yQH/fE8jMPL6KMlbstxC4XO5KSkrKak93F7Q0N0FgQABgf6m7SpIgEAjMRUWF0NjYAGq1mry8DznErAUFsg9pl8sD7eVlpdDc1AhyuZxk4ixTOpcbSeMLnU4HJkyzQqEgwQ2IcJ2xfOSyRCKxE4Er+flk7DtG0OV2VCqVWrsxtampqav4PIhsc7BWag7Gx68ODw1CZGSEncmCS42s5J7s7JNQV1sDFEWZ8TnCiXlBbDZ7obKyAvLy8gB/T2OfrysCITweb6m+rhZyc3JIOscQnhPzKJIpIt7W+hB8fX2/4nOYKwIHxDQNQ4MDkJSUCByOj3ETc41HkpNhoL8faJGIyO9xReCwTCaDsdERctCAQMC/sIm51xITE4CsA7GYBuYA29SJxykuLj5SeLMAJifGoeJOOZSUGHKYfc1xgM9to8F4/14VjI+Ngl5/w67X63c7ezr6IU3IhJgWvYqJjoY1/P1lM2w2a8IZVKqQhbV5Wm2Unc/jTZF3IgWODicZx4e1ePVSADTfVbmNlioV5J6QkFJMOVrIOyiK9Wn4cRjYF2Lchu11BJRf3I5bkjXttMD3DzFuwfZWC8t9Kig7L/W8gG0+GpafhoLlkdI7At9ehoO5QwmWDi8IWGejwGxSgrndCwK2OUz9UCiYMfUEjwqQun95rvkV3OMCKzOY+k6ldwRsb7Rg7g35WXevCHyeDPstsMcESN3XtpxXBKx42lm6Q9YNvuUCZMstDar/qPtfCfS2qMEyq3WKj892wvsmBcxtwHyzAoxnJIAXDYcCUnKVVsop6y4N1yk0wZRVE8RxiL+YTT5kRpib84YtnPnQ2AqC/7lP7R/yJtLQGsQ4rAAAAABJRU5ErkJggg==');

        /**
         * 密码输入界面
         * @typedef {object} PasswordView
         */
        class PasswordView extends PIXI.Container {
            /**
             * @param {function(string):void} cb 关闭回调
             */
            constructor(cb) {
                super();

                const gap = 30, w0 = 360, h0 = 240;

                //this.width = LOBBY_WIDTH;
                //this.height = LOBBY_HEIGHT;
                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .5);
                ctn.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                ctn.endFill();
                ctn.interactive = true;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x0C1E2C, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();

                bg.x = (LOBBY_WIDTH - w0) * .5;
                bg.y = (LOBBY_HEIGHT - h0) * .5;

                let t = new PIXI.Text('请输入密码', {
                    fontFamily: FF,
                    fontSize: 28,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = 40;

                let textInput = new PIXI.TextInput({
                    fontSize: '18px',
                    width: '200px',
                    height: '20px',
                    padding: '6px',
                    paddingLeft: '10px',
                });
                textInput.x = 75;
                textInput.y = 90;
                textInput.substituteText = false;
                textInput.destroyBoxCache = ()=>{};
                bg.addChild(textInput);

                const wb0 = 100, wh0 = 40;
                let btn = new TextButton('取消', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(); });
                bg.addChild(btn);
                btn.x = gap;
                btn.y = h0 - wh0 - 20;

                btn = new TextButton('确定', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(textInput.text); });
                bg.addChild(btn);
                btn.x = w0 - wb0 - gap;
                btn.y = h0 - wh0 - 20;
            }
        }

        /**
         * 登录界面
         * @typedef {object} UserView
         */
        class UserView extends PIXI.Container {
            /**
             * @param {string} pzl 验证码
             * @param {function():void} cb 回调
             */
            constructor(pzl, cb) {
                super();

                const gap = 30, w0 = 450, h0 = pzl ? 420 : 320;

                //this.width = LOBBY_WIDTH;
                //this.height = LOBBY_HEIGHT;

                let ctn = new PIXI.Graphics();
                this.addChild(ctn);
                ctn.beginFill(0, .5);
                ctn.drawRect(0, 0, LOBBY_WIDTH, LOBBY_HEIGHT);
                ctn.endFill();
                ctn.interactive = true;

                let bg = new PIXI.Graphics();
                this.addChild(bg);

                bg.lineStyle(2, 0x26608C, 1);
                bg.beginFill(0x0C1E2C, .85);
                bg.drawRect(0, 0, w0, h0);
                bg.endFill();

                bg.x = (LOBBY_WIDTH - w0) * .5;
                bg.y = (LOBBY_HEIGHT - h0) * .5;

                let t = new PIXI.Text('登录', {
                    fontFamily: FF,
                    fontSize: 28,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = w0 * .5;
                t.y = 40;

                const prefix = ['昵称', '密码', '验证'];
                let tis = [null, null, null];
                let plh = [localStorage.getItem('username')];
                for (let i = 0, c = pzl ? 3 : 2; i < c; ++i) {
                    let yy = 110 + 70 * i;
                    t = new PIXI.Text(prefix[i], {
                        fontFamily: FF,
                        fontSize: 22,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                    });
                    bg.addChild(t);
                    t.anchor.y = .5;
                    t.x = gap + 10;
                    t.y = yy;

                    let ti = new PIXI.TextInput({
                        fontSize: '18px',
                        width: '280px',
                        height: '20px',
                        padding: '6px',
                        paddingLeft: '10px',
                    });
                    ti.x = w0 - 300 - gap - 10;
                    ti.y = yy - 15;
                    bg.addChild(ti);
                    tis[i] = ti;
                    ti.text = plh[i] || '';
                    ti.substituteText = false;
                    ti.destroyBoxCache = ()=>{};
                }
                tis[1]._dom_input.setAttribute('type', 'password');
                if (pzl) {
                    t = new PIXI.Text(`验证问题：清一色${pzl}，\n听牌为（包括已出现4枚的）`, {
                        fontFamily: FF,
                        fontSize: 18,
                        fill: '#ffffff',
                        stroke: '#0066ff',
                        strokeThickness: 2,
                        align: 'center'
                    });
                    bg.addChild(t);
                    t.anchor.set(.5);
                    t.x = w0 * .5;
                    t.y = h0 * .5 + 95;
                }

                const wb0 = 100, wh0 = 40;
                let btn = new TextButton('取消', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(); });
                bg.addChild(btn);
                btn.x = gap;
                btn.y = h0 - wh0 - 20;

                btn = new TextButton('确定', {
                    fontFamily: FF,
                    fontSize: 20,
                    fill: '#ffffff',
                    stroke: '#0066ff',
                    strokeThickness: 2,
                }, wb0, wh0, ()=>{ cb(tis[0].text.trim(), tis[1].text, pzl ? tis[2].text : ''); });
                bg.addChild(btn);
                btn.x = w0 - wb0 - gap;
                btn.y = h0 - wh0 - 20;
            }
        }

        /**
         * 最顶层view
         * @typedef {object} TopView
         */
        class TopView extends PIXI.Container {
            constructor() {
                super();

                //this.width = LOBBY_WIDTH;
                //this.height = LOBBY_HEIGHT;
            }

            adapt() {
                let sx = window.innerWidth / LOBBY_WIDTH;
                let sy = window.innerHeight / LOBBY_HEIGHT;
                let ss = Math.min(sx, sy);

                this.scale.set(ss);
                let cw = LOBBY_WIDTH * ss;
                if (window.innerWidth > cw) {
                    this.x = (window.innerWidth - cw) * .5;
                } else {
                    this.x = 0;
                }
            }

            /**
             * 提示错误
             * @param {string} s 文本
             * @param {boolean} r 一直保持不消失
             */
            error(s, r) {
                let bg = new PIXI.Graphics();
                this.addChild(bg);

                let t = new PIXI.Text(s, {
                    fontFamily: FF,
                    fontSize: 32,
                    fill: '#000000',
                });
                bg.addChild(t);
                t.anchor.set(.5);
                t.x = LOBBY_WIDTH * .5;
                t.y = LOBBY_HEIGHT * .5;
                scaleText(t, LOBBY_WIDTH - 40);

                let w = t.width, h = t.height;
                bg.beginFill(0xffffff, .9);
                bg.drawRect((LOBBY_WIDTH - w) * .5 - 20, (LOBBY_HEIGHT - h) * .5 - 20, w + 40, h + 40);
                bg.endFill();

                if (!r) {
                    (new TWEEN.Tween(bg)).to({alpha:1}, 100).onComplete(()=>{
                        (new TWEEN.Tween(bg)).to({alpha:0}, 100).delay(1300).onComplete(()=>{ bg.dstry(); }).start();
                    }).start();
                }
            }
        }

        start_load();
    </script>
</body>
</html>
