<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title></title>
  <style>*{padding:0;margin:0}</style>
  <meta name="viewport" content="user-scalable=no,initial-scale=.4,maximum-scale=.4,minimum-scale=.4,width=device-width,height=device-height">
</head>
<body>
  <canvas></canvas>
  <script src="js/pixi.min.js"></script>
  <script src="js/pixi-sound.js"></script>
  <script src="js/Tween.min.js"></script>
  <script src="js/PIXI.TextInput.min.js"></script>
  <script>
'use strict';
/* jshint esversion: 6 */
/* jshint -W069 */  // {variable} is better written in dot notation
// /* jshint -W116 */  // Expected '{' and instead saw 'continue'. (W116)jshint(W116)
// /* jshint -W030 */  // Expected an assignment or function call and instead saw an expression. (W030)
/* jshint -W008 */ //  A leading decimal point can be confused with a dot: '.5'. (W008)jshint(W008)
// /* jshint -W014 */ // Misleading line break before ','; readers may interpret this as an expression boundary. (W014)
// /* jshint -W078 */ // Setter is defined without getter. (W078)"
// /* jshint -W109 */ // Strings must use singlequote. (W109)
/* jshint -W040 */ // If a strict mode function is executed using function invocation, its 'this' value will be undefined. (W040)

// windows
//var console={},PIXI={},TWEEN={},Image={},window={},location={},document={},localStorage={},WebSocket={},URL={},navigator={};
//function setTimeout(){}
//function setInterval(){}
//function clearTimeout(){}
//function clearInterval(){}

// mac
// var console={},PIXI={},TWEEN={},Image={},window={},location={},document={},localStorage={},WebSocket={},URL={},navigator={};
// function setInterval(){}
// function clearInterval(){}
// function setTimeout(){}
// function clearTimeout(){}

    // TileTable
    const TlTbl = Uint8Array.of(
      0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,6,6,6,6,7,7,7,7,8,8,8,8,
      16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,22,22,22,22,23,23,23,23,24,24,24,24,
      32,32,32,32,33,33,33,33,34,34,34,34,35,35,35,35,36,36,36,36,37,37,37,37,38,38,38,38,39,39,39,39,40,40,40,40,
      48,48,48,48,49,49,49,49,50,50,50,50,51,51,51,51,52,52,52,52,53,53,53,53,54,54,54,54,
      64,65,66,67,68,69,70,71
    );
    // Seat To Origin
    // 每盘座位转换为初始座位
    const St2Ogn = [
      Uint8Array.of(0, 1, 2, 3), Uint8Array.of(3, 0, 1, 2), Uint8Array.of(2, 3, 0, 1), Uint8Array.of(1, 2, 3, 0),
      Uint8Array.of(1, 0, 3, 2), Uint8Array.of(0, 3, 2, 1), Uint8Array.of(3, 2, 1, 0), Uint8Array.of(2, 1, 0, 3),
      Uint8Array.of(3, 2, 0, 1), Uint8Array.of(2, 1, 3, 0), Uint8Array.of(1, 0, 2, 3), Uint8Array.of(0, 3, 1, 2),
      Uint8Array.of(2, 3, 1, 0), Uint8Array.of(1, 2, 0, 3), Uint8Array.of(0, 1, 3, 2), Uint8Array.of(3, 0, 2, 1)
    ];
    // Tile Superscript
    const TlSpt = [
      '1', '2', '3', '4', '5', '6', '7', '8', '9',
      '1', '2', '3', '4', '5', '6', '7', '8', '9',
      '1', '2', '3', '4', '5', '6', '7', '8', '9',
      'E', 'S', 'W', 'N', 'C', 'F', 'P', '', ''
    ];

    /**
     * 获取pack类型（吃碰杠）
     * @param {number} p pack
     * @return {number}
     */
    function pk_tp(p) { return (p >> 8) & 3; }

    /**
     * 获取pack的牌 0x3f=63
     * @param {number} p pack
     * @return {number}
     */
    function pk_tl(p) { return (p & 63) << 2; }

    /**
     * 获取pack的供牌者
     * @param {number} p pack
     * @return {number}
     */
    function pk_ofr(p) { return (p >> 6) & 3; }

    /**
     * pack是否为加杠 0x300=768
     * @param {number} p pack
     * @return {boolean}
     */
    function pro_k(p) { return (p & 768) === 768; }

    /**
     * 生成一个pack，测试用
     * @param {number} p 类型（0吃，1碰，2杠，3加杠）
     * @param {number} t 牌
     * @param {number} o 供牌（对于碰杠：0自己，1上家，2对家，3下家；对于吃牌表示第几张）
     */
    function mk_pk(p, t, o) {
      return ((p & 3) << 8) | ((t & 63) >> 2) | ((o & 3) << 6);
    }

    /**
     * 获取word的低字节
     * @param {number} w word
     * @return {number}
     */
    function lobyte(w) { return w & 255; }

    /**
     * 获取word的高字节
     * @param {number} w word
     * @return {number}
     */
    function hibyte(w) { return (w >> 8) & 255; }

    /**
     * 获取dword的低字
     * @param {number} d dword
     * @return {number}
     */
    function loword(d) { return d & 65535; }

    /**
     * 获取dword的高字
     * @param {number} d dword
     * @return {number}
     */
    function hiword(d) { return (d >> 16) & 65535; }

    /**
     * 交换数组中两个元素
     * @param {array} a 输入数组
     * @param {number} i 位置1
     * @param {number} j 位置2
     */
     function swp(a, i, j) {
      let t = a[i];
      a[i] = a[j];
      a[j] = t;
    }

    /**
     * 随机打乱数组
     * @param {array} a 输入数组
     * @param {number} b 开始位置
     * @param {number} e 结束位置（不包括）
     */
    function shfl(a, b, e) {
      for (let i = b, l = a.length; i < e && i < l; ++i) {
        let j = Math.trunc(Math.random() * (e - b)) + b;
        if (i !== j) {
          swp(a, i, j);
        }
      }
    }

    /**
     * 将数组中指定元素提到最前
     * @param {array} a 输入数组
     * @param {number} i 位置
     */
    function shft_ahd(a, i) {
      let t = a[i];
      while (i > 0) {
        a[i] = a[i - 1];
        --i;
      }
      a[0] = t;
    }

    /**
     * 将数组中指定元素移到最尾
     * @param {array} a 输入数组
     * @param {number} i 位置
     */
    function shft_bhd(a, i) {
      let l = a.length;
      let t = a[i];
      while (i + 1 < l) {
        a[i] = a[i + 1];
        ++i;
      }
      a[l - 1] = t;
    }

    /**
     * 字符串化数字时显示正号
     * @param {number} x
     * @return {string}
     */
    function psgn(x) { return (x >= 0 ? `+${x}` : x); }

    /**
     * 字符串化数字时显示为两位
     * @param {number} x
     * @return {string}
     */
    function pad2(x) { return (x < 10 ? `0${x}` : x); }

    /**
     * 根据base64字符串生成PIXI纹理
     * @param {string} b base64的图片
     * @return {object}
     */
    function b64t(b) {
      let img = new Image();
      img.src = b;
      return PIXI.Texture.from(img);
    }

    /**
     * 创建BitmapText
     * @param {string} t 文本
     * @param {object} s 5.x版本的BitmapText.style
     * @return {object}
     */
    function bmp_txt(t, s) {
      //return new PIXI.extras.BitmapText(t, {font:`${s['fontSize']}px ${s['fontName']}`});  // v4.x
      return new PIXI.BitmapText(t, s);  // v5.x
    }

    /**
     * 缩小文本以适配宽度
     * @param {object} t 文本
     * @param {number} w 宽度
     */
    function scl_txt(t, w) {
      let w0 = t.width / t.scale.x;
      if (w0 > w) {
        t.scale.set(w / w0);
      }
      else {
        t.scale.set(1);
      }
    }

    PIXI.DisplayObject.prototype.dsty = function() {
      try {
        this.destroy({children:true});
      } catch (e) {
        console.log(e);
      }
    };

    /**
     * 添加模糊效果
     * @param {object} p 待添加效果的精灵
     */
    function addblur(p) {
      let b = new PIXI.filters.BlurFilter();
      b.blur = 1;
      p.filters = [b];
    }

    /**
     * 移除模糊效果
     * @param {object} p 已经添加过效果的精灵
     */
    function rmblur(p) {
      p.filters = [];
    }

    const FF = [
      '-apple-system', /*'BlinkMacSystemFont',*/ 'Segoe UI', 'Roboto', 'Helvetica Neue', 'Arial', 'Noto Sans', 'sans-serif',
      'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji'
    ];

    console.log('location.search', location.search);

    const T64 = Object.freeze({
      // 圆形128 * 128
      CY: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAMAAAD04JH5AAAAolBMVEUAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+/v7+/v7////////+/v7///////////////////+wenBYAAAANXRSTlMAA/cG5wnSwTgjFxMPdgi9tKxpWBwM28WglCv57sqPhH9gW0jw6XlsT0EfGvPhLie4iHJlP9pFTFAAAAOoSURBVHja7duJdqJAEAXQ6m5AEVQWF8Qd9y3rvP//tTGTmZBJMCMKXc45uT9Q71hlQks1XU6kSI+0cLxZTUbNypvmaLLaxBqSCNWIk15XIpPs9pK4oUpLIcxaEh36+FL/ECU1U5RR3Z56c5xl7k3tgjMod9MzkIPR27iKitLYhQ975LR/CHcNKoJqBUOJC8hh0FLXl3eSIS42TJzrIgh35klcQXozV1zR/LtxB1fqjO8uHQXhrJsoQHPtiIvq2+MFCrEY2xckMKuRREFkVDUpJyesoECV0KFcanUDhTLqtTzt3y4NFMxYbsXZ9e97EoWTvXtx7vin9YtNcOaXYTeWKIUc7xjmL2MSc9RnSOAGBkpkBC59qZ1YKJWVtOkLamahZNZM0Unizkfp/DtBp7RGEqWTo9bJAVjNocF8dWIM1MaCFtZGZTfAhyZ+K7MBTxKayKeMJohqB9p0qp+/CU4EjSLn0wSGc2g0D9XHCexCq+6HOVRTCa3kVNF7uy406+6YPoDsj8BtQrumm9YXsz20289EegyLwCBKj2v2AgwW9tsIBmARqD8d6IJF1/zTAQkW8ncPxBRMpuJ1BHww8dXrCAzAZNCgF1WwqdKRqINNXbwE8MDGewmgDLAxXgI4fbDpO3wzmE5hAEbBMcAEjCZEwgcj/xigCUbNY4AKGFWOAfpg1D8GAKvvAN8BvgPcQoAOGHVu4E8xcf8zogiMoht4IKEEjJJbeChlfSx3b+Fgwn40Yz+csh/P+X+gYP+JRjyDybOgX2IJFjKmV+YQLIYmvVJLsFgq+i0egMEgTt9Z+mDgp28vxVpCO7kW9KbGMIbDGqU43hgEit6xO9CsY9N75kpCK7kyb+vVLTX0vrqU0wZ90PKgkdfKWCFaQJtF1jKR+whtHl36TMRdaNKNBWUwQ01NWIQmZXLGEhrIsXNyl9OHBv7pzU71Y4jSDX8oOqkddlCyTtimL7grA6UyVi59qbYcoESDZY3+YVvmTqEcbRnWqvMuV4v7UUldGIzuBc9qe7rezrXcny41cyRI6+dQCywUygpqlIs781Agb+ZSTqrYSy7qkms+kwMKcZjY4n+86MR/1etIuGtvjivMvbUrrrxt+GzhYtZzATcOG9snS+IC0nraNqgIpl23+sipb9Vts8hbp809ctg30xunxRDt6uMBZzo8VtuCCqfam5El/9350aatqBxCqTjsWfJ08V4YKyWoVEI41WDyUJF/la48TIKqIwT9d34CBB4Uc5tI3NEAAAAASUVORK5CYII='),

      // 复选框相关40 * 40
      CB: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAB+0KVeAAAAIVBMVEUmJij19fnn5+s6Ojy6ur2cnJ8rKy2bm56VlZg5OTw8PD5Ii9qAAAAAQElEQVQoz2NIVRREA0JhDIWCGECCQdGZAQ2YCDEIGqALMgsyCDJggFHBUcHBI4iRaDkFGRQ90QWXCGHNCFizDACdVg4t30uVKQAAAABJRU5ErkJggg=='),
      TK: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACgAAAAoBAMAAAB+0KVeAAAAGFBMVEUAAAD19fn19fn19fn19fn19fn19fn19fn8h/qnAAAAB3RSTlMAJeSAcaBJxjzuQwAAAGRJREFUKM/lzrENgDAMRNEgGCBCMEAaaOlo6dgHilsfich8YTIBuc7nJ8uhygyFrpmXb9nrLEBps6GLBnVEK9f0wGRde+8d3DMAIoDcMvimQOgEhEpAKBDqIT96mqGnQDLG8ONcEMQfjD5vxOcAAAAASUVORK5CYII='),

      // 锁32 * 32
      //LK: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAADRklEQVR42tWXW0iTURzAN/dtc7Z921rqnHPTlZcphA9lhfWkBgZp6kO+Be4hC42KegvSIKiGqWsGakpW3i+pmfNCXslrkPYSPYQIXTQh27SLW/Pf/8RnEImba2514Af7zs75/j/+/3MO52Ox/sPGRoKRLMSIlCCnEA3is9WB9yM9fD5/MTY21p6WlgYZGekQF7fXLvTzW8L/RpFjCMfdwbnIaQxsyUhPh4b6OujuMkFtTTXUVD+ALlMntLW2gi4rC2iaXsGx1xGROwXOCYVCMN4yQH/fE8jMPL6KMlbstxC4XO5KSkrKak93F7Q0N0FgQABgf6m7SpIgEAjMRUWF0NjYAGq1mry8DznErAUFsg9pl8sD7eVlpdDc1AhyuZxk4ixTOpcbSeMLnU4HJkyzQqEgwQ2IcJ2xfOSyRCKxE4Er+flk7DtG0OV2VCqVWrsxtampqav4PIhsc7BWag7Gx68ODw1CZGSEncmCS42s5J7s7JNQV1sDFEWZ8TnCiXlBbDZ7obKyAvLy8gB/T2OfrysCITweb6m+rhZyc3JIOscQnhPzKJIpIt7W+hB8fX2/4nOYKwIHxDQNQ4MDkJSUCByOj3ETc41HkpNhoL8faJGIyO9xReCwTCaDsdERctCAQMC/sIm51xITE4CsA7GYBuYA29SJxykuLj5SeLMAJifGoeJOOZSUGHKYfc1xgM9to8F4/14VjI+Ngl5/w67X63c7ezr6IU3IhJgWvYqJjoY1/P1lM2w2a8IZVKqQhbV5Wm2Unc/jTZF3IgWODicZx4e1ePVSADTfVbmNlioV5J6QkFJMOVrIOyiK9Wn4cRjYF2Lchu11BJRf3I5bkjXttMD3DzFuwfZWC8t9Kig7L/W8gG0+GpafhoLlkdI7At9ehoO5QwmWDi8IWGejwGxSgrndCwK2OUz9UCiYMfUEjwqQun95rvkV3OMCKzOY+k6ldwRsb7Rg7g35WXevCHyeDPstsMcESN3XtpxXBKx42lm6Q9YNvuUCZMstDar/qPtfCfS2qMEyq3WKj892wvsmBcxtwHyzAoxnJIAXDYcCUnKVVsop6y4N1yk0wZRVE8RxiL+YTT5kRpib84YtnPnQ2AqC/7lP7R/yJtLQGsQ4rAAAAABJRU5ErkJggg=='),
      LK: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAMAAABEpIrGAAABRFBMVEUAAAAAAAAAAAADAwABAAAAAAAAAAAAAAAhGQMkIgUAAAAAAAAAAAAAAAAYGBgICAgREREGBgYAAAAAAAAAAAAAAAA2NjUSERAAAAAAAAAAAAAAAAAAAAAAAABYWFc8OzuLi4owMDAVDwETExMeHh0AAAAHBgYAAAAAAAAAAACWlJIAAAAAAAAAAAAAAAAJCQeVlZIAAAAAAAAAAACRkZEAAAAAAACLi4sAAAD96yvxsxytoB7DtSGachHytBzy4SnorBoqKSm5uLf76SqtrKvKycinpqWdnJuRkI9TUlL75Sn0wx/yuRwODg3DwsHAv76xsLCqqahoaGdjYmJPT0/41yXCwcCjoqGCgYGAgIBtbGxKSUlFRUREREP64Sj53yj73SbuzCP2zyL1yyG7rh8fHx/0vh6uoR6FfBaUbhBtXxAMDAyBW2C+AAAAOXRSTlMANwbx0RQDyvr6GpQLAv3y/fnox8Bw/ty6qWlEJSH+/v39+vnr0tDQspmUjYmIf3RsYlBNSj00LhGBVmjbAAABMUlEQVQ4y5WS11KDUBRFA0SIdAipJvbee0GN0iEJ6bH3Xv7/XcdJLkPxjq63M2cNm33mxv4HuUZR+SLz2xrJcmOOk+aS63jUGs1zTlM1TbXR5hfpCCH1adeHBQwTOqrOzoVjhjhbf5a2SBKZZS2dTQX39FRbZSn6J2uZ189EMiBsTKgdqZeM5kZqSuATeLZlYgXQVrTO46j/AFjzIokCXWo1hKL/BO7JFeWN1GXd3fZ34I30ijcuXddcxPcLm7ZhrTJ4D2b+1Bjdwb2KOSKjKEqGAEx+j9PEQv9aA9jbfpjXjxkUCAd7Ye4O41Ch/AIXtEoJLnRluHBThQtaRYYK2oMMF25LcKFcleHCowwVtK4MEUBApAAahoWnI8D9cZ93IOyKiUFAAjDuPdICEgkZ+wtffUVqVxPpcRUAAAAASUVORK5CYII='),

      // 花36 * 36
      //F: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAYAAADhAJiYAAAE/0lEQVR42sVYfWwTZRzuxBgiEfUfo4nGL/4yaqKJiYliJEHUZBEzg4kGNSoiEiYiCDLYum8mDhkb2xhsdrR3vWshwGY/7rbBnB/xH6JAkLBkQjJBhTHMHGzd1vbxeXsbXffR3smKTd703u/nnt/32WzX98uADRljnZN27y1izPY//DJGZN/CiKK1se0UA72SNDei6L+wtYzI2oIbhgRe7yyCKIHaMgxPC/gfCruDyyKqXh3rs0U5F3FrBbDbb0o7IF60npdGxy6fvumRsKKvSTM72jyKpD81GKORtb5BZ/ODaWQnWGwWzDVQSktu+hhS9e8sA1L1w2kBY6eCUoFPWWdIO3Hdl/dKgblDkv+xYVfwqUHJf7+wrBhDHv2oVUBRVftpzDrBs8SZQ6rv0Z6GpttSAgm5hNJqDiruRWElhlnroaiq/8wxuzFulSH9z4iq5VF0x3jO0JgF8vkC5+oh+x6aEkzYrb/Khb2mLpIDsApseh3TLkHVMhPAjEj+Z6Iek+b8+WZg8ctAcbnRVzSgbh+wwwGUVRCsH9bFqv8Dd+sTcXNWtP2mD1j6BrBoPrBypdHPrwKyC4BMglz0LJCT91+Y6h1yBx+Pm7MSfIAoT5vaXOsCNmwC/D6g4SDwcREBFQKvZQEvPU/mvrQuNreWN9npqYw9Vg5q6wD2NRtgBKitZCq3DKg/gFFjsCKyk2ElsBxS4F6hP88JkTEgXjGlzCW7qEfbgKIa4NAhYH2ZAarRCawtpR7VAwXVZJE6VrzLkgHQEiuF/nxhmpXS3XFGRPtsC5lQgMJcoEniWGHivHgu22PFRZTawmowyzSgTdvjl8UaL+T7oItsnNnJNWsnzLPl7jANKCxri21/Ow7eQRmeM7VpW2MiAxvzgeMfAd1k52wdcGINRZU/bg3/K1xm/VG3iBCGU1S0D6555mRNKGqlDORVAqtLqE9kpotAushSJ8V2SrDhBiSuqW4A9ngA1zd0BXbgq9pk50bC7sB7cbNn4KQulYuJpIDqeUEu33rvfvb5vJvOsIpAflwF/JBNBnOAVZzfSKBNrUDH9wSyFXiB/umVFwnUN5WFRWJ6PDG7FANhJfgWPXbXtBnhu+8YTvH9t+PWlU3RrC40WvYUylz1NZCVCaxYQSa08edFaVVdTH+X2pOluqhrvhUebQGdVdUkQMIhZi6kt16WqLif0to+KUkYi64rp9UcMfa5A+P9EoFoFaIQOM+7TKcg1Ks3JzElDnU2GT5mPKAaleLam6DwoZxGXJT6EFa/ncg0z9Ret5QPiRyIdPZMq0siZGxmIN3AMLHdaQAVQXYL/dS6sph7uNpwFH9IUfTIfdSTtolKfGFA0e8znzuTUlNuYKrwIICNjve7O3FJvkyTPjxVJlluCoyoPpnl/TZT+U6S+NUJe/vNKQFddWn38A0H0g+o5Uq/88BdKQENMOISfSjdgOiIB+D135261KEpijz4BojsdzjaZ5urvxTdk25AVGrZtJUNS4GnxUcEC6XOaVpmp6m1Hj3KswdFOWStbFb0fCr3ZVJ7JgWYblG/h9TAw0iVNah6B8PHk3QN862XzaJSlX13wtt6u6ihpsnwjjHtfGRsjygueenxJGKqnZmPDIpeJMpow3vr59g/EpYDy/9yOudMehGnPocB80OKsJ0vcn50z68EUxNyNc2bsdreu2TJLHHZWYdjttk9Yq3YY+XD1b94sRp9iYCMcwAAAABJRU5ErkJggg=='),
      F: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAkCAMAAADW3miqAAABZVBMVEUAAADadID+qLn/qbn/qLr6pLXzpLL5nrPrj67+qLn7pbb7prb+qLn+qLn+qLn/qLn/qbn+qLn9p7j9p7j9p7n8prf8prf6prf/qbr+qLn9qLn+p7n9p7n9p7n9p7n8p7j9prn9pbb6o7fqn6r/qLr+qLr/qLn9p7n9p7n9qLj8prf+qbj/p7r+qLj9p7j9prj8p7n6pLbzoq7/qbr/boP/bYL/qLn/pbX/eIz/eoD/h5v/cYb/TUfrpfD9qL//na//m6r/kKP/3pf/hJf/e4//hIz/d3v/Rj3/v8L/s7L/oq//qaf/laX/jaH/kp//jJX/gZT/fZL/3Iv/doj/dIj/kHv/0m3/xWz/Yl7/Uk/mpP7zptn1ncz/sbv/q7L/qan/pKX/4qT/saT/oKL4eqD/mp//lZ3/iJz/1pH/iJD+dIz/jor/uIn/fYj/2X3/gn3/qXP/amr/aGj/XGT/XFn/SED/RTxqbgfSAAAAM3RSTlMAAuv++B8OCgTmLCPz493Y1dGLhX5mQhruzr6rlpOBXE48NQj69MK7npBjVDHHpXZxOBbfsnyPAAAB9ElEQVQ4y42SZZPbMBBA1+zghZmPoSjLiZPchS9HPcYyM9Pvr2yPLbWuO30fpNnVG2klLfwJB6DCv8kslkHOL2bAHzU5h8SVEkJzFc5XuoEchJt+TiiMXMKSj5REDCkfaYGVCn93uBgrxT3rcrAhqZBnpWugSo2gTAte4gUk5lM8KwVScREJ/FLIdmo55NBEHvia6dTpxTe7E6T399/85obXiFSk8ffpF3SIu1ODlXJBIkkzbry3ud3T8NWPiffBKoiy9RBrBx96SKepWDoL9eK8W/aoNdo+wc86rw5bI6auMiRo0Maadrr76SkmM27TfBJWaTDWyOL74+FnjXBE8zWQI25wh+xgnD8ZnhtYwwM3HZEB0oIT6YOjzmR4/PH17uOX/aZxYGeFFfNfE47VN3YevTi7uDjDrQdb7352m5aT4MC0qlFbupxenmCNYJa9f/XVfIdo1WlkJVO2f+UbETodMrzdQE3iLGcUoFStmnZaZH3PrP/5+gYirAKDxCOL3rg10PX26fj+3XWrBdhOX0YOujXo6J69VYI6ahT5MKO6Ulb0k+Zv/4ckZl1JCfhJkVlwKfpJ14FyS2RqpZ0qiA1gqOSizgFSyDl8Ya0OLJws2+8ZJ20fjNtSCTwkY3ygkFasi6QLAT5WCoEXTmGuMqtwNPgFoQSmKwyf2sgAAAAASUVORK5CYII='),

      // 举手120 * 120
      //R: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAYAAAA5ZDbSAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAAB3RJTUUH5AMRFScVQ/GOCwAAAAZiS0dEAP8A/wD/oL2nkwAAD8pJREFUeNrtnXt0HNV9xz/3zuyutKuXJRvbsiXZxsZQi5jQmIJjbDAQXi2EgAklTkpympASaHwAEwLhEXJo3TQk5FEnUJK0B0II1E1iH1KKT0OA8MYBAyXY2NRgsB62JVmynrszt3/MzGp2Je3sEmW1s7nfc/YcPWZnduc739/r3vu7oKGhoaGhoaGhoaGhoaGhoVEmEGX+3aqAGvfnXqAPUJrgcMMAjgM+DiwHZrrfsxN4DngIeB5IaX2HD1XA9cA+V6njvfYDXwPq9O0KF2LABmAkB7neKwVsdB8IbaJDgk8AdwNxgIZ6g7/8SDUnLosjBbz48iBbHumjvTNtmUeAdcD3tTamHhJYAFzsmuCbgM8BfwFUAvXAbz2FtjRF1C/va1Yj7UuU6mpVqqtVJTuWqK3/OU8tXhjzK3k7MEff3qlFI3A7sBtI+sixgS5gE3CjFyGbplAb/7lRqYOtKtW5JOOlulrVT+6aqyoqhHeOYeDCcldGKeNo4F7gy66CzSz3Mg34GHCL50/nNUU4+4wqlBqbDdmW4vRVVRy9MOb9KQocW84EmyX82Y4A7gRWe3+oqZbMb44Siwnea0vR1pHEtgGIeMdMbzCprTYYh1+UgqqE5IgZGV+7zn1YZgMtQDXQD+x1o/GUJviPg8uAMwCEgNNWVnHdVdNZemwFEVPQ1pHk3p/1sPFHXfT22aMqtdW46vXOY9uK4ZGM/zcB3wTOcv1x1HUF7cDjwD1u3mxrgicPM9xChQQ4+cQ493y7kZbmKLblkDOtLsZtN8ykusrglg2dpKz8ClS2gmQy49jz3OKIyEq5Frqvc928+V9d4rUPngQsBhYBRKOCK/62gZbmKFZKoZRjai0LTAM+s7aOY5fERr+QFAgxcfbnvFdlP+QCoKJCMK3OIF6ZcVtmAf8EfForeHIj5zjA9HqD41orUPY4QZMNMxpMjmut5KVXhtJmOAe/2Dae304jEZesOb+Gi86vZc4sk/0HLbY80sd9D/bQfcjyKmQ34JQ6t2uC/3CkTaZhCCJm7npMNCJ8Cg4w0bbC8hEciwpuunYGX7y8gYpK6UhcCE5dkWBpawVXf6XN8/EtwNqwEVyqJtr2m1SVw71KCfG4yAikghU8esJTT07wd5+pJxoVWCmFZYGVUkgJay+u5YJza/xvP9UtqmiCJ0HBaQJzqVIIQUVs9AApxIQEC5wAa3h4lOCVyxPU1IxNq5SCWEzykdVVGIbwu44jNMGT4zrEaNAUbHbTJMocChaQSimSqdHjq+K5b0FdjYE56sgibhqlCZ6szyUleRDse6PIPYIipED6DjCM3OceGlbYVvrXJM4ghSZ4shRsSEfFE0PhD7CFdB2xmljt/gfCZ34nSKuU/1ReDVsTPHkKdk20mpDfDBPt+WCVIw/2DhcCTLOcZy2FJcgSufSbaaILiaKFCDbR40TwWsGTTbCQue+q30RLmdsHK5Vpok2jIAWHbsLeVBY66oGlOGXJKqAHeB142U+wIQUyoPTor3IVUskSQgQqOOxzMKeC4DiwBrgc+ACQ8N3KPuAZf6RacBQdEEbbPp8t8lCwCjnJxSa4Fmdk5rNAxTh1iBrgTP8t9Uw0eZpoEZAm2bYzUOFdMVDBIde0WeRrXQ9c4ZngaEQwpzFCbbXkYLdFW3vKG/YTfkXmDLKyo2jJhAwLL03yRdEyDx8cZitdTIJXuWbZAFi4IMr6K6dzxilVVFdJurotNj/Sx7e+f4B97SkKMdEqo9AhJlawcNTr99mGLCiK1kFWjqj4Upw5VMyZHeGuOxpZvaoKZTtjvA31Btdc2UDTnAifv3ofPb1WuhCRu9AxNorOBcvKVLBhFJwH6zRpHEzHmeIKwCUfq+WUFQmslJOyOGbWUeJHz6nmzNOqMgmxg0x0NsETF6Mta1SVgvflg3WhYxw0uCRjmoLlJ8TH9X3eCM6CeaP1/J5em4FBOyD1yc8HA1iuxchXwSrkYXSxCDa8axkSKmK5oyb/lBrbR0g+laycPhjHB3sPhJTC8cFKK/gPhfKnlDlNLr40BudhiJg5Bv0VYwcbAnxwWsGyYB+sBxtyXEemU5M8SEhLP48gS2Wb6AAFewTLfGvRSis4HxMtRv1e/kGTaYicpKlxKlm5/LU/aHNMdHnnwUVXsBSuIlW+Cg5QpVL5p0kCLNunYAnSKGd6i0vwqIJlbgWnfD44rzw4Yzw4nzxYpQnOL4rWPrgggoPKg3YBCh6bB+cuRmf6YDeKLuMwuuhpUj4Ktsb44NwmvZDxYMtS6dJmWsE6TZpkBRcURTvHq5xBVqEm2p8m5eZXz+goOE0Kjlz9ebBp5i5coDIHG0TAuVMW6dWHUpBXFK3TpIJ9cICJ9ik4YooCB/wJTJP8/joois6KqpQmOI9CR6CC7SwFB026U/kXOlKpzDQpUMEh98/FDLLSZlHmiFyzFWyaAePBamwtOl//LmX5z+iYkkpW7jRJjfHBuRiWEiorRr9GVULmfCBSvlq0IfMog4Y8ijaLrWAhco/gKJwhvXyDrGhU8KlL6ti9Z4TaaskF51YHBlkZEboIYFHPqixQwTKo9JhpcoOCLNuG886q5qQPVdqmKUT9NEPkGq1KpTKDrKA512Gnu+gEOz5Y5LxTfj4DfbCLI2Y4a1BUAAXRiLu0RUG8MnhxufbBhQZZAUtRTFPQ0pzuisS85mjgxDiP2CByla1Y9eEEq09O0Dw3wifW1DGtzsg9oUCb6AIV7JrFCZ84AesubyBeIamslFz213XY+d3kQCnaNixaEOWBe5ro7bOZ02jmZR2Unvg+eQq2FSyYF2XDrTMReSqzIPuqoH6aQUO9kXNmyQT2OHSjScUiWI4qOLic6M2i+GPdyYIeGqXHgws20bK8l+T+SRIs/T5WhIjgSdTvNGA+o4vtyorgcqkbvB/MwlmyswWn9+XPgGXl5oOV/6cwuTXx/syNAJpxelF/Emj13esmnF6cF+F0tC0vgsMWs3guRY0uKRYBFnERcIn7OmoCK7kMp8/1t8uFYNsl2Wm1HioFj1GmnOA+tuK0OrwQp+1h+p2xmOCED1bSfcjmtd8Peec5DfgBTtf50Ptgn4JVqPxwVkuIbAVHgZOA7wG/Aq4B5nnHJOKSM1dX8ePvzmHz/S2svbjWf+oFOAvey9BEh4jhrIERj9wYsAKnafnZOIvr0qitMVh9coLLLq1j1fIEtTUGSJiZ2Wm+krFdDnSQNRVBlk/BEZwG4acAp2crcHqDwdmnV/M3H6/jxGVxEnHpdLe1FIYQGZ3pcbrmJcuJYN9CTBUigj3hKnAakX6DrH6VjbNMzju7hk9eXMefL60gFhslNs3miGLby4P+t+3D2U+x/Ex0mBScNY9eeuQKAfOaolx0fg2XXljLkqMriEQElqWyO8pjGIKnnu/n0ccO+//8LDBQngSHKMiKRNzFb+5MEEPCUQtjXHJBLWs+WstRR0aRBtjWmK0C0sfv3D3Ml27t8O+6th/YXJ6FjhBZaGUrWo+JcfzSCra/Nswxi2OsXeM0CW9uirhde/B3ox0ToLXvt1h/czvPvjjg//b/BrxQbgSrsCnYtmF+S5T7725izzsjLF4UY/YsMz2tSAX47sP9Nrdu6GTLf/f5//Vz4OujNqHsTHS4bLRSMK85wvyWqNNjKw9ahNt4/JsbD/Kj+7v9McdTwHrgQLE+v/bBeSq50E/97w/0cMe/HPDv0fQGzm6nbxU1SCzWPcqw1WU8pGRIeHhrHzf/Yyd9h9Nfuw24Gnix6FnAVBQ6ynXM0DAEz20b5NqbMiLmXpzdUf9rStK8Il0n6anYspxNMUQZKnfHrmHW3djOzt3p8YMRN6C6d8ry+CJdp9clmaFhRc8hK1zTOoJuooS2jhTX3JSRDtk4G1veyRTuYFosgg8ChwEGBhVtHamy2VxeCOjts7nx9k5+tTUjHfoFzr7G/VP68BXpOvuBTs9E79g1XBZ+WAgYGVFsuHM/9z7Y4w8enwCuLWY6NNUE9wA7vV9+98oQQ0N26Am2bfjBj7v4zt1d/jVPrwFfBP6vJNxHEYOsdIqw/dUh3t2XDFysXep+98FfHOK2b+xnYDD9sL7jkvtyyXzOIl7rKTfY4p33kjz57EDgBPjSTYdg62P9fOmrHXT3WP444zrg1yX1IBbxWq8Cr3h+eNOWXg4ftkIXTBuG4PnfDbLuxjbe3Zcerx8AbgMeKjlLU8Rr9QC/TEchT/fz5DMDgSvsS025b+wc5u+vb+P3O9O5bgr4FnAXvopdyXzmIl+vEzgHqB8ZURzqszn3jGpisdInWUrY+16SK9a38cTTGUN/P3TToYGSfCiLfL0unA2xTgHYszfJ3MYIH/pgZUnXp6WEzgMW625oyx7624Qzk7K7ZK3OFFxzj0vwLMuC13cMc9KyOE1zoiVJspTQ1W1x3Vfb+emmQ/5//Q/wBZyBBDTBozjkRtNnAdGeQxZv7h5h1YoE9dOMkiLZMKC9I8X6Wzq476Ee/3ri53DWG+0u+bhhiq77Js4mHScA4u29Sd7em2TFiQnqamVJkGwYgtffGOaq69vZtKXXT+6rwOe8jEATPD4s4CVgCc5aHnbsGubNt0Y44fg4DfXmlJEspdNp7+FH+/jCdW389tmM2Gm7q9wXCAmmctegfpzq1vE4K/HYuWuEF14a5KgjozTPjRQ1R/a22HmvLcXXv3OAm/+hkz17M+alP+GSuy1UefsUX/+g688+4JH87r4kjz7WjwAWL4qRSBhFIba3z2bT5l6u/ko7/7H5EAODaROSBH4KXAXsIGQolQR0Ic6Kgb/yii8RU7ByeZwrP9vAaSsTVFcbKFvl1Tglny8tpLMs5WBXil8/2c8P7+vm8af7GRrK8A3twB1uEaOPEKKUKgzTcYbYPo+zDS0AiYRk1fIEl15Yy6oPJ5g908QwRXrPw3x8tbdC0FvMPTBos+utEbb+5jA/f7iXbdsHs4lNumnQ7cDTpVihCiPB4CzuOgf4Ms4i6XQpNRoRLDoyyqrlCVYuT3Dsn8WYPTNCVUK63fCy9mpw+UqlFENDNge7LXbvGeHFlwZ58pkBtm0fpKMzld2Dywb+F9gIPIBTXg01SrVGOBv4FPBpN8rOqJlHTMH06QYtc6PMb4kwtzHCjAaT6ipJxBRYtuJwv83BLot9HUne2Zvk7XeTtHekGBiwx5trkMLZXv4nrr/di0ZRHr75rtl+DqfWqybxZePMuHjYfZAay/UmhgENONvTngksB450/XSho2GDQIdbrHgc+I2r3MFyVknYPu80nPYHrcAxrspnuoRXuqmfDQzhlEQPuCb3TZzVBTtx6sfD/AmgHOY2GjitECrcIE26BKdcEocowkp6DQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDY1Jw/8DfzHUjiF21CoAAAAldEVYdGRhdGU6Y3JlYXRlADIwMjAtMDMtMTdUMjE6Mzk6MTIrMDA6MDDXr5I5AAAAJXRFWHRkYXRlOm1vZGlmeQAyMDIwLTAzLTE3VDIxOjM5OjEyKzAwOjAwpvIqhQAAAABJRU5ErkJggg=='),
      R: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAB4CAMAAAAOusbgAAABaFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD96isAAAD/7iz+7CsCAgAEAwH76Sv55yr/7CsGBgGkmBwjIAYKCQL25SpMRg0ZFwTZyiWqnh2nmxwfHQUSEAMNDALczCXfzyYcGgWhlRvq2SjWxyTz4Snm1idmXxFHQgxCPQs2MgknJAbw3ynu3Snt3CjHuSKYjRpfWBBQSg08OAo4NAkyLgjg0CbRwiO0qB+xpB5qYxJhWhBXUQ8tKgfk0yfDtSG7rSAWFAO+sCCtoR2Ngxh5cBRbVQ9TTQ7LvSJ1bRRuZhOckBqIfxdyahPi0ieTiBm4qh+EexaAdhYLb/heAAAALnRSTlMA/OAdIQXj+BcSC/D03dEkiOd2YFoxJsStO+u1QzdXK9fKkW6/fmVpVFBKl6OdxBIoZgAABixJREFUaN7t2mlT2kAAxvEgUE4pYC0I0nrbM08CAeTyAKUgoqKCeOFVtVrr1evrN5iQpa1tOTb0Df9XTqczv9mwm90EmG7dunXrdGat1sx0PH2/3dXb6xoZ0DMdzex04D6P3cR0ML3dADnN605e7ydWIFkqFpcSgGGSUT/dM+f4hM9scgFzFYHjhJNVwKZlVM5o79UAfot73IpAkWPFuKkoDC8YdXs65oeUAYgs8Gy1zDYwzqia0QsgdbSSvue31tj7YnlghDH6Bge0ai0spwZYPsmsZS9SAFbWJXhxGXCPDFkM1t63PkaNjMNAeUf8YEPCtwCBC2VAI38Ejkk1Bj1gQXiGq1p8bptc6sIKqkWTUQDWCYZ+zzRITPOSdkDgtSocLe3tnlwngZ5++vATDdLzMrwElGV4fRsI38a4ECfcpAA7ffgZgfk7ES6wynLKS38HS8CwiZ5IRjwnr13uQoH541XglpP+eSoAx1PqcJ+fwFfA8qIE70SALzK8F4bnuRpwZOd3+PMqgT+oMuIJIPJZgkN3P4+4SOBHqsCrx7/DCyJ8oyo8SWD+GsjHpD/n5+B/J8MzqsCjwFGOfRCeUgc2DU46JwbMCiy2T+DpNAKzasDmPpe1uvl7vcB2hsDxGpxAYEYF2DRigJT/FzgowdlTBD7UwY9pnSY1QDiynQ5A2YPFlhQ4JMLhCn140AJEiguZ6fPEL/CmDO8m1YD1b4H0GcezPD+bJFshe0DgTyK8Rx022oA7yQoekhELInwpwVwV/kodfu4gM+eC3ECEEoE3RPhE/i+z9GCPch1DV+ReLXwEDgUZTiF6Rh92KDB/R24g9fB7EX6v5oj5axHOEPijDJ+lkFJgPy2434OoPHPYa3IDCR4S+CSK1AZ92ILoiQzvV2c1gUsETtKHfSJ8JsNLZB0HLwm8F0byE4F7dLTgVB1cLhD4gMCnuyHa8IBFmTnCQfXUIcObwBIrYZWAKrCVwCURjklajMDV404iy8vHW6rwBqcsoXwNjhN4xo/ENHV40IpkDT4E4nXwPqtc3rQCgxpsEKcsgTeDMpwn8Dtgbl4dOKTM5Ms6+LoO3qEOvxLh3ZAykw+DZFZfyNgN2Tvowqc1OK7cJln+w1H5k4wVyW5JEX4pwlkCizcNuVzt2Md9EeEcSx3WKIs0SJYQSRrxdqYO1lKBX9S9ftgHvoVqnlAbOz+9PHcukIkmwrTeAsgwP3/1Pcc+UGY+yFKHn2iURSrSPPtgPFsH92ppvn5oIAJTewvw3+CddmCTzvw/YOOE65HX1/FLrR21aQAMa9WH628gT8eHqizgH21pVjcN6+Tvhnr8AMLlI8CrV3c5kROI3vfaAbFofnbtFrAZW76B/DtyrtbpB994IJbarBQ48rGrCwfgGHVbIHZaOlnkpM1rSP0RzwSgMUAssb8R5Gpn0zFza5tEc3C1uatdgZOfJROAvdXdqXG4Egb8q9+ztX0jNL0FeHyqw/z8VnT7fIFXtrNcHPDb9a0cBAjcUAtnOZGttbgEwG1q4wTScDzHkoLfw4BLx1CAm+smBQz1t3XYa6VQJQE4XjGdhrmNVcDSR+FA33BkIRnG9RSejxuNLCTxO/y23uzNtAAXDshCavld5rfm4dhFABhr52FG7wY2Y826wnkUsLX39aaTPHY3HD+VBHoG237tE3jHNTehv6YBzzOmvUwuIL7Y9AK2jjLt5gRSe1wT482uABq7vm34cS8QLzTs8jt5wE/lRzjjQLjIN+pmLgG4jQyFtDYgssE15q4fABjTMtR+T1ReCDXy+eZKAWCY1lfX+hE/sHn8b5nLxkFuHLR+ahOf5/5xmYXKUdX1MfR66gKw9f7vwz2+SAIY62do9rwqp8/XuT+yhakVP2B4o2Xo9titAQLLlUWOf+iEtz6TjwJwOM0M7Ux2C4BofOqYlWwF5WK75+Uqa/AOMCqkfzmsARA+2p/NrgmiV01Y3Dm7jSf8ADS2SROjTkan9IgfSGwdXt0Wb4rnFwfLkShwzzq1jHrpnMNW/J7f4+0zMupmejUybNHUq9Yer7PfzHQgU3+f3T1mG+odsrncI6ODOj3TufRmk9FoNJn1TLdu3bp169atW4v9AFywUc+44QzMAAAAAElFTkSuQmCC'),

      // 左三角形64 * 64
      TL: b64t('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAAzUlEQVR4nO3Q2w2EMBBD0ZRMJ5Ts/UJCiEcSSLyauacC+5YCAAAAAADwRyQt7g02khZJcu+w2M6nDLA/ny7A8XyqAGfn0wS4Op8iwN358AGezocOUHM+bIDa8yEDtJwPF6D1fKgAPefDBOg9HyLAm/NRAqypA5TyLoJ7+2d6I7h3f6ongnvz51ojuPcO0RLBvXWY2gjunUPVRHBvHO4pgnvfFHcR3NumuYrg3jXVWQT3pumOEdx7LPYR3FtstgjuHVaSVvcGAAAAAAAQzw/EKywNEzzYSAAAAABJRU5ErkJggg=='),
    });

    const WIND = ['East', 'South', 'West', 'North'], ACTION = ['Chow', 'Pung', 'Kong', 'Hu', 'Flower', 'Pass', 'Waive'];

    console.log('PIXI.utils.isMobile', PIXI.utils.isMobile);
    var tz = {
      app: null,
      ws: null,
      res: null,
      phn: false,
      tpvw: null,  // 顶层结点
      game: null,  // 游戏
      lobby: null,  // 大厅
      tlscp: 0,  // 牌面上角标
      piano: 0,  // 钢琴键：0自动 1三格 2两格
      hbt: 0,  // 心跳包
      wall: true,  // 显示牌墙
      ffs: 24,  // 番种字体的尺寸（英文的番种名很长，需要小一号）

      cfg: {},  // 所有本地存储的数据
      ltrl: {},  // 语言文本

      /**
       * 加载配置
       */
      load: function() {
        this.cfg = JSON.parse(localStorage.getItem('game_data')) || {};
      },

      /**
       * 保存配置
       */
      save: function() {
        localStorage.setItem('game_data', JSON.stringify(this.cfg));
      },

      /**
       * 本地格式化字符串
       * @param {string} f 索引
       */
      ls: function(f) {
        let a = arguments;
        let s = this.ltrl[f] || f;
        return a.length === 1 ? s : s.replace(/\{(\d+)\}/g, (m, i)=>a[i]);
      },

      /**
       * 提示数据不同步（以前的版本是直接重新加载页面，但效果不好）
       */
      reenter: function() {
        this.tpvw.err(this.ls('NotSynchronized'), true);
        //this.ws.send('{"m":4}');
      },

      /**
       * 播放音乐
       * @param {string} s 音乐文件名
       */
      play: function(s) {
        try {
          this.res[s].sound.play();
        } catch (e) {
          console.log(e);
        }
      },

      /**
       * 开始加载
       */
      strt_load: function() {
        // 显示牌墙：0自动 1有 2无
        // 自动：手机不显示，PC、平板显示
        this.phn = false;
        //this.phn = PIXI.utils.isMobile.phone;
        let sw = this.cfg['wall'];
        if (typeof sw !== 'number') sw = 0;

        // 手机
        if (this.phn) {
          // 牌墙
          this.wall = (sw === 1);

          // 钢琴键
          let pt = this.cfg['piano'];
          this.piano = (typeof pt === 'number') ? pt : 0;
        } else {
          // 牌墙
          this.wall = (sw !== 2);
        }

        // 音量
        let v = this.cfg['volume'];
        PIXI.sound.volumeAll = (typeof v === 'number') ? Math.max(0, Math.min(100, v)) / 100 : 1;

        // 加载进度显示
        let t = new PIXI.Text('0%', {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        this.app.stage.addChild(t);
        t.anchor.set(.5);

        // 适配
        let layt = ()=>{
          t.x = window.innerWidth * .5;
          t.y = window.innerHeight * .5;
          t.scale.set(Math.min(window.innerWidth / 680, window.innerHeight / 700));
        };
        layt();
        window.onresize = ()=>{
          this.app.renderer.resize(window.innerWidth, window.innerHeight);
          layt();
        };

        //PIXI.loader.add([  // v4.x
        PIXI.Loader.shared.add([  // v5.x
          'img/tiles/standing1.png',
          'img/tiles/standing3.png',
          'img/tiles/pool0.png',
          'img/tiles/pool1.png',
          'img/tiles/pool2.png',
          'img/tiles/pool3.png',
          'img/tiles/standing0.png',

          'img/dice/1.png',
          'img/dice/2.png',
          'img/dice/3.png',
          'img/dice/4.png',
          'img/dice/5.png',
          'img/dice/6.png',

          'fnt/shsb.png',
          'fnt/shsb.fnt',

          'snd/01-start.wav',
          'snd/02-dice.wav',
          'snd/03-cd.wav',
          'snd/05-draw.wav',
          'snd/06-discard.wav',
          'snd/08-inquire.wav',
          'snd/09-cpk.wav',
          //'snd/10-win.wav',
          'snd/12-flower-m.wav',
          'snd/13-flower-f.wav',
          'snd/14-chow-m.wav',
          'snd/15-chow-f.wav',
          'snd/16-pung-m.wav',
          'snd/17-pung-f.wav',
          'snd/18-kong-m.wav',
          'snd/19-kong-f.wav',
          'snd/20-win-m.wav',
          'snd/21-win-f.wav',
          'snd/25-xchg.wav'
        ])
        .load(()=>{
          t.dsty();

          // 标记一些资源
          //let r = this.res = PIXI.loader.resources;  // v4.x
          let r = this.res = PIXI.Loader.shared.resources;  // v5.x
          StTl.tx0 = r['img/tiles/standing0.png'].texture;
          StTl.tx1 = r['img/tiles/standing1.png'].texture;
          StTl.tx3 = r['img/tiles/standing3.png'].texture;
          PlTl.tx0 = r['img/tiles/pool0.png'].texture;
          PlTl.tx1 = r['img/tiles/pool1.png'].texture;
          PlTl.tx2 = r['img/tiles/pool2.png'].texture;
          PlTl.tx3 = r['img/tiles/pool3.png'].texture;

          this.strt_game();
        })
        .onProgress.add((e)=>{
          console.log('loading progress:',e.progress);
          t.text = e.progress.toFixed(2) + '%';
        });
      },

      /**
      * 开始游戏
      */
      strt_game: function(){
        let app = this.app;

        let gm = this.game = new Game();
        app.stage.addChild(gm);

        let lb = this.lobby = new Lobby();
        app.stage.addChild(lb);

        let tp = this.tpvw = new TpMst();
        app.stage.addChild(tp);

        //tp.visible = false;
        //lb.visible = false;
        gm.visible = false;

        let w = window.innerWidth, h = window.innerHeight;
        lb.layt(w, h);
        gm.layt(w, h);
        tp.layt(w, h);
        window.onresize = ()=>{
          let w = window.innerWidth, h = window.innerHeight;
          this.app.renderer.resize(w, h);
          this.lobby.layt(w, h);
          this.game.layt(w, h);
          this.tpvw.layt(w, h);
        };

        let ws = this.ws = new WebSocket('ws://127.0.0.1:5333/ws');
        ws.onopen = ()=>{
          console.log('open');
          // 测试直接创建桌子/坐下
          // let idx = location.search.substr(1);
          // if (idx == undefined) idx = 0;
          // if (idx == 0) {
          //   ws.send('{"m":1,"r":3}');
          // }
          // else {
          //   ws.send(`{"m":1,"r":4,"v":10001,"s":${idx}}`);
          // }
          // ws.send('{"m":1,"r":6}');
          ws.send(`{"m":5,"t":${new Date().getTime()}}`);
          ws.send('{"m":1,"r":2}');
          let f = false;
          let c = document.cookie;
          if (c) {
            let cs = c.split(';');
            for (let i = 0, l = cs.length; i < l; ++i) {
              let p = cs[i].trim().split('=');
              if (p[0] === '__p') {
                if (p.length > 1) {
                  ws.send(`{"m":1,"r":11,"t":"${p[1]}"}`);
                  f = true;
                }
                break;
              }
            }
          }
          this.lobby.tlr_ = f;  // 使用Token登录
          if (!f) {
            let un = this.cfg['username'], pw = this.cfg['token'];
            if (un && pw) {
              ws.send(`{"m":1,"r":12,"u":"${un}","p":"${pw}"}`);
            }
          }

          // 心跳包
          this.hbt = 0;
          setInterval(()=>{
            if (++this.hbt === 30) {
              this.hbt = 0;
              ws.send(`{"m":5,"t":${new Date().getTime()}}`);
            }
          }, 1000);
        };
        ws.onerror = (e)=>{
          this.tpvw.err(this.ls('NetworkError'), true);
          console.log('error',e);
        };
        ws.onclose = ()=>{
          console.log('close');
        };
        ws.onmessage = (p)=>{
          try {
            let r=JSON.parse(p.data);
            console.log(r);
            switch(r['m']) {
            case 1:
              this.lobby.onmsg(r);
              break;
            case 2:
              this.game.onmsg(r);
              break;
            case 3:
              this.lobby.visible = false;
              this.game.startup(r['s']);
              break;
            case 4:
              this.lobby.visible = false;
              this.game.reconn(r);
              break;
            case 5:
              this.lobby.echo(r);
              this.game.echo(r);
              break;
            }
          } catch (e) {
            console.log(e);
          }
          this.hbt = 0;
        };
      }
    };

    // =====================================================================================================
    // 通用控件

    /**
     * 复选框
     * @typedef {object} ChkBox
     */
    class ChkBox extends PIXI.Container {
      // tk_ = null;  // 勾号
      // fg_ = null;  // 高亮的前景
      // fa_ = null;  // 文本标签

      /**
       * @param {string} s 文本
       * @param {function(ChkBox):void} cb 回调
       */
      constructor(s, cb) {
        super();

        let b = new PIXI.Sprite(T64.CB);
        this.addChild(b);
        b.x = 5;

        let k = this.tk_ = new PIXI.Sprite(T64.TK);
        this.addChild(k);
        k.x = 5;
        k.visible = false;

        let w0, h0;
        if (s) {
          let t = this.fa_ = new PIXI.Text(s, {
            fontFamily: FF,
            fontSize: 30,
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3,
            lineJoin: 'round',
            padding: 10
          });
          this.addChild(t);
          t.x = b.width + 10;

          /*this.width =*/ w0 = b.width + 10 + t.width + 10;
          /*this.height =*/ h0 = Math.max(b.height, t.height) + 10;
          t.anchor.y = .5;
          t.y = h0 * .5;
        }
        else {
          /*this.width =*/ w0 = b.width + 10;
          /*this.height =*/ h0 = b.height + 10;
        }
        b.anchor.y = .5;
        k.anchor.y = .5;
        b.y = h0 * .5;
        k.y = h0 * .5;

        let fg = this.fg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        fg.alpha = .25;
        fg.width = w0;
        fg.height = h0;
        this.addChild(fg);
        fg.visible = false;

        let c = ()=>{
          let k = this.tk_;
          if (k.visible) {
            k.visible = false;
            if (this.fa_) {
              this.fa_.style.stroke = '#000000';
            }
          }
          else {
            k.visible = true;
            if (this.fa_) {
              this.fa_.style.stroke = '#0066ff';
            }
          }

          if (cb) {
            cb(this);
          }
        };

        let l = ()=>this.fg_.visible = true;
        let n = ()=>this.fg_.visible = false;

        this.interactive = true;
        this.on('click', c);
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('tap', c);
        this.on('touchstart', l);
        this.on('touchendoutside', n);
        this.on('touchend', n);
      }

      /**
       * 测试是否选中
       * @return {boolean} 是否选中
       */
      get sel() {
        return this.tk_.visible;
      }

      /**
       * 设置选中
       * @param {boolean} b 是否选中
       */
      set sel(b) {
        this.tk_.visible = b;
        if (this.fa_) {
          this.fa_.style.stroke = b ? '#0066ff' : '#000000';
        }
      }
    }

    /**
     * 管理互斥的一组checkbox
     * @typedef {object} RdoGrp
     */
    class RdoGrp {
      // cb_ = null;  // 各个checkbox

      constructor() {
        this.cb_ = [];
      }

      /**
       * 添加一个按钮
       * @param {object} cb 一个ChkBox
       */
      add(cb) {
        this.cb_.push(cb);
      }

      /**
       * 获取选中的下标
       * @return {number}
       */
      get idx() {
        return this.cb_.findIndex(e=>e.sel);
      }

      /**
       * 设置选中的下标
       * @param {number} n
       */
      set idx(n) {
        this.cb_.forEach((e, i)=>{
          e.sel = (n === i);
        });
      }
    }

    /**
     * 矩形空按钮
     * @typedef {object} EptBtn
     */
    class EptBtn extends PIXI.Container {
      // fg_ = null;  // 高亮的前景

      /**
       * @param {number} w 宽
       * @param {number} h 高
       * @param {function(EptBtn):void} cb 点击回调
       */
      constructor(w, h, cb) {
        super();

        //this.width = w;
        //this.height = h;

        let c = cb.bind(this, this);
        let l = ()=>this.fg_.visible = true;
        let n = ()=>this.fg_.visible = false;

        let b = new PIXI.Sprite(PIXI.Texture.WHITE);
        b.tint = 0;
        b.alpha = .25;
        b.width = w;
        b.height = h;
        this.addChild(b);

        let f = this.fg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        f.alpha = .25;
        f.width = w;
        f.height = h;
        this.addChild(f);
        f.visible = false;

        this.interactive = true;
        this.on('click', c);
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('tap', c);
        this.on('touchstart', l);
        this.on('touchendoutside', n);
        this.on('touchend', n);
      }
    }

    /**
     * 文本按钮
     * @typedef {object} TxtBtn
     */
    class TxtBtn extends EptBtn {
      // fa_ = null;  // 按钮上的文本标签

      /**
       * @param {string} t 文本
       * @param {object} s 文本样式
       * @param {number} w 宽
       * @param {number} h 高
       * @param {function(TxtBtn):void} cb 回调
       */
      constructor(t, s, w, h, cb) {
        super(w, h, cb);

        let f = this.fa_ = new PIXI.Text(t, s);
        f.anchor.set(.5);
        f.x = w * .5;
        f.y = h * .5;
        this.addChild(f);
      }
    }

    /**
     * 带边缘的按钮
     * @typedef {object} EdgBtn
     */
    class EdgBtn extends PIXI.Container {
      // fg_ = null;  // 高亮的前景

      /**
       * @param {number} w 宽
       * @param {number} h 高
       * @param {function(EdgBtn):void} cb 点击回调
       */
      constructor(w, h, cb) {
        super();

        //this.width = w;
        //this.height = h;

        this.cb_ = cb;
        let c = ()=>this.cb_(this);
        let l = ()=>this.fg_.visible = true;
        let n = ()=>this.fg_.visible = false;

        let b = this.bg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        b.tint = 0;
        b.alpha = .75;
        b.width = w;
        b.height = h;
        this.addChild(b);

        let f = this.fg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        f.alpha = .25;
        f.width = w;
        f.height = h;
        this.addChild(f);
        f.visible = false;

        // 黑色边框
        let cvs = document.createElement('canvas');
        cvs.width = w;
        cvs.height = h;
        let ctx = cvs.getContext('2d');
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.strokeStyle = '#808080';
        ctx.rect(0, 0, w, h);
        ctx.stroke();
        ctx.closePath();
        let s = new PIXI.Sprite(PIXI.Texture.from(cvs));
        //s.alpha = .5;
        this.addChild(s);

        this.interactive = true;
        this.on('click', c);
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('tap', c);
        this.on('touchstart', l);
        this.on('touchendoutside', n);
        this.on('touchend', n);
      }

      /**
       * 设置点击回调
       * @param {function(EdgBtn):void} cb 点击回调
       */
      setcb(cb) {
        this.cb_ = cb;
      }
    }

    /**
     * 大尺寸复选框
     * @typedef {object} ChkBoxL
     */
    class ChkBoxL extends PIXI.Container {
      // tk_ = null;  // 勾号
      // fa_ = null;  // 文本标签

      /**
       * @param {number} w 宽度
       * @param {number} h 高度
       * @param {string} s 文本
       * @param {function(ChkBoxL):void} cb 回调
       */
      constructor(w, h, s, cb) {
        super();

        let p = new EdgBtn(w, h, this._c.bind(this, cb));
        this.addChild(p);

        //let b = new PIXI.Sprite(PIXI.Texture.WHITE);
        //b.tint = 0;
        //b.alpha = .35;
        //b.width = w;
        //b.height = h;
        //this.addChild(b);

        let b = new PIXI.Sprite(T64.CB);
        this.addChild(b);

        let k = this.tk_ = new PIXI.Sprite(T64.TK);
        this.addChild(k);
        k.visible = false;

        if (s) {
          let t = this.fa_ = new PIXI.Text(s, {
            fontFamily: FF,
            fontSize: 30,
            fill: '#ffffff',
            stroke: '#000000',
            strokeThickness: 3,
            lineJoin: 'round',
            padding: 10
          });
          this.addChild(t);

          // 框与左边5像素，中间框与文本之间5像素，文本与右边5像素
          let w1 = b.width, w2 = t.width;
          let gp = w - w1 - 15;
          if (gp >= w2) {
            let a = (w - w1 - 5 - w2) / 2;
            b.x = k.x = a;
            t.x = a + w1 + 5;
          }
          else {
            b.x = k.x = 5;
            t.x = w1 + 10;
            t.scale.set(gp / w2);
          }

          t.anchor.y = .5;
          t.y = h * .5;
        }
        else {
          b.x = w * .5;
          k.x = w * .5;
        }
        b.anchor.y = .5;
        k.anchor.y = .5;
        b.y = h * .5;
        k.y = h * .5;
      }

      /**
       * 测试是否选中
       * @return {boolean} 是否选中
       */
      get sel() {
        return this.tk_.visible;
      }

      /**
       * 设置是否选中
       * @return {boolean} 是否选中
       */
      set sel(b) {
        this.tk_.visible = b;
        if (this.fa_) {
          this.fa_.style.stroke = b ? '#0066ff' : '#000000';
        }
      }

      _c(cb) {
        let k = this.tk_;
        if (k.visible) {
          k.visible = false;
          if (this.fa_) {
            this.fa_.style.stroke = '#000000';
          }
        }
        else {
          k.visible = true;
          if (this.fa_) {
            this.fa_.style.stroke = '#0066ff';
          }
        }

        if (cb) {
          cb(this);
        }
      }
    }

    /**
     * 滑动控制条
     * @typedef {object} RngBr
     */
    class RngBr extends PIXI.Container {
      // val_ = 0;  // 值（0-100）
      // thmb_ = null;  // 滑块
      // l_ = 0;  // 滑块可到达的最小横坐标
      // r_ = 0;  // 滑块可到达的最大横坐标
      // drag_ = false;  // 正在拖动

      /**
       * @param {number} w 总体宽度
       * @param {number} h0 滑块高度
       * @param {number} h1 滑条高度
       * @param {function(number):void} cb 回调
       */
      constructor(w, h0, h1, cb) {
        super();

        //this.width = w;
        //this.height = h0;

        this.l_ = h0 * .5 - 3;
        this.r_ = w - h0 * .5 + 3;

        let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
        this.addChild(bg);

        bg.alpha = .5;
        bg.width = w;
        bg.height = h1;
        bg.y = (h0 - h1) * .5;

        let t = this.thmb_ = new PIXI.Sprite(T64.CY);
        this.addChild(t);
        t.scale.set(h0 / 128);
        t.anchor.set(.5);
        t.x = t.y = h0 * .5;

        this.drag_ = false;
        let c = (g)=>{
          let p = this.toLocal(g);
          let v0 = this.l_, v1 = this.r_;
          let vx = Math.max(v0, Math.min(v1, p.x));
          this.thmb_.x = vx;
          this.val_ = (vx - v0) * 100 / (v1 - v0);
          cb(this.val_);
        };

        t.interactive = true;
        t.on('pointerdown', ()=>{ this.drag_ = true; });
        t.on('pointerup', ()=>{ this.drag_ = false; });
        t.on('pointerupoutside', ()=>{ this.drag_ = false; });
        t.on('pointermove', (e)=>{
          if (this.drag_) c(e.data.global);
        });

        bg.interactive = true;
        bg.on('click', (e)=>{
          if (!this.drag_) c(e.data.global);
        });
        bg.on('tap', (e)=>{
          if (!this.drag_) c(e.data.global);
        });
      }

      /**
       * 设置值
       * @param {number} v 值[0-100]
       */
      set val(v) {
        this.val_ = v;
        this.thmb_.x = this.l_ + (this.r_ - this.l_) * v / 100;
      }

      /**
       * 获取值
       * @return {number} [0-100]
       */
      get val() {
        return this.val_;
      }
    }


    /**
     * 监听鼠标或移动端点击移入移出的按钮
     * @typedef {object} HvrBtn
     */
    class HvrBtn extends PIXI.Container {
      // cb_ = null;  // 回调函数

      /**
       * @param {number} w 宽
       * @param {number} h 高
       * @param {function(object,boolean):void} cb 回调
       */
      constructor(w, h, cb) {
        super();

        //this.width = w;
        //this.height = h;

        this.cb_ = cb;

        let l = ()=>{ this.fg_.visible = true; this.cb_(this, true); };
        let n = ()=>{ this.fg_.visible = false; this.cb_(this, false); };

        let b = new PIXI.Sprite(PIXI.Texture.WHITE);
        b.tint = 0;
        b.alpha = .25;
        b.width = w;
        b.height = h;
        this.addChild(b);

        let f = this.fg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        f.alpha = .25;
        f.width = w;
        f.height = h;
        this.addChild(f);
        f.visible = false;

        this.interactive = true;
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('touchstart', l);
        this.on('touchendoutside', n);
        this.on('touchend', n);
      }
    }

    // =====================================================================================================
    // 子元素、界面

    /**
     * 点击外部关闭的弹窗
     * @typedef {object} AutoHide
     */
    class AutoHide extends PIXI.Container {
      // lsn_ = null;  // 透明底版，适配全屏

      constructor() {
        super();

        let c = this.lsn_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        c.tint = 0;
        c.alpha = .2;
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        this.addChild(c);
        c.interactive = true;
        c.on('click', this.tapout.bind(this));
        c.on('tap', this.tapout.bind(this));
      }

      /**
       * 点击外部
       */
      tapout() {
        this.visible = false;
      }

      /**
       * 适配
       */
      layt() {
        let c = this.lsn_;
        c.width = window.innerWidth;
        c.height = window.innerHeight;
      }
    }

    /**
     * 点击外部隐藏，松开恢复的弹窗
     * @typedef {object} AutoTgl
     */
    class AutoTgl extends PIXI.Container {
      // lsn_ = null;  // 透明底版，适配全屏

      constructor() {
        super();

        let c = this.lsn_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        c.tint = 0;
        c.alpha = .2;
        c.width = window.innerWidth;
        c.height = window.innerHeight;
        this.addChild(c);
        c.interactive = true;
        c.on('pointerdown', this.outdown.bind(this));
        c.on('pointerup', this.outup.bind(this));
        c.on('pointerupoutside', this.outup.bind(this));
      }

      /**
       * 外部按下，由子类自己实现
       */
      outdown() {
      }

      /**
       * 外部松开，由子类自己实现
       */
      outup() {
      }

      /**
       * 适配
       */
      layt() {
        let c = this.lsn_;
        c.width = window.innerWidth;
        c.height = window.innerHeight;
      }
    }

    /**
     * 换风提示
     * @typedef {object} XchgRd
     */
    class XchgRd extends AutoHide {
      /**
       * @param {number} w 风
       * @param {array} n 玩家昵称
       * @param {array} s 玩家分数
       */
      constructor(w, n, s) {
        super();

        let c = this.ic_ = new PIXI.Graphics();
        this.addChild(c);

        c.lineStyle(2, 0x26608C, 1);
        c.beginFill(0x060F16, .85);
        c.drawRect(0, 0, XchgRd.W, XchgRd.H);
        c.endFill();

        let t = new PIXI.Text(tz.ls('Round' + WIND[w]), {
          fontFamily: FF,
          fontSize: 128,
          fill: '#ffffff',
          fontWeight:'bold',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.set(.5);
        t.x = XchgRd.W * .5;
        t.y = XchgRd.H * .5;
        c.addChild(t);
        scl_txt(t, XchgRd.W * .95);

        // 玩家昵称

      }

      /**
       * 点击外部，覆盖，实现不可点击
       */
      tapout() {
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        super.layt();
        const w0 = XchgRd.W, h0 = XchgRd.H, s0 = XchgRd.S;
        let c = this.ic_, s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale XchgRd =', s);
      }
    }
    XchgRd.W = 500;
    XchgRd.H = 400;
    XchgRd.S = .75;

    /**
     * 倒计时
     * @typedef {object} CD
     */
    class CD extends PIXI.Container {
      constructor() {
        super();

        let b = new PIXI.Sprite(T64.CY);
        b.tint = 0;
        b.alpha = .5;
        b.width = b.height = CD.R;
        this.addChild(b);

        let t = this.t_ = new PIXI.Text('', {
          fontFamily: FF,
          fontSize: 32,
          fill: '#dedede',
          stroke: '#000000',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.set(.5);
        this.addChild(t);
        t.x = t.y = CD.R * .5;
      }

      /**
       * 设置读秒
       * @param {number} 秒数
       */
      setup(s) {
        let h = this.h_;
        if (h) {
          clearInterval(h);
          this.h_ = null;
        }

        this.t_.text = s;
        this.f_ = s;
        this.e_ = new Date().getTime() + s * 1000;
        this.h_ = setInterval(()=>{
          let n = this.e_ - new Date().getTime();
          let s = Math.round(n / 1000);
          if (s > 0) {
            if (s !== this.f_) {
              this.f_ = s;
              this.t_.text = s;
              if (!tz.cfg['mutecd'] && s <= 3) {
                tz.play('snd/03-cd.wav');
              }
            }
          }
          else {
            this.t_.text = '0';
            clearInterval(this.h_);
            this.h_ = null;
            this.visible = false;
          }
        }, 100);
        this.visible = true;
      }

      /**
       * 移除读秒
       */
      rm() {
        let h = this.h_;
        if (h) {
          clearInterval(h);
          this.h_ = 0;
        }
        this.visible = false;
      }
    }
    CD.R = 80;

    /**
     * 鸣牌按钮
     * @typedef {object} CalBtn
     */
    class CalBtn extends PIXI.Container {
      // bg_ = null;  // 背景
      // fg_ = null;  // 前景
      // fa_ = null;  // 文本标签
      // cb_ = null;  // 回调

      constructor() {
        super();

        //this.width = 150;
        //this.height = 150;

        let c = ()=>this.cb_(this);
        let l = ()=>this.fg_.visible = true;
        let n = ()=>this.fg_.visible = false;

        let bg = this.bg_ = new PIXI.Sprite(T64.CY);
        bg.alpha = .25;
        bg.width = bg.height = 150;
        this.addChild(bg);

        let fg = this.fg_ = new PIXI.Sprite(T64.CY);
        fg.alpha = .25;
        fg.width = fg.height = 150;
        this.addChild(fg);
        fg.visible = false;

        let f = this.fa_ = new PIXI.Text('', {
          fontFamily: 'sans-serif',
          fontSize: 64,
          fontWeight: 'bold',
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 5,
          lineJoin: 'round',
          dropShadow: true,
          dropShadowColor: '#000000',
          //dropShadowAngle: Math.PI / 6,
          dropShadowDistance: 8,
          padding: 10
        });
        f.anchor.set(.5);
        f.x = f.y = 75;
        this.addChild(f);
        //scl_txt(f, CalBtn.W - 10);

        this.interactive = true;
        this.on('click', c);
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('tap', c);
        this.on('touchstart', l);
        this.on('touchendoutside', n);
        this.on('touchend', n);
      }

      /**
       * 设置
       * @param {number} i ACTION数组中的索引
       * @param {function(CalBtn):void} cb 点击回调
       */
      setup(i, cb) {
        this.fa_.text = tz.ls(ACTION[i]);
        scl_txt(this.fa_, CalBtn.W - 10);
        this.cb_ = cb;

        // 6弃，显示为绿色，3和，显示为红色
        this.bg_.tint = (i !== 6 ? (i !== 3 ? 0 : 0xff6a6a) : 0x00cd66);
      }
    }
    CalBtn.W = 150;
    CalBtn.H = 150;

    /**
     * 鸣牌按钮组（PC、平板）
     * @typedef {object} CalCtn
     */
    class CalCtn extends PIXI.Container {
      // cb_ = null;  // 回调

      constructor() {
        super();

        // 吃碰杠和花过弃按钮，最多同时亮5个，预留6个位（吃碰杠和过弃）
        let cb = new Array(6);
        for (let i = 0; i < 6; ++i) {
            let c = cb[i] = new CalBtn();
            this.addChild(c);
            c.x = i * 190;
            //c.visible = false;
        }
        this.cb_ = cb.reverse();  // 反向排列

        // let g = new PIXI.Graphics();
        // g.lineStyle(2, 0x0000FF, 1);
        // g.beginFill(0x0000BB, .25);
        // g.drawRect(0, 0, CalCtn.W, CalCtn.H);
        // g.endFill();
        // this.addChild(g);
      }

      /**
       * 初始化
       */
      init() {
        this.cb_.forEach(e=>e.visible = false);
      }

      /**
       * 设置
       * @param {number} i 第几个按钮
       * @param {number} k 第几种动作
       * @param {funtion():void} cb 回调
       */
      setup(i, k, cb) {
        let b = this.cb_[i];
        b.setup(k, cb);
        b.visible = true;
      }

      /**
       * 隐藏
       * @param {number} i 第几个按钮
       */
      hide(i) {
        this.cb_[i].visible = false;
      }

      /*
       * 适配
       * @param {number} w 允许宽度
       * @param {number} h 允许高度
       */
      layt(w, h) {
        // 左右各120
        this.x = 120;
        let s = (w - 240) / CalCtn.W;
        this.y = h - 20 - (CalCtn.H * s);
        this.scale.set((w - 240) / CalCtn.W);
      }
    }
    CalCtn.W = 190 * 5 + CalBtn.W;
    CalCtn.H = CalBtn.H;

    /**
     * 鸣牌按钮组（手机）
     * @typedef {object} CalPop
     */
    class CalPop extends PIXI.Container {
      // cg_ = null;  // 按钮组
      // sh_ = false;  // 是否打开
      // b_ = null;  // 开关按钮

      constructor() {
        super();

        // 可被折叠的根结点
        let r = this.r_ = new PIXI.Container();
        this.addChild(r);

        let cg = new Array(6);
        const bs = {
          fontFamily: FF,
          fontSize: 30,
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        };

        // 排列方式：
        // 5 3 0
        // 4 2 1 >
        [
          {x:400,y:0},
          {x:400,y:160},
          {x:200,y:160},
          {x:200,y:0},
          {x:0,y:160},
          {x:0,y:0}
        ].forEach((e, i)=>{
          let c = cg[i] = new EdgBtn(200, 160, (e)=>{
            let cb = e.cb_;
            if (cb) cb();
          });
          r.addChild(c);
          c.position = e;
          c.visible = false;

          let t = new PIXI.Text(i, bs);
          c.addChild(t);
          t.anchor.set(.5);
          t.x = 100;
          t.y = 80;
          c.fa_ = t;
          scl_txt(t, 190);
        });
        this.cg_ = cg;
        this.sh_ = false;

        // 折叠/展开按钮
        let b = new EdgBtn(200, 160, ()=>this.tgl(!this.sh_));
        this.addChild(b);
        b.bg_.alpha = .25;
        b.x = 600;

        let p = this.tl_ = new PIXI.Sprite(T64.TL);
        b.addChild(p);
        p.anchor.set(.5);
        p.x = 100;
        p.y = 80;

        let t1 = new TWEEN.Tween(p).to({alpha:.6}, 1000),
          t2 = new TWEEN.Tween(p).to({alpha:1}, 500);
        t1.chain(t2);
        t2.chain(t1);
        t1.start();

        // 指示文本
        let s = this.s_ = new PIXI.Text('', {
          fontFamily: FF,
          fontSize: 24,
          fill: '#dedede',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        this.addChild(s);
        s.anchor.x = 1;
        s.x = CalPop.W - 210;
        s.y = 130;
      }

      /**
       * 切换
       * @param {boolean} 状态
       */
      tgl(s) {
        if (this.sh_ !== s) {
          this.sh_ = s;
          this.r_.visible = s;
          this.tl_.rotation = s ? Math.PI : 0;
          this.s_.visible = !s;
        }
      }

      /**
       * 当前是否可用
       * @return {boolean}
       */
      ac() {
        return this.visible && this.sh_;
      }

      /**
       * 初始化
       */
      init() {
        this.cg_.forEach(e=>e.visible = false);
      }

      /**
       * 设置
       * @param {number} i 第几个按钮
       * @param {number} k 第几种动作
       * @param {funtion():void} cb 回调
       */
      setup(i, k, cb) {
        let c = this.cg_[i];

        c.cb_ = cb;
        c.fa_.text = tz.ls(ACTION[k]);
        scl_txt(c.fa_, 180);

        // 6弃，显示为绿色，3和，显示为红色
        c.bg_.tint = (k !== 6 ? (k !== 3 ? 0 : 0xff6a6a) : 0x00cd66);
        c.visible = true;
        c.ai_ = k;
      }

      /**
       * 隐藏
       * @param {number} i 第几个按钮
       */
      hide(i) {
        this.cg_[i].visible = false;
      }

      /**
       * 提交设置，以完成小文本更新
       */
      commit() {
        let s = '';
        this.cg_.forEach(e=>{
          if (e.visible) {
            let a = e.ai_;
            if (typeof a === 'number' && a < 5) {
              s += tz.ls(ACTION[a]);
              s += ' / ';
            }
          }
        });
        //console.log('commit s', s);
        this.s_.text = (s.length > 3) ? s.substr(0, s.length - 3) : '';
      }
    }
    // 2行4列，每个200*160
    CalPop.W = 800;
    CalPop.H = 320;

    /**
     * 鸣牌选择界面
     * @typedef {object} CalSel
     */
    class CalSel extends PIXI.Container {
      constructor() {
        super();

        let r = this.r_ = new PIXI.Container();
        this.addChild(r);

        // 最多也就三种杠法或三种吃法+一个取消+折叠，共5个键
        // 每个跟另外三个界面一样，每个尺寸200*160
        // 排列方式：
        // 1 2 3 x >
        // 设置的时候倒序
        let cg = new Array(4);
        [
          {x:0,y:0},
          {x:200,y:0},
          {x:400,y:0},
          {x:600,y:0}
        ].forEach((e, i)=>{
          let c = cg[i] = new EdgBtn(200, 160);
          r.addChild(c);
          c.position = e;
          //c.visible = false;
        });
        this.cg_ = cg;
        //this.cr_.visible = false;

        // 最后一个是取消
        let c = cg[3];
        let f = new PIXI.Text('\u00D7', {
          fontFamily: FF,
          fontSize: 30,
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        c.addChild(f);
        f.anchor.set(.5);
        f.x = 100;
        f.y = 80;

        // 折叠/展开按钮
        let b = new EdgBtn(200, 160, ()=>this.tgl(!this.r_.visible));
        this.addChild(b);
        b.bg_.alpha = .25;
        b.x = 800;

        let p = this.tl_ = new PIXI.Sprite(T64.TL);
        b.addChild(p);
        p.anchor.set(.5);
        p.x = 100;
        p.y = 80;

        let t1 = new TWEEN.Tween(p).to({alpha:.6}, 1000),
          t2 = new TWEEN.Tween(p).to({alpha:1}, 500);
        t1.chain(t2);
        t2.chain(t1);
        t1.start();
      }

      /**
       * 切换
       * @param {boolean} 状态
       */
      tgl(s) {
        if (this.r_.visible !== s) {
          this.r_.visible = s;
          this.tl_.rotation = s ? Math.PI : 0;
        }
      }

      /**
       * 设置
       * @param {number} t 鸣牌类型，吃=3，杠=5
       * @param {array} a 可选择的鸣牌
       * @param {function(number):void} cb 回调
       */
      setup(t, a, cb) {
        this.visible = true;
        this.tgl(true);

        const bs = {
          fontFamily: FF,
          fontSize: 30,
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        };

        // 反向布局，从3-l起
        let l = a.length, o = 3 - l, cg = this.cg_;
        for (let i = 0; i < o; ++i) {
          cg[i].visible = false;
        }
        for (let i = 0; i < l; ++i) {
          let e = a[i], b = cg[o + i];
          b.visible = true;

          b.setcb(function(e, cb){ cb(e); }.bind(this, e, cb));

          // 清除旧内容
          let c = b.ctn_;
          if (c) c.dsty();

          // 创建新内容
          b.ctn_ = c = new PIXI.Container();
          b.addChild(c);

          // 按钮上的内容
          switch (t) {
            case 3: {
              let f = new PIXI.Text(tz.ls('Chow'), bs);
              c.addChild(f);
              f.anchor.set(.5);
              f.x = 100;
              f.y = 35;

              let t = new StTl(hibyte(e));
              c.addChild(t);
              t.x = 100 - W0;
              t.y = 135 - H0F;

              t = new StTl(lobyte(e));
              c.addChild(t);
              t.x = 100;
              t.y = 135 - H0F;
              break;
            }
            case 5: {
              let f = new PIXI.Text(tz.ls('Kong'), bs);
              c.addChild(f);
              f.anchor.set(.5);
              f.x = 100;
              f.y = 35;

              let t = new StTl(lobyte(e));
              c.addChild(t);
              t.x = 100 - W0 * .5;
              t.y = 135 - H0F;
              break;
            }
          }
        }
        // 最后一个取消
        cg[3].setcb(()=>cb());
      }

      /*
       * 适配（用于PC、平板）
       * @param {number} w 允许宽度
       * @param {number} h 允许高度
       */
      layt(w, h) {
        // 左右各120
        this.x = w - CalSel.W;
        this.y = h - 180 - CalSel.H;
      }
    }
    CalSel.W = 1000;
    CalSel.H = 160;

    /**
     * 下方的菜单
     * @typedef {object} OptGrp
     */
    class OptGrp extends PIXI.Container {
      // cg_ = null;  // 按钮组

      constructor() {
        super();

        let cg = new Array(7);
        ['AutoFlower', 'NoChow', 'NoPung', 'NoKong', 'SelfDrawnOnly', 'AutoHu', 'AutoDiscard']
        .forEach((e, i)=>{
          let c = cg[i] = new ChkBox(tz.ls(e));
          this.addChild(c);
          c.x = 200 * i;
        });
        this.cg_ = cg;
/*
        // 位置测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, 150, 40);
        g.endFill();
        this.addChild(g);
*/
        OptGrp.H = this.height;
        OptGrp.W = this.width;
      }

      /**
       * 初始化，勾选自动补花
       */
      init() {
        this.cg_.forEach((e, i)=>e.sel = (i === 0));
      }

      /**
       * 获取按钮状态
       */
      opt() {
        let o = 0;
        this.cg_.forEach((e, i)=>o |= (Number(e.sel) << i));
        return o;
      }
    }

    /**
     * 弹出式菜单
     * @typedef {object} OptPop
     */
    class OptPop extends PIXI.Container {
      // cg_ = null;  // 按钮组
      // sh_ = false;  // 是否打开
      // b_ = null;  // 开关按钮

      /**
       * 切换的回调
       * 由于本界面跟鸣牌有重叠，所以要相互关闭
       * @param {function(OptPop,boolean):void}
       */
      constructor(cb) {
        super();

        this.cb_ = cb;

        // 可被折叠的根结点
        let r = this.r_ = new PIXI.Container();
        this.addChild(r);

        // 折叠后小文本的根结点
        let s = this.s_ = new PIXI.Container();
        this.addChild(s);

        const bs = {
          fontFamily: FF,
          fontSize: 24,
          fill: '#dedede',
          stroke: '#000000',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        };

        // 排列方式：
        //      自摸 和牌 摸打
        // 补花 不吃 不碰 不杠  >
        let cg = new Array(7);
        [
          {f:'AutoFlower', p:{x:0,y:160}},
          {f:'NoChow', p:{x:200,y:160}},
          {f:'NoPung', p:{x:400,y:160}},
          {f:'NoKong', p:{x:600,y:160}},
          {f:'SelfDrawnOnly', p:{x:200,y:0}},
          {f:'AutoHu', p:{x:400,y:0}},
          {f:'AutoDiscard', p:{x:600,y:0}}
        ].forEach((e, i)=>{
          let c = cg[i] = new ChkBoxL(200, 160, tz.ls(e['f']), c=>c.v_ = c.sel);
          r.addChild(c);
          c.position = e['p'];
        });
        this.cg_ = cg;
        this.sh_ = false;

        // 折起来之后的小文字
        // 排两行
        let st = new Array(7), x = 0;
        [
          'SelfDrawnOnly', 'AutoHu', 'AutoDiscard'
        ].forEach((e, i)=>{
          let t = st[4 + i] = new PIXI.Text('['+ tz.ls(e).replace(/\n/g, ' ') +']', bs);
          s.addChild(t);
          t.x = x;
          x += t.width + 10;
        });
        [
          'AutoFlower', 'NoChow', 'NoPung', 'NoKong'
        ].forEach((e, i)=>{
          let t = st[i] = new PIXI.Text('['+ tz.ls(e).replace(/\n/g, ' ') +']', bs);
          s.addChild(t);
          t.x = x;
          t.y = 40;
          x += t.width + 10;
        });
        this.st_ = st;
        r.visible = false;

        (()=>{
          // 右对齐
          let w = s.width, w1 = st[3].x + st[3].width;
          if (w1 < w) {
            let d = w - w1;
            for (let i = 0; i < 4; ++i) {
              st[i].x += d;
            }
          }
          w1 = st[6].x + st[6].width;
          if (w1 < w) {
            let d = w - w1;
            for (let i = 4; i < 7; ++i) {
              st[i].x += d;
            }
          }
          s.pivot.x = w;
        })();
        s.x = OptPop.W - 210;  // 与按钮间隔10
        s.y = OptPop.H - 70;

        // 折叠/展开按钮
        let b = new EdgBtn(200, 160, ()=>this.tgl(!this.sh_));
        this.addChild(b);
        b.bg_.alpha = .25;
        b.x = 800;
        b.y = 160;

        let p = this.tl_ = new PIXI.Sprite(T64.TL);
        b.addChild(p);
        p.anchor.set(.5);
        p.x = 100;
        p.y = 80;

        let t1 = new TWEEN.Tween(p).to({alpha:.6}, 1000),
          t2 = new TWEEN.Tween(p).to({alpha:1}, 500);
        t1.chain(t2);
        t2.chain(t1);
        t1.start();
      }

      /**
       * 初始化，勾选自动补花
       */
      init() {
        this.cg_.forEach((e, i)=>e.v_ = e.sel = (i === 0));
        this.st_.forEach((e, i)=>e.style.stroke = (i !== 0) ? '#000000' : '#0066ff');
      }

      /**
       * 获取按钮状态
       */
      opt() {
        let o = 0;
        this.cg_.forEach((e, i)=>{ if (e.v_) o |= (1 << i); });
        return o;
      }

      /**
       * 切换
       * @param {boolean} 状态
       */
      tgl(s) {
        if (this.sh_ !== s) {
          this.sh_ = s;
          this.r_.visible = s;
          this.s_.visible = !s;
          this.tl_.rotation = s ? Math.PI : 0;
          if (!s) {
            this.cg_.forEach((e, i)=>this.st_[i].style.stroke = e.v_ ? '#0066ff' : '#000000');
          }
          this.cb_(this, s);
        }
      }

      /**
       * 是否打开
       * @return {boolean}
       */
      get xtd() {
        return this.sh_;
      }
    }
    // 2行5列，每个200*160
    OptPop.W = 1000;
    OptPop.H = 320;

    /**
     * 操作按钮基类
     * @typedef {object} HlpBs
     */
    class HlpBs extends PIXI.Container {
      constructor() {
        super();

        // 由子类自己addChild
        // 计时文本
        this.gt_ = new PIXI.Text('00:00', {
          fontFamily: FF,
          fontSize: 22,
          fill: '#dedede',
          padding: 10
        });

        // 测速文本
        this.ee_ = new PIXI.Text('0ms', {
          fontFamily: FF,
          fontSize: 22,
          fill: '#dedede',
          padding: 10
        });
      }

      /**
       * 开始计时
       * @param {number} 当前时间戳（服务器传过来）
       */
      strt(t) {
        if (this.tm_) {
          clearInterval(this.tm_);
        }
        this.st_ = t;
        this.tm_ = setInterval(()=>{
          let s = Math.floor((new Date().getTime() - this.st_) / 1000);
          let m = Math.floor(s / 60);
          s -= m * 60;
          this.gt_.text = `${pad2(m)}:${pad2(s)}`;
        });
      }

      /**
       * 停止计时
       */
      stop() {
        if (this.tm_) {
          clearInterval(this.tm_);
          this.tm_ = null;
        }
      }

      /**
       * 设置测速文本
       * @param {number} 时间戳（服务器原样传回来）
       */
      spd(t) {
        this.ee_.text = `${new Date().getTime() - t}ms`;
      }
    }

    /**
     * 弹出式操作按钮
     * @typedef {object} HlpPop
     */
    class HlpPop extends HlpBs {
      // cg_ = null;  // 按钮组
      // sh_ = false;  // 是否打开
      // b_ = null;  // 开关按钮

      /**
       * @param {object} p 代理onspd onchs oncal onset onhst
       */
      constructor(p) {
        super();

        // 排列方式：
        // 设置 计分  >
        // 测速 策略 鸣牌
        let cg = new Array(5);
        const bs = {
          fontFamily: FF,
          fontSize: 30,
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        };
        [
          {t:tz.ls('Speed'), p:{x:0,y:160}, f:'onspd'},
          {t:tz.ls('Chase'), p:{x:200,y:160}, f:'onchs'},
          {t:tz.ls('CallOpt'), p:{x:400,y:160}, f:'oncal'},
          {t:tz.ls('GameSetting'), p:{x:0,y:0}, f:'onset'},
          {t:tz.ls('History'), p:{x:200,y:0}, f:'onhst'}
        ].forEach((e, i)=>{
          let c = cg[i] = new EdgBtn(200, 160, (b)=>{
            // 先清除高亮，再回调，最后收起所有按钮
            b.fg_.visible = false;
            p[e['f']].call(p);
            this.tgl(false);
          });
          this.addChild(c);
          c.position = e['p'];
          c.visible = false;

          let t = new PIXI.Text(e['t'], bs);
          c.addChild(t);
          t.anchor.set(.5);
          t.x = 100;
          t.y = 80;
          scl_txt(t, 190);
        });
        this.cg_ = cg;
        this.sh_ = false;

        // 折叠/展开按钮
        let b = new EdgBtn(200, 160, ()=>this.tgl(!this.sh_));
        this.addChild(b);
        b.bg_.alpha = .25;
        b.x = 400;

        let s = this.tl_ = new PIXI.Sprite(T64.TL);
        b.addChild(s);
        s.anchor.set(.5);
        s.x = 100;
        s.y = 80;

        let t1 = new TWEEN.Tween(s).to({alpha:.6}, 1000),
          t2 = new TWEEN.Tween(s).to({alpha:1}, 500);
        t1.chain(t2);
        t2.chain(t1);
        t1.start();

        // 计时文本
        let t = this.gt_;
        b.addChild(t);
        t.anchor.set(.5);
        t.x = 100;
        t.y = 20;

        // 测速文本
        t = this.ee_;
        b.addChild(t);
        t.anchor.set(.5);
        t.x = 100;
        t.y = 140;
      }

      /**
       * 切换
       * @param {boolean} 状态
       */
      tgl(s) {
        if (this.sh_ !== s) {
          this.sh_ = s;
          this.cg_.forEach(e=>e.visible = s);
          this.tl_.rotation = s ? Math.PI : 0;
        }
      }

      /**
       * 是否打开
       * @return {boolean}
       */
      get xtd() {
        return this.sh_;
      }
    }
    // 2行3列，每个200*160
    HlpPop.W = 600;
    HlpPop.H = 320;

    /**
     * 操作按钮窗口
     * @typedef {object} HlpPop
     */
    class HlpCtn extends HlpBs {
      // btn_ = null;  // 按钮组

      /**
       * @param {object} p 代理onspd onchs oncal onset onhst
       */
      constructor(p) {
        super();

        const s = {
          fontFamily: FF,
          fontSize: 24,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        };
        let a = new Array(5);
        [
          {t:'Speed', f:'onspd'},
          {t:'Chase', f:'onchs'},
          {t:'CallOpt', f:'oncal'},
          {t:'GameSetting', f:'onset'},
          {t:'History', f:'onhst'}
        ].forEach((e, i)=>{
          let b = a[i] = new TxtBtn(tz.ls(e['t']), s, 120, 60, ()=>p[e['f']].call(p));
          this.addChild(b);
        });
        this.btn_ = a;

        // 计时文本
        let t = this.gt_;
        this.addChild(t);
        t.anchor.set(.5);

        // 测速文本
        t = this.ee_;
        this.addChild(t);
        t.anchor.set(.5);
      }

      /**
       * 适配
       * @param {number} w
       * @param {number} h
       */
      layt(w, h) {
        // 按钮120*60
        let a = this.btn_, t = this.ee_;
        a[0].x = w - 120;
        a[0].y = 50;
        a[1].y = h - 40;
        a[2].y = h - 40;
        a[2].x = w - 120;
        a[3].x = w - 120;
        a[3].y = 120;
        a[4].y = h - 110;

        // 速度
        t.x = w - 50;
        t.y = 30;

        // 计时
        t = this.gt_;
        t.x = w - 160;
        t.y = 80;
      }
    }

    /**
     * 中间面板
     * @typedef {object} CtrPnl
     */
    class CtrPnl extends PIXI.Container {
      // o_ = null;  // 当前打：X风X
      // r_ = null;  // 牌墙剩余
      // w_ = null;  // 四家门风及得分
      // v_ = 0;  // 我的门风（视角）
      // t_ = 0;  // 轮到谁

      constructor() {
        super();

        // 背景
        let b = new PIXI.Container();
        this.addChild(b);

        let s = new PIXI.Sprite(PIXI.Texture.WHITE);
        s.tint = 0;
        s.alpha = .5;
        s.width = 280;
        s.height = 220;
        b.addChild(s);

        // 前景，用来显示配置、分差
        let f = new PIXI.Container();
        this.addChild(f);
        f.visible = false;

        s = new PIXI.Sprite(PIXI.Texture.WHITE);
        s.tint = 0;
        s.alpha = .5;
        s.width = 280;
        s.height = 220;
        f.addChild(s);

        this.interactive = true;
        let l = ()=>{ f.visible = true; b.visible = false; };
        let n = ()=>{ f.visible = false; b.visible = true; };
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('touchstart', l);
        this.on('touchendoutside', n);
        this.on('touchend', n);

        // 当前打：X风X
        let t = this.o_ = new PIXI.Text('', {
          fontFamily: 'sans-serif',
          fontSize: 54,
          fontWeight: 'bold',
          fill: '#ffffff',
          stroke: '#808080',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.set(.5);
        t.x = 140;
        t.y = 85;//110 - 25;
        b.addChild(t);

        // 牌墙剩余
        t = this.r_ = new PIXI.Text('', {
          fontFamily: FF,
          fontSize: 26,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.set(.5);
        t.x = 140;
        t.y = 150;//110 + 40;
        b.addChild(t);
        this.rem_ = 0;

        // 四家门风及得分、分差
        let w = this.w_ = new Array(4);
        let d = this.d_ = new Array(4);
        [
          {p:{x:140, y:195}, r:0},  // y:220-25=195
          {p:{x:255, y:110}, r:(-Math.PI * .5)},  // x:280-25=255
          {p:{x:140, y:25}, r:Math.PI},
          {p:{x:25, y:110}, r:(Math.PI * .5)}
        ].forEach((e, i)=>{
          t = w[i] = new PIXI.Text('', {
            fontFamily: FF,
            fontSize: 32,
            fontWeight: 'bold',
            fill: '#888888',
            //stroke: '#0066ff',
            //strokeThickness: 2,
            //lineJoin: 'round',
            padding: 10
          });
          t.anchor.set(.5);
          b.addChild(t);
          t.position = e['p'];
          t.rotation = e['r'];

          t = d[i] = new PIXI.Text('', {
            fontFamily: FF,
            fontSize: 32,
            fontWeight: 'bold',
            fill: '#888888',
            //stroke: '#0066ff',
            //strokeThickness: 2,
            //lineJoin: 'round',
            padding: 10
          });
          t.anchor.set(.5);
          f.addChild(t);
          t.position = e['p'];
          t.rotation = e['r'];
        });
        this.v_ = 0;

        // 配置
        t = this.g_ = new PIXI.Text('', {
          fontFamily: FF,
          fontSize: 24,
          fill: '#dedede',
          //stroke: '#0066ff',
          //strokeThickness: 2,
          //lineJoin: 'round',
          lineHeight: 30,
          align: 'center',
          padding: 10
        });
        t.anchor.set(.5);
        f.addChild(t);
        t.x = 140;
        t.y = 110;

        // 范围测试
        // let g = new PIXI.Graphics();
        // g.lineStyle(2, 0x0000FF, 1);
        // g.beginFill(0xFF00BB, .25);
        // g.drawRect(0, 0, 280, 220);
        // g.endFill();
        // this.addChild(g);
      }

      /**
       * 初始化
       */
      init() {
        this.rem_ = 0;
        this.r_.text = '';
        this.o_.text = '';
        //this.w_.forEach(e=>e.text = '');
      }

      /**
       * 设置配置信息
       */
      cfg(g) {
        this.g_.text = `${tz.ls('XRounds', g['n'])} ${g['l']} (${g['b']})\n${g['r30']}/${g['r12']}s\n${tz.ls('Sabotage')} ${g['s']?'\u2713':'\u2715'}`;
      }

      /**
       * 设置牌墙剩余
       * @param {number} n 剩余数
       */
      set remain(n) {
        if (this.rem_ !== n) {
          this.rem_ = n;
          this.r_.text = `${tz.ls('Remains')} : ${n}`;
        }
      }

      /**
       * 获取牌墙剩余
       * @return {number}
       */
      get remain() {
        return this.rem_;
      }

      /**
       * 设置盘序
       * @param {number} o
       */
      order(o) {
        this.o_.text = tz.ls('Order' + o);
      }

      /**
       * 设置得分和风向
       * @param {number} v 我的座位
       * @param {array} s 分数
       */
      setup(v, s) {
        this.v_ = v;
        this.w_.forEach((e, i)=>{
          let k = (v + i) & 3;
          e.text = `${tz.ls(WIND[k])} ${s[i]}`;
        });
        let d = this.d_, o = s[0];
        d[0].text = `${tz.ls(WIND[v])} ${s[0]}`;
        for (let i = 1; i < 4; ++i) {
          let t = d[i], l = s[i] - o;
          t.text = l;
          t.style.fill = l > 0 ? '#ff6a6a' : (l < 0 ? '#5cdbd3' : '#888888');
        }
      }

      /**
       * 设置轮次
       * @param {number} t 轮到谁
       */
      set turn(t) {
        if (this.t_ !== t) {
          this.t_ = t;
          let n = (t + 4 - this.v_) & 3;
          this.w_.forEach((e, i)=>{
            e.style.fill = (i !== n) ? '#888888' : '#ff6a6a';
          });
        }
      }

      /**
       * 获取轮次
       * @param {number} t 轮到谁
       */
      get turn() {
        return this.t_;
      }

      /**
       * 是否轮到自己
       * @return {boolean}
       */
      self() {
        return this.t_ === this.v_;
      }

      /**
       * 获取门风
       */
      get seat() {
        return this.v_;
      }
    }
    CtrPnl.W = 280;
    CtrPnl.H = 220;

    /**
     * 桌面上玩完信息栏
     * @typedef {object} UsrBrf
     */
    class UsrBrf extends PIXI.Container {
      // l_ = null;  // 掉线
      // n_ = null;  // 昵称
      // f_ = null;  // 花牌数
      // w_ = null;  // 错和

      constructor() {
        super();

        const w = UsrBrf.W, h = UsrBrf.H;
        //this.width = w;
        //this.height = h;

        let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
        bg.tint = 0;
        bg.alpha = .25;
        bg.width = w;
        bg.height = h;
        this.addChild(bg);

        let t = this.l_ = new PIXI.Text(tz.ls('LoseConnect'), {
          fontFamily: FF,
          fontSize: 60,
          fill: '#ffffff',
          padding: 10
        });
        t.anchor.set(.5);
        this.addChild(t);
        t.x = w * .5;
        t.y = h * .5;
        t.alpha = .2;
        t.visible = false;

        t = this.n_ = new PIXI.Text('', {
          fontFamily: FF,
          fontSize: 28,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.set(.5);
        this.addChild(t);
        t.x = w * .5;
        t.y = h * .5;

        let f = new PIXI.Sprite(T64.F);
        this.addChild(f);
        f.scale.set(.8);
        f.anchor.set(.5);
        f.x = w * .5 - 23;
        f.y = h - 25;

        t = this.f_ = new PIXI.Text('\u00D7 0', {
          fontFamily: FF,
          fontSize: 26,
          fill: '#ffffff',
          padding: 10
        });
        t.anchor.set(.5);
        this.addChild(t);
        t.x = w * .5 + 17;
        t.y = h - 25;

        t = this.w_ = new PIXI.Text(tz.ls('FalseHu'), {
          fontFamily: FF,
          fontSize: 26,
          fill: '#ffffff',
          padding: 10
        });
        t.anchor.set(.5);
        this.addChild(t);
        t.x = w * .5;
        t.y = 30;
        t.visible = false;
      }

      /**
       * 初始化
       */
      init() {
        this.flw_ = 0;
        this.f_.text = '\u00D7 0';
        this.l_.visible = false;
        this.w_.visible = false;
      }

      /**
       * 设置名字
       * @param {string} s 名字
       */
      set name(s) {
        let t = this.n_;
        t.text = s;
        scl_txt(t, 170);
      }

      /**
       * 获取名字
       * @return {string}
       */
      get name() {
        return this.n_.text;
      }

      /**
       * 设置花牌数
       * @param {number} f 花牌数
       */
      set flower(f) {
        if (this.flw_ !== f) {
          this.flw_ = f;
          this.f_.text = '\u00D7 ' + parseInt(f);
        }
      }

      /**
       * 获取花牌数
       * @return {number} 花牌数
       */
      get flower() {
        return this.flw_;
      }

      /**
       * 设置连接状态
       * @param {boolean} l 掉线状态
       */
      set conn(l) {
        this.l_.visible = !l;
      }

      /**
       * 获取连接状态
       * @param {boolean} l 掉线状态
       */
      get conn() {
        return !this.l_.visible;
      }

      /**
       * 设置错和状态
       * @param {number} f 错和状态
       */
      set flswn(f) {
        this.w_.visible = f;
      }

      /**
       * 获取错和状态
       * @return {number} 错和状态
       */
      get flswn() {
        return this.w_.visible;
      }
    }
    UsrBrf.W = 180;
    UsrBrf.H = 160;

    // 重叠区域，02总高，13总高，牌组间隔，间隔
    const OL = 18, H0F = 78, H1F = 64, GP = 4;

    // 02宽度，02高度（不包含重叠），13宽度，13高度（不包含重叠）
    const W0 = 52, H0 = 60,/*78-18=60*/ W1 = 70, H1 = 46;/*64-18=46*/

    // 13立牌宽度，高度（总）
    const W1S = 36, H1SF = 83;

    // 02手牌最大宽度、高度
    //const HW0 = W0 * 14 + W1 * 4 + GP * 5;
    //const HH0 = H1 * 2 + OL;

    // 13手牌最大宽度、高度
    //const HW1 = W0 * 2;
    //const HH1 = H1 * 14 + H0 * 4 + GP * 5 + OL;

    const GF = 4;
    // 13副露宽度、高度
    const FW1 = W0 * 2, FH1 = H1 * 11 + GF * 3 + H0 * 4 + H1F;

    // 02副露宽度、高度
    const FW0 = W0 * 12 + GF * 3 + W1 * 4, FH0 = H1 + H1F;

    //const HAND_SCALE = 1.7;//1 + (W1 + GP) / (W0 * 3);

    //const EXT_CP_02 = (W1 + GP - W0) * .5; // (W0 * 2 + W1 + GP - W0 * 3) * .5
    //const EXT_DK_02 = (W1 + GP) * .5;  // (W0 * 3 + W1 + GP - W0 * 3) * .5
    //const EXT_CK_02 = (W0 + GP) * .5;

    //const EXT_CP_13 = (H0 + GP - H1) * .5; // (H1 * 2 + H0 + GP - H1 * 3) * .5
    //const EXT_DK_13 = (H0 + GP) * .5;  //  (H1 * 3 + H0 + GP - H1 * 3) * .5
    //const EXT_CK_13 = (H1 + GP) * .5;

    //const DOX = [10, 10, -10, -10];
    //const DOY = [10, -10, -10, 10];

    // 骰子时间、抓牌时间、理牌时间、出牌时间
    const DCDT = 2000, DRDT = 100, STDT = 200, DSDT = 100;

    /**
     * 牌池中的牌
     * @typedef {object} PlTl
     */
    class PlTl extends PIXI.Sprite {
      // i_ = -1;  // 牌张索引

      /**
       * @param {object} t 纹理
       * @param {number} i 牌张索引
       */
      constructor(t, i) {
        super(t);
        this.i_ = i;
      }
    }

    /**
     * 更新牌张（自己、对家）
     * @param {object} p 要更新的牌（精灵）
     * @param {number} i 牌张索引
     */
    function updt_t0(p, i) {
      if (p.i_ !== i) {
        let v = TlTbl[i];
        p.texture.frame = new PIXI.Rectangle(
          (W0 + 2) * (v & 15) + 2, (H0F + 2) * ((v & 240) >> 4) + 2,
          W0, H0F);
        p.i_ = i;

        let s = p.s_;
        if (tz.tlscp && s) {
          s.text = TlSpt[i >> 2];
        }
      }
    }

    /**
     * 更新牌张（下家、上家）
     * @param {object} p 要更新的牌（精灵）
     * @param {number} i 牌张索引
     */
    function updt_t1(p, i) {
      if (p.i_ !== i) {
        let v = TlTbl[i];
        p.texture.frame = new PIXI.Rectangle(
          (W1 + 2) * (v & 15) + 2, (H1F + 2) * ((v & 240) >> 4) + 2,
          W1, H1F);
        p.i_ = i;

        let s = p.s_;
        if (tz.tlscp && s) {
          s.text = TlSpt[i >> 2];
        }
      }
    }

    /**
     * 创建牌墙（自己、对家）
     */
    function wall0() {
      return new PIXI.Sprite(new PIXI.Texture(PlTl.tx0.baseTexture, new PIXI.Rectangle(
        (W0 + 2) * 8 + 2, (H0F + 2) * 4 + 2,
        W0, H0F)));
    }

    /**
     * 创建牌墙（下家、上家）
     */
    function wall1() {
      return new PIXI.Sprite(new PIXI.Texture(PlTl.tx1.baseTexture, new PIXI.Rectangle(
        (W1 + 2) * 8 + 2, (H1F + 2) * 4 + 2,
        W1, H1F)));
    }

    /**
     * 创建立牌（下家）
     */
    function st_tl1() {
      return new PIXI.Sprite(StTl.tx1);
    }

    /**
     * 创建立牌（对家）
     */
    function st_tl2() {
      return new PIXI.Sprite(new PIXI.Texture(PlTl.tx2.baseTexture, new PIXI.Rectangle(
        (W0 + 2) * 8 + 2, (H0F + 2) * 4 + 2,
        W0, H0F)));
    }

    /**
     * 创建立牌（上家）
     */
    function st_tl3() {
      return new PIXI.Sprite(StTl.tx3);
    }

    /**
     * 随机下标
     * @param {number} s 总大小
     * @param {number} n 随机几个
     * @param {number} o 统计增加的值
     */
    function rnd_idx(s, n, o) {
      // 算法为：先生成一个0,1,2,3,...(s-1)的数组，随机打乱，取最开头的n个
      let a = new Uint8Array(s);
      a.forEach((e, i, a)=>a[i] = i);
      shfl(a, 0, s);
      let r = a.slice(0, n).sort();
      if (o) {
        r.forEach((e, i, a)=>a[i] += o);
      }
      return r;
    }

    /**
     * 自己牌墙
     * @typedef {object} Wall0
     */
    class Wall0 extends PIXI.Container {
      // s_ = null;  // 牌张精灵

      constructor() {
        super();
/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, Wall0.W, Wall0.H);
        g.endFill();
        this.addChild(g);
*/

        let s = this.s_ = new Array(36);
        for (let i = 0; i < 36; ++i) {
          let p = (i >> 1), d = 1 - (i & 1);
          let w = s[((17 - p) << 1) + d] = wall0();
          this.addChild(w);
          w.x = W0 * p;
          w.y = OL * d;
        }
      }
    }
    // 折叠
    Wall0.W = W0 * 18;
    Wall0.H = H0 + OL;

    // 打开
    //Wall0.W = W0 * 18;
    //Wall0.H = H0 * 2 + OL;

    /**
     * 下家牌墙
     * @typedef {object} Wall1
     */
    class Wall1 extends PIXI.Container {
      // s_ = null;  // 牌张精灵

      constructor() {
        super();
/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, Wall1.W, Wall1.H);
        g.endFill();
        this.addChild(g);
*/

        let s = this.s_ = new Array(36);
        for (let i = 0; i < 36; ++i) {
          let p = (i >> 1), d = 1 - (i & 1);
          let w = s[(p << 1) + d] = wall1();
          this.addChild(w);
          w.y = H1 * p + OL * d;
        }
      }
    }
    // 折叠
    Wall1.W = W1;
    Wall1.H = H1 * 18 + OL * 2;

    // 打开
    //Wall1.W = W1 * 2;
    //Wall1.H = H1 * 18 + OL * 2;

    /**
     * 对家牌墙
     * @typedef {object} Wall2
     */
    class Wall2 extends PIXI.Container {
      // s_ = null;  // 牌张精灵

      constructor() {
        super();
/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, Wall2.W, Wall2.H);
        g.endFill();
        this.addChild(g);
*/

        let s = this.s_ = new Array(36);
        for (let i = 0; i < 36; ++i) {
          let p = (i >> 1), d = 1 - (i & 1);
          let w = s[(p << 1) + d] = wall0();
          this.addChild(w);
          w.x = W0 * p;
          w.y = OL * d;
        }
      }
    }
    // 折叠
    Wall2.W = W0 * 18;
    Wall2.H = H0 + OL;

    // 打开
    //Wall2.W = W0 * 18;
    //Wall2.H = H0 * 2 + OL;

    /**
     * 上家牌墙
     * @typedef {object} Wall3
     */
    class Wall3 extends PIXI.Container {
      // s_ = null;  // 牌张精灵

      constructor() {
        super();
/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, Wall3.W, Wall3.H);
        g.endFill();
        this.addChild(g);
*/

        let s = this.s_ = new Array(36);
        for (let i = 0; i < 36; ++i) {
          let p = (i >> 1), d = 1 - (i & 1);
          let w = s[((17 - p) << 1) + d] = wall1();
          this.addChild(w);
          w.y = H1 * p + OL * d;
        }
      }
    }
    // 折叠
    Wall3.W = W1;
    Wall3.H = H1 * 18 + OL * 2;

    // 打开
    //Wall3.W = W1 * 2;
    //Wall3.H = H1 * 18 + OL * 2;

    /**
     * 牌墙
     * @typedef {object} WaCtn
     */
    class WaCtn extends PIXI.Container {
      // wa_ = null;  // 牌墙
      // s_ = null;  // 接管牌张精灵
      // op_ = {};  // 标记牌墙开门位置
      // fp_ = {};  // 标记牌墙顺序
      // bp_ = {};  // 标记牌墙逆序
      // rem_ = 0;  // 牌墙剩余

      constructor() {
        super();

        let wa = this.wa_ = [new Wall0(), new Wall1(), new Wall2(), new Wall3()];
        this.s_ = [[], [], [], []];
        wa.forEach((e, i)=>{
          this.addChildAt(e, 0);
          this.s_[i] = e.s_;
        });
      }

      /**
       * 适配
       */
      layt(w, h) {
        let wa = this.wa_;

        wa[0].x = w - HdCtn1.W - Wall1.W - Wall0.W;
        wa[0].y = h - Wall0.H;

        wa[1].x = w - HdCtn1.W - Wall1.W;
        wa[1].y = HdCtn3.W + H0;

        wa[2].x = HdCtn3.W + Wall1.W;
        wa[2].y = HdCtn2.H;

        wa[3].x = HdCtn3.W;
        wa[3].y = h - Wall0.H - Wall1.H + OL * 2;
      }

      /**
       * 初始化
       */
      init() {
        // 如果用起牌墙效果，则需要先隐藏牌墙
        //this.s_.forEach(l=>l.forEach(e=>e.visible = false));
        this.s_.forEach(l=>l.forEach(e=>e.visible = true));
      }

      /**
       * 准备牌墙，起牌墙效果
       */
      // prep() {
      //   let s = this.s_;
      //   for (let i = 0; i < 18; ++i) {
      //     setTimeout(()=>{
      //       for (let k = 0; k < 4; ++k) {
      //         s[k][i * 2].visible = true;
      //         s[k][i * 2 + 1].visible = true;
      //       }
      //       tz.play('snd/05-draw.wav');
      //     }, 30 * i);
      //   }
      // }

      /**
       * 掷骰子
       * @param {number} v 座位
       * @param {array} d 骰子点数
       */
      dice(v, d) {
        console.log('dice v d', v, d);
        let o = (d[0] + d[1] - 1 + 4 - v) & 3;  // 开门的方位
        let p = d[0] + d[1] + d[2] + d[3];  // 留的墩数
        if (p >= 18) {  // 转角
          p -= 18;
          o = (o + 3) & 3;
        }

        // 标记牌墙o:方位，p:墩数，d:下面的
        this.op_ = {o:o, p:p, d:false};  // 标记牌墙开门位置
        this.fp_ = {o:o, p:p, d:false};  // 标记牌墙顺序
        // 标记牌墙逆序
        this.bp_ = p > 0 ? {o:o, p:(p - 1), d:false}  // 往前退一墩
          : {o:((o + 1) & 3), p:17, d:false};  // 转角
        this.rem_ = 144;
      }

      // 顺序抓一张牌
      front() {
        if (!this.rem_) return;

        let fp = this.fp_, bp = this.bp_;
        let o = fp['o'], p = fp['p'], s;

        if (!fp['d']) {  // 抓上面的
          s = this.s_[o][p * 2];

          // 更新信息
          fp['d'] = true;

          // 正序和逆序是同一墩牌
          if (fp['o'] === bp['o'] && fp['p'] === bp['p']) {
            bp['d'] = true;
          }
        }
        else {  // 抓下面的
          s = this.s_[o][p * 2 + 1];

          ++p;  // 往下一墩
          if (p >= 18) {  // 转角
            p -= 18;
            o = (o + 3) & 3;
          }

          // 更新信息
          // 当正序和逆序到达同一墩牌时，信息共用
          fp['o'] = o;
          fp['p'] = p;
          fp['d'] = (o !== bp['o'] || p !== bp['p']) ? false : bp['d'];
        }

        --this.rem_;
        s.visible = false;
        return s;
      }

      // 逆抓一张牌
      back() {
        if (!this.rem_) return;

        let bp = this.bp_, fp = this.fp_;
        let o = bp['o'], p = bp['p'], s;

        if (!bp['d']) {  // 抓上面的
          s = this.s_[o][p * 2];

          // 更新信息
          bp['d'] = true;

          // 正序和逆序是同一墩牌
          if (o === fp['o'] && p === fp['p']) {
            fp['d'] = true;
          }
        }
        else {  // 抓下面的
          s = this.s_[o][p * 2 + 1];

            // 往上一墩
          if (p > 0) {
            --p;
          }
          else {  // 转角
            p = 17;
            o = (o + 1) & 3;
          }

          // 更新信息
          // 当正序和逆序到达同一墩牌时，信息共用
          bp['o'] = o;
          bp['p'] = p;
          bp['d'] = (o !== fp['o'] || p !== fp['p']) ? false : fp['d'];
        }

        --this.rem_;
        s.visible = false;
        return s;
      }
    }

    /**
     * 立牌
     * @typedef {object} StTl
     */
    class StTl extends PIXI.Sprite {
      // i_ = 0;  // 牌张索引
      // s_ = null;  // 角标
      // fg_ = null;  // 高亮前景
      // cb_ = null;  // 点击回调

      /**
       * @param {number} i 牌张索引
       * @param {function(StTl):void} cb 点击回调
       */
      constructor(i, cb) {
        let v = TlTbl[i];
        super(new PIXI.Texture(StTl.tx0.baseTexture, new PIXI.Rectangle(
          (W0 + 2) * (v & 0xF) + 2, (H0F + 2) * ((v & 0xF0) >> 4) + 2,
          W0, H0F)));
        this.i_ = i;

        if (tz.tlscp) {
          let s = this.s_ = bmp_txt(TlSpt[i >> 2], { fontName: 'shsb', fontSize: 24 });
          this.addChild(s);
          s.x = 4;
          s.y = 18;
        }

        if (!cb) {
          return;
        }

        let fg = this.fg_ = new PIXI.Sprite(new PIXI.Texture(StTl.tx0.baseTexture, new PIXI.Rectangle(
          (W0 + 2) * 7 + 2, (H0F + 2) * 3 + 2,
          W0, H0F)));
        this.addChild(fg);
        fg.alpha = .3;
        fg.visible = false;

        this.cb_ = cb;
        let l = ()=>this.fg_.visible = true;
        let n = ()=>this.fg_.visible = false;

        this.interactive = true;
        this.on('click', ()=>this.cb_(this));
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('tap', ()=>this.cb_(this));
        // 手指要点两下才能出牌
        //this.on('touchstart', l);
        //this.on('touchendoutside', n);
        //this.on('touchend', n);

        //this.anchor = new PIXI.ObservablePoint(this.ly, this, 0, 0);
      }

      /**
       * 更新牌张
       * @param {number} i 牌张索引
       */
      updt(i) {
        updt_t0(this, i);
      }

      /**
       * 重新布局，需在改变锚点后调用
       */
      layt() {
        let f = this.fg_;
        if (f) {
          f.x = W0 * (-this.anchor.x);
          f.y = H0F * (-this.anchor.y);
        }

        if (tz.tlscp) {
          let s = this.s_;
          if (s) {
            s.x = 4 - W0 * this.anchor.x;
            s.y = 18 - H0F * this.anchor.y;
          }
        }
      }

      /**
       * 设置高亮状态
       * @param {boolean} h 高亮状态
       */
      set hlt(h) {
        this.fg_.visible = h;
      }

      /**
       * 获取高亮状态
       * @return {boolean}
       */
      get hlt() {
        return this.fg_.visible;
      }

      /**
       * 点击这张牌，由手机钢琴键调用
       */
      click() {
        this.cb_(this);
      }

      // /**
      //  * 设置点击回调
      //  * @param {function(StTl):void} f 点击回调
      //  */
      // setcb(f) {
      //   this.cb_ = f;
      // }
    }

    /**
     * 自己牌池中的牌
     * @typedef {object} PlTl0
     */
    class PlTl0 extends PlTl {
      // i_ = 0;  // 牌张索引
      // s_ = null;  // 角标

      /**
       * @param {number} i 牌张索引
       */
      constructor(i) {
        let v = TlTbl[i];
        super(new PIXI.Texture(PlTl.tx0.baseTexture, new PIXI.Rectangle(
          (W0 + 2) * (v & 15) + 2, (H0F + 2) * ((v & 240) >> 4) + 2,
          W0, H0F)), i);

        if (tz.tlscp) {
          let s = this.s_ = bmp_txt(TlSpt[i >> 2], { fontName: 'shsb', fontSize: 24 });
          this.addChild(s);
          s.x = 4;
          s.y = -2;
        }
      }

      /**
       * 更新牌面
       * @param {number} i 牌张索引
       */
      updt(i) {
        updt_t0(this, i);
      }

      /**
       * 重新布局，需在改变锚点后调用
       */
      layt() {
        if (tz.tlscp) {
          let s = this.s_;
          if (s) {
            s.x = 4 - W0 * this.anchor.x;
            s.y = -2 - H0F * this.anchor.y;
          }
        }
      }
    }

    /**
     * 下家牌池中的牌
     * @typedef {object} PlTl1
     */
    class PlTl1 extends PlTl {
      // i_ = 0;  // 牌张索引
      // s_ = null;  // 角标

      /**
       * @param {number} i 牌张索引
       */
      constructor(i) {
        let v = TlTbl[i];
        super(new PIXI.Texture(PlTl.tx1.baseTexture, new PIXI.Rectangle(
          (W1 + 2) * (v & 15) + 2, (H1F + 2) * ((v & 240) >> 4) + 2,
          W1, H1F)), i);

        if (tz.tlscp) {
          let s = this.s_ = bmp_txt(TlSpt[i >> 2], { fontName: 'shsb', fontSize: 24 });
          this.addChild(s);
          s.rotation = -Math.PI * .5;
          s.x = 0;
          s.y = H1 - 8;
        }
      }

      /**
       * 更新牌面
       * @param {number} i 牌张索引
       */
      updt(i) {
        updt_t1(this, i);
      }

      /**
       * 重新布局，需在改变锚点后调用
       */
      layt() {
        if (tz.tlscp) {
          let s = this.s_;
          if (s) {
            s.x = - W1 * this.anchor.x;
            s.y = H1 - 8 - H1F * this.anchor.y;
          }
        }
      }
    }

    /**
     * 对家牌池中的牌
     * @typedef {object} PlTl2
     */
    class PlTl2 extends PlTl {
      // i_ = 0;  // 牌张索引
      // s_ = null;  // 角标

      /**
       * @param {number} i 牌张索引
       */
      constructor(i) {
        let v = TlTbl[i];
        super(new PIXI.Texture(PlTl.tx2.baseTexture, new PIXI.Rectangle(
          (W0 + 2) * (v & 15) + 2, (H0F + 2) * ((v & 240) >> 4) + 2,
          W0, H0F)), i);

        if (tz.tlscp) {
          let s = this.s_ = bmp_txt(TlSpt[i >> 2], { fontName: 'shsb', fontSize: 24 });
          this.addChild(s);
          s.rotation = -Math.PI;
          s.x = W0 - 5;
          s.y = H0 - 2;
        }
      }

      /**
       * 更新牌面
       * @param {number} i 牌张索引
       */
      updt(i) {
        updt_t0(this, i);
      }

      /**
       * 重新布局，需在改变锚点后调用
       */
      layt() {
        if (tz.tlscp) {
          let s = this.s_;
          if (s) {
            s.x = W0 - 5 - W0 * this.anchor.x;
            s.y = H0 - 2 - H0F * this.anchor.y;
          }
        }
      }
    }

    /**
      * 上家牌池中的牌
      * @typedef {object} PlTl3
      */
    class PlTl3 extends PlTl {
      // i_ = 0;  // 牌张索引
      // s_ = null;  // 角标

      /**
       * @param {number} i 牌张索引
       */
      constructor(i) {
        let v = TlTbl[i];
        super(new PIXI.Texture(PlTl.tx3.baseTexture, new PIXI.Rectangle(
          (W1 + 2) * (v & 15) + 2, (H1F + 2) * ((v & 240) >> 4) + 2,
          W1, H1F)), i);

        if (tz.tlscp) {
          let s = this.s_ = bmp_txt(TlSpt[i >> 2], { fontName: 'shsb', fontSize: 24 });
          this.addChild(s);
          s.rotation = Math.PI * .5;
          s.x = W1;
          s.y = 4;
        }
      }

      /**
       * 更新牌面
       * @param {number} i 牌张索引
       */
      updt(i) {
        updt_t1(this, i);
      }

      /**
       * 重新布局，需在改变锚点后调用
       */
      layt() {
        if (tz.tlscp) {
          let s = this.s_;
          if (s) {
            s.x = W1 - W1 * this.anchor.x;
            s.y = 4 - H1F * this.anchor.y;
          }
        }
      }
    }

    /**
     * 生成一副吃牌
     * @param {number} n 玩家
     * @param {number} t 副露关键牌
     * @param {number} o 供牌
     * @param {array} s 传出，生成的精灵
     */
    function new_c(n, t, o, s) {
      const PT = [PlTl0, PlTl1, PlTl2, PlTl3];
      const PT0 = PT[n];
      switch (o) {
      default: s.push(new PT[(n + 1) & 3](t - 4)); s.push(new PT0(t)); s.push(new PT0(t + 4)); break;
      case 2: s.push(new PT[(n + 1) & 3](t)); s.push(new PT0(t - 4)); s.push(new PT0(t + 4)); break;
      case 3: s.push(new PT[(n + 1) & 3](t + 4)); s.push(new PT0(t - 4)); s.push(new PT0(t)); break;
      }
      return 0;
    }

    /**
     * 生成一副碰牌
     * @param {number} n 玩家
     * @param {number} t 副露关键牌
     * @param {number} o 供牌
     * @param {array} s 传出，生成的精灵
     * @return {number} 横放的张。012 上、对、下家
     */
     function new_p(n, t, o, s) {
      const PT = [PlTl0, PlTl1, PlTl2, PlTl3];
      const PT0 = PT[n];
      switch (o) {
      default: s.push(new PT[(n + 1) & 3](t)); s.push(new PT0(t)); s.push(new PT0(t)); s[0].pr_ = true; return 0;
      case 2: s.push(new PT0(t)); s.push(new PT[(n + 1) & 3](t)); s.push(new PT0(t)); s[1].pr_ = true; return 1;
      case 3: s.push(new PT0(t)); s.push(new PT0(t)); s.push(new PT[(n + 3) & 3](t)); s[2].pr_ = true; return 2;
      }
    }

    /**
     * 生成一副直杠
     * @param {number} n 玩家
     * @param {number} t 副露关键牌
     * @param {number} o 供牌
     * @param {array} s 传出，生成的精灵
     * @return {number} 横放的张。012 上、对、下家
     */
     function new_dk(n, t, o, s) {
      const PT = [PlTl0, PlTl1, PlTl2, PlTl3];
      const PT0 = PT[n];
      switch (o) {
      default: s.push(new PT[(n + 1) & 3](t)); s.push(new PT0(t)); s.push(new PT0(t)); s.push(new PT0(t)); return 0;
      case 2: s.push(new PT0(t)); s.push(new PT[(n + 1) & 3](t)); s.push(new PT0(t)); s.push(new PT0(t)); return 1;
      case 3: s.push(new PT0(t)); s.push(new PT0(t)); s.push(new PT0(t)); s.push(new PT[(n + 3) & 3](t)); return 2;
      }
    }

    /**
     * 生成一副暗杠
     * @param {number} n 玩家
     * @param {number} t 副露关键牌
     * @param {number} o 供牌
     * @param {array} s 传出，生成的精灵
     */
     function new_ck(n, t, o, s) {
      const WA = [wall0, wall1];
      const WA0 = WA[n & 1];
      s.push(WA0()); s.push(WA0()); s.push(WA0()); s.push(WA0()); s[1].ck_ = true; s[2].ck_ = true;
      return 3;
    }

    /**
     * 生成一副加杠（仅用在断线重连时）
     * @param {number} n 玩家
     * @param {number} t 副露关键牌
     * @param {number} o 供牌
     * @param {array} s 传出，生成的精灵
     * @return {number} 456上、对、下家碰牌的加杠
     */
    function new_pk(n, t, o, s) {
      const PT = [PlTl0, PlTl1, PlTl2, PlTl3];
      const PT0 = PT[n];
      switch (o) {
      default: s.push(new PT[(n + 1) & 3](t)); s.push(new PT[(n + 1) & 3](t)); s.push(new PT0(t)); s.push(new PT0(t)); return 4;
      case 2: s.push(new PT0(t)); s.push(new PT[(n + 1) & 3](t)); s.push(new PT[(n + 1) & 3](t)); s.push(new PT0(t)); return 5;
      case 3: s.push(new PT0(t)); s.push(new PT0(t)); s.push(new PT[(n + 3) & 3](t)); s.push(new PT[(n + 3) & 3](t)); return 6;
      }
    }

    /**
     * 生成副露
     * @param {number} n 玩家
     * @param {number} c 副露类型
     * @param {number} t 副露关键牌
     * @param {number} o 供牌者
     * @param {array} s 传出，生成的精灵
     * @return {number} 横放的张。012 上、对、下家，3自己暗杠 456上、对、下家碰牌的加杠
     */
    function new_ca(n, c, t, o, s) {
      switch (c) {
      case 0:  // 吃
        new_c(n, t, o, s);
        return 0;
      case 1:  // 碰
        return new_p(n, t, o, s);
      case 2:  // 0暗杠 123直杠
        return o ? new_dk(n, t, o, s) : new_ck(n, t, o, s);
      case 3:  // 加杠
        return new_pk(n, t, o, s);
      }
      return 0;
    }

    /**
     * 生成副露
     * @param {number} c 副露类型
     * @param {number} o 供牌者
     * @return {array} 横放精灵的下标
     */
    /*function pk_hz(c, o) {
      let h = [];
      switch (c) {
      case 0:  // 吃
        return [0];
      case 1:  // 碰
        switch (o) {
        default: return [0];
        case 2: return [1];
        case 3: return [2];
        }
        break;
      case 2:  // 0暗杠 123直杠
        switch (o) {
        default: return [0];
        case 2: return [1];
        case 3: return [3];
        case 0: return [];
        }
        break;
      case 3:  // 加杠
        switch (o) {
        default: return [0, 1];
        case 2: return [1, 2];
        case 3: return [2, 3];
        }
        break;
      }
      return h;
    }*/

    /**
     * 寻找立牌中的指定牌（精准匹配）
     * @param {number} s 立牌数组
     * @param {number} b 开始位置
     * @param {number} t 待搜索的牌
     * @return {number} 下标或者-1
     */
    function st_find(s, b, t) {
      for (let l = s.length; b < l; ++b) {
        let e = s[b];
        if (e && e.visible && e.i_ === t) return b;
      }
      return -1;
    }

    /**
     * 寻找立牌中的指定牌（匹配牌面相等）
     * @param {number} s 立牌数组
     * @param {number} b 开始位置
     * @param {number} t 待搜索的牌
     * @return {number} 下标或者-1
    */
    function st_find_f(s, b, t) {
      let v = t & 0xfc;
      for (let l = s.length; b < l; ++b) {
        let e = s[b];
        if (e && e.visible && (e.i_ & 0xfc) === v) return b;
      }
      return -1;
    }

    /**
     * 寻找立牌中的指定牌（匹配牌面相等，但不精准匹配）
     * @param {number} s 立牌数组
     * @param {number} b 开始位置
     * @param {number} t 待搜索的牌
     * @return {number} 下标或者-1
     */
    function st_find_n(s, b, t) {
      let v = t & 0xfc;
      for (let l = s.length; b < l; ++b) {
        let e = s[b];
        if (e && e.visible) {
          let i = e.i_;
          if ((i & 0xfc) === v && i !== t) return b;
        }
      }
      return -1;
    }

    /**
     * 手牌的容器（基类）
     * @typedef {object} HdCtn
     */
    class HdCtn extends PIXI.Container {
      constructor() {
        super();

        /** @member {object} 立牌容器 */
        this.c_ = new PIXI.Container();
        /** @member {object} 副露容器 */
        this.f_ = new PIXI.Container();
        /** @member {array} 立牌精灵 */
        this.s_ = [];
        /** @member {array} 副露数据 */
        this.p_ = [];
        /** @member {object} 打开的立牌精灵 */
        this.o_ = new PIXI.Container();
        /** @member {array} 打开的精灵容器 */
        this.g_ = [];
      }

      /**
       * 初始化
       */
      init() {
        this.p_ = [];
        this.f_.removeChildren().forEach(e=>e.dsty());
        this.s_.forEach(e=>e.visible = false);
        this.o_.removeChildren().forEach(e=>e.dsty());
        //this.g_.forEach(e=>e.dsty());  // TODO:
        this.g_ = [];
        this.c_.visible = true;
      }

      /**
       * 抓牌效果
       * @param {number} i 抓牌到手上第几张
       * @param {object} o 牌墙上牌张的坐标
       * @param {object} p 牌张精灵
       * @param {number} x 偏移x
       * @param {number} y 偏移y
       */
      _draw(i, o, p, x, y) {
        p.position = this.c_.toLocal(o);
        let d = this.s_[i];
        new TWEEN.Tween(p).to({x:(d.x - x),y:(d.y + y)}, DRDT).onComplete(()=>{
          d.visible = true;
          p.dsty();
        }).start();

        addblur(p);
      }

      /**
       * 补花效果
       * @param {object} o 牌墙上牌张的坐标
       */
      rpflw(o) {
        let s = this.s_;
        if (s[13].visible) {
          s[13].visible = false;
          this.draw(13, o);
        } else {
          s[12].visible = false;
          this.draw(12, o);

          //let a = this.p_.length * 3;
          //let i = rnd_idx(13 - a, 1)[0] + a;
          //this.draw(12, o);
          //if (i !== 12) {
          //}
        }
      }

      /**
       * 打牌效果
       * @param {number} i 打出牌在手牌中的下标
       * @param {object} p 打出牌精灵
       * @param {object} d 目标牌池精灵
       * @param {number} x 转换世界坐标的基准点
       * @param {number} y 转换世界坐标的基准点
       * @param {number} dx 飞到牌池后的偏移
       * @param {number} dy 飞到牌池后的偏移
       */
      _dscd(i, p, d, x, y, dx, dy) {
        let o = this.s_[i], r = d.parent;
        o.visible = false;
        p.position = r.toLocal(o.toGlobal({x:x, y:y}));
        addblur(p);
        new TWEEN.Tween(p.position).to({x:(d.x + dx), y:(d.y + dy)}, DSDT).onComplete(()=>{
          rmblur(p);
        }).start();
      }

      /**
       * 设置数据
       * @param {array} s 立牌
       * @param {array} p 副露
       * @param {number} n 当前是哪个玩家
       * @param {function(object):void} ad 添加副露牌张结点的回调函数
       * @param {function(number,number):array} dp 获取最终应该去到位置的回调函数
       */
      _setup(s, p, n, ad, dp) {
        // 立牌
        if (!p) p = [];
        if (n) {  // 自己已经在外面设置过了
          let o = p.length * 3;
          this.s_.forEach((e, i)=>{
            if (i >= o) {
              e.visible = true;
            }
            else {
              e.visible = false;
            }
          });
          // 摸到的牌
          let v = s[13 - o], e = this.s_[13];
          if (typeof v !== 'undefined') {
            e.visible = true;
          }
          else {
            e.visible = false;
          }
        }

        // 副露
        p.forEach(e=>{
          // 副露类型、关键牌
          let c = pk_tp(e), t = pk_tl(e), o = pk_ofr(e);

          let s = [], z = 0;
          // z横放的张。012 上、对、下家，3自己暗杠 456上、对、下家碰牌的加杠
          z = new_ca(n, c, t, o, s);

          // 自己的暗杠要显示出来
          if (n === 0 && c === 2 && o === 0) {
            s[1] = new PlTl0(t);
            s[2] = new PlTl0(t);
          }

          // 添加新结点
          s.forEach(ad);

          // 设置位置
          dp(c, z).forEach((p, i)=>s[i].position = p);

          this.p_.push(e);
        });
      }

      /**
       * 吃
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       * @param {number} n 当前是哪个玩家
       * @param {array} r 来源下标
       * @param {number} x 偏移x
       * @param {number} y 偏移y
       * @param {function(object):void} ad 添加副露牌张结点的回调函数
       * @param {function(number,number):array} dp 获取最终应该去到位置的回调函数
       */
      _c(p, o, n, r, x, y, ad, dp) {
        let t = pk_tl(p);  // 关键牌

        // 执行动画的精灵数组
        let s = [];
        new_c(n, t, pk_ofr(p), s);

        this.p_.push(p);

        // 添加新结点
        s.forEach(ad);

        // 根据横放的牌张，计算应去的位置
        let d = dp(0, 0);

        // 执行动画

        // 设置初始位置
        s[0].position = (this.f_.toLocal(o));  // 外源

        // 手牌来源
        let m;
        if (n === 0) {
          m = this.c_.scale.x / this.f_.scale.x;
        }
        r.forEach((v, i)=>{
          let p = this.s_[v];
          // 手牌来源
          let q = s[i + 1];
          q.position = this.f_.toLocal(p.toGlobal({x:x, y:y}));

          if (n === 0) {
            q.scale.set(m);
            new TWEEN.Tween(q.scale).to({x:1,y:1}, DSDT).start();
          }

          // 隐藏手牌
          p.visible = false;
        });

        // 执行动画
        s.forEach((e, i)=>{
          addblur(e);
          new TWEEN.Tween(e).to(d[i], DSDT).onComplete(rmblur).start();
        });

        let g = this.s_;
        g[13].visible = false;
        shft_ahd(g, r[0]);
        shft_ahd(g, r[1]);
        shft_ahd(g, 13);

        tz.play('snd/09-cpk.wav');
      }

      /**
       * 碰
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       * @param {number} n 当前是哪个玩家
       * @param {array} r 来源下标
       * @param {number} x 偏移x
       * @param {number} y 偏移y
       * @param {function(object):void} ad 添加副露牌张结点的回调函数
       * @param {function(number,number):array} dp 获取最终应该去到位置的回调函数
       */
       _p(p, o, n, r, x, y, ad, dp) {
        let t = pk_tl(p);  // 关键牌

        // 执行动画的精灵数组
        let s = [];
        let z = new_p(n, t, pk_ofr(p), s);

        this.p_.push(p);

        // 添加新结点
        s.forEach(ad);

        // 根据横放的牌张，计算应去的位置
        let d = dp(1, z);

        switch (z) {
        case 1:
          // 把供牌张交换到下标0位置
          swp(s, 0, 1);
          swp(d, 0, 1);
          break;
        case 2:
          // 把供牌张移动到下标0位置
          shft_ahd(s, 2);
          shft_ahd(d, 2);
          break;
        }

        // 执行动画

        // 设置初始位置
        s[0].position = (this.f_.toLocal(o));  // 外源

        // 手牌来源
        let m;
        if (n === 0) {
          m = this.c_.scale.x / this.f_.scale.x;
        }
        r.forEach((v, i)=>{
          let p = this.s_[v];
          // 手牌来源
          let q = s[i + 1];
          q.position = this.f_.toLocal(p.toGlobal({x:x, y:y}));

          if (n === 0) {
            q.scale.set(m);
            new TWEEN.Tween(q.scale).to({x:1,y:1}, DSDT).start();
          }

          // 隐藏手牌
          p.visible = false;
        });

        // 执行动画
        s.forEach((e, i)=>{
          addblur(e);
          new TWEEN.Tween(e).to(d[i], DSDT).onComplete(rmblur).start();
        });

        let g = this.s_;
        g[13].visible = false;
        shft_ahd(g, r[0]);
        shft_ahd(g, r[1]);
        shft_ahd(g, 13);

        tz.play('snd/09-cpk.wav');
      }

      /**
       * 直杠
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       * @param {number} n 当前是哪个玩家
       * @param {array} r 来源下标
       * @param {number} x 偏移x
       * @param {number} y 偏移y
       * @param {function(object):void} ad 添加副露牌张结点的回调函数
       * @param {function(number,number):array} dp 获取最终应该去到位置的回调函数
       */
      _dk(p, o, n, r, x, y, ad, dp) {
        let t = pk_tl(p);  // 关键牌

        // 执行动画的精灵数组
        let s = [];
        let z = new_dk(n, t, pk_ofr(p), s);

        this.p_.push(p);

        // 添加新结点
        s.forEach(ad);

        // 根据横放的牌张，计算应去的位置
        let d = dp(2, z);

        switch (z) {
        case 1:
          // 把供牌张交换到下标0位置
          swp(s, 0, 1);
          swp(d, 0, 1);
          break;
        case 2:
          // 把供牌张移动到下标0位置
          shft_ahd(s, 3);
          shft_ahd(d, 3);
          break;
        }

        // 执行动画

        // 设置初始位置
        s[0].position = (this.f_.toLocal(o));  // 外源

        // 手牌来源
        let m;
        if (n === 0) {
          m = this.c_.scale.x / this.f_.scale.x;
        }
        r.forEach((v, i)=>{
          let p = this.s_[v];
          // 手牌来源
          let q = s[i + 1];
          q.position = this.f_.toLocal(p.toGlobal({x:x, y:y}));

          if (n === 0) {
            q.scale.set(m);
            new TWEEN.Tween(q.scale).to({x:1,y:1}, DSDT).start();
          }

          // 隐藏手牌
          p.visible = false;
        });

        // 执行动画
        s.forEach((e, i)=>{
          addblur(e);
          new TWEEN.Tween(e).to(d[i], DSDT).onComplete(rmblur).start();
        });

        let g = this.s_;
        shft_ahd(g, r[0]);
        shft_ahd(g, r[1]);
        shft_ahd(g, r[2]);

        tz.play('snd/09-cpk.wav');
      }

      /**
       * 暗杠
       * @param {number|boolean} p 牌组数据（仅对自己有效）|原本手里四个
       * @param {number} n 当前是哪个玩家
       * @param {array} r 来源下标
       * @param {number} x 偏移x
       * @param {number} y 偏移y
       * @param {function(object):void} ad 添加副露牌张结点的回调函数
       * @param {function(number,number):array} dp 获取最终应该去到位置的回调函数
       */
      _ck(p, n, r, x, y, ad, dp) {
        // 执行动画的精灵数组
        let s = [];
        new_ck(n, 0, pk_ofr(p), s);

        if (n === 0) {
          let t = pk_tl(p);
          s[1] = new PlTl0(t);
          s[2] = new PlTl0(t);
          this.p_.push(p);
        }
        else {
          this.p_.push(0x300);  // 占位
        }

        // 添加新结点
        s.forEach(ad);

        // 根据横放的牌张，计算应去的位置
        let d = dp(3, 3);

        // 执行动画

        // 设置初始位置

        // 手牌来源
        let m;
        if (n === 0) {
          m = this.c_.scale.x / this.f_.scale.x;
        }
        r.forEach((v, i)=>{
          let p = this.s_[v];
          // 手牌来源
          let q = s[i];
          q.position = this.f_.toLocal(p.toGlobal({x:x, y:y}));

          if (n === 0) {
            q.scale.set(m);
            new TWEEN.Tween(q.scale).to({x:1,y:1}, DSDT).start();
          }

          // 隐藏手牌
          p.visible = false;
        });

        // 执行动画
        s.forEach((e, i)=>{
          addblur(e);
          new TWEEN.Tween(e).to(d[i], DSDT).onComplete(rmblur).start();
        });

        let g = this.s_;
        shft_ahd(g, r[0]);
        shft_ahd(g, r[1]);
        shft_ahd(g, r[2]);
        shft_bhd(g, r[3]);

        tz.play('snd/09-cpk.wav');
      }

      /**
       * 加杠
       * @param {number} p 牌组数据
       * @param {number} n 当前是哪个玩家
       * @param {number} r 来源下标
       * @param {number} x 偏移x
       * @param {number} y 偏移y
       * @param {funtion(object,object):void} ad 添加结点的回调函数
       * @param {function(object):object} ps 获取位置的回调函数
       * @return {JSON} {s:牌张精灵，p:{目标位置}}
       */
      _pk(p, n, r, x, y, ad, ps) {
        // 查找应该加在哪组明刻上
        let t = pk_tl(p);
        let o = this.f_.children.find(e=>e.pr_ && e.i_ === t);  // 测试时去掉牌张检测
        if (typeof o === 'undefined') {
          tz.reenter();
          return;
        }

        //this.p_[] = p;  // TODO：修改副露数据

        delete o.pr_;
        let s = new PIXI.Sprite(new PIXI.Texture(o.texture, o.texture.frame));

        // 添加新结点
        ad(o, s);

        // 手牌来源
        let q = this.s_[r];

        s.position = this.f_.toLocal(q.toGlobal({x:x, y:y}));

        if (n === 0) {
          s.scale.set(this.c_.scale.x / this.f_.scale.x);
          new TWEEN.Tween(s.scale).to({x:1,y:1}, DSDT).start();
        }

        // 隐藏手牌
        q.visible = false;

        // 执行动画
        let d = ps(o);
        addblur(s);
        new TWEEN.Tween(s).to({x:d['x'], y:d['y']}, DSDT).onComplete(rmblur).start();

        // NOTE：测试归位
        //setTimeout(()=>new TWEEN.Tween(s).to({x:d['dx'], y:d['dy']}, DSDT).start(), 3000);

        shft_bhd(this.s_, r);

        s.dx_ = d['dx'];
        s.dy_ = d['dy'];

        tz.play('snd/09-cpk.wav');
        return {s:s, p:{x:d['dx'], y:d['dy']}};
      }

      /**
       * 和牌
       * @param {number} t 牌张
       * @param {object} o 供牌的起点坐标
       * @param {number} n 当前是哪个玩家
       * @param {number} x 偏移x
       * @param {number} y 偏移y
       * @param {function(object):void} ad 添加和牌张结点的回调函数
       */
      _win(t, o, n, x, y, ad) {
        const PT = [PlTl0, PlTl1, PlTl2, PlTl3];
        let s = new PT[n](t);
        ad(s);
        s.position = (this.c_.toLocal(o));
        let p = this.s_[13];
        addblur(s);
        new TWEEN.Tween(s).to({x:(p.x + x), y:(p.y + y)}, DSDT).onComplete(e=>/*rmblur(e)*/e.dsty()).start();
        if (n === 0) {
          s.scale.set(this.f_.scale.x / this.c_.scale.x);
          new TWEEN.Tween(s.scale).to({x:1,y:1}, DSDT).start();
        }
      }

      /**
       * 打开手牌
       * @param {array} s 立牌
       * @param {array} p 副露
       * @param {number} t 和牌张
       * @param {number} m 定时移走
       * @param {number} n 当前是哪个玩家
       * @param {funtion(object,object):void} js 添加摊开立牌结点的回调函数
       * @param {funtion(object,object):void} jp 添加摊开副露结点的回调函数
       */
      _open(s, p, t, m, n, js, jp) {
        const PT = [PlTl0, PlTl1, PlTl2, PlTl3], WA = [wall0, wall1];
        const PT0 = PT[n], WA0 = WA[n & 1];

        // 立牌
        let a = (p && p.length) ? p.length * 3 : 0;
        s.forEach((e, i)=>{
          let o = this.s_[i + a], q = (e !== 255) ? new PT0(e) : WA0();
          js(q, o);
          this.g_.push(q);
        });

        // 和牌
        if (typeof t !== 'undefined') {
          let o = this.s_[13], q = new PT0(t);
          js(q, o);
          this.g_.push(q);
        }

        // 副露包含暗杠
        if (p && p.length && p.some(e=>(e & 0xffc0) === 0x200)) {
          // 因为是直接在子结点中查找暗杠标记的牌，为避免新插入的影响，先复制一份
          let c = this.f_.children, u = new Array(c.length);
          c.forEach((e, i)=>u[i] = e);
          p.forEach(e=>{
            // 暗杠
            if ((e & 0xffc0) === 0x200) {
              for (let k = 0, g = 0, l = c.length; k < l && g < 2; ++k) {
                let b = u[k];
                if (b.ck_) {
                  let q = new PT0(pk_tl(e));
                  jp(q, b);
                  this.g_.push(q);
                }
              }
            }
          });
        }

        this.c_.visible = false;
        if (m) {
          setTimeout(()=>{
            this.c_.visible = true;
            this.g_.forEach(e=>e.dsty());
            this.g_ = [];
            this.o_.removeChildren().forEach(e=>e.dsty());
          }, m);
        }
      }
    }

    /**
     * 自己手牌的容器
     * @typedef {object} HdCtn0
     */
    class HdCtn0 extends HdCtn {
      /**
       * @param {function(object)} 点击牌张回调
       */
      constructor(cb) {
        super();

        this.dscd_ = cb;

        // 立牌容器
        let c = this.c_;
        this.addChild(c);

        // 打开的立牌容器
        this.addChild(this.o_);

        // 副露容器
        let f = this.f_;
        this.addChild(f);

        // // 测试代码，最大高度
        // // 4组直杠
        // for (let i = 0; i < 4; ++i) {
        //   for (let k = 0; k < 3; ++k) {
        //     let t = new PlTl0(0x41 + i*4);
        //     t.x = (W0 * 3 + W1 + GF) * i + W0 * k;
        //     t.y = HdCtn0.H - H0F;
        //     f.addChild(t);
        //   }

        //   let t = new PlTl1(0x41 + i*4);
        //   t.x = (W0 * 3 + W1 + GF) * i + W0 * 3;
        //   t.y = HdCtn0.H - H1F;
        //   f.addChild(t);
        // }
/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, HdCtn0.WF, HdCtn0.H);
        g.endFill();
        f.addChild(g);

        g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, HdCtn0.W, HdCtn0.H);
        g.endFill();
        c.addChild(g);
*/
        // 正序设置
        let s = this.s_;
        for (let i = 0; i < 14; ++i) {
          let p = s[i] = new StTl(i, p=>this._c(p));
          p.y = HdCtn0.H - H0F;
          p.x = W0 * i;
          if (i === 13) p.x += GP;
          c.addChild(p);
          p.visible = false;
        }

        this.x_ = 0;
      }

      /**
       * 初始化
       */
      init() {
        super.init();
        this.x_ = 0;
      }

      /**
       * 发牌
       * @param {array} s 立牌
       * @param {boolean} e 是否为庄家
       */
      prep(s, e) {
        this.s_.forEach((p, i)=>{
          let a = s[i];
          if (typeof a !== 'undefined') {
            p.updt(a);
          }
        });
        if (!e) {
          this.s_[13].i_ = 0xff;
        }
      }

      /**
       * 摸切
       */
      dd() {
        let p = this.s_[13];
        if (p.visible && p.i_ !== 0xff && p.i_ !== -1) {
          this.dscd_(p);
        }
      }

      /**
       * 获取摸到的牌
       * @return {number} 牌张索引
       */
      wt() {
        return this.s_[13].i_;
      }

      /**
       * 是否能打牌
       */
      candscd() {
        return this.s_[13].visible;
      }

      /**
       * 外部调用点击某张牌
       */
      clk(i) {
        let p = this.s_[i];
        if (p.visible) {
          this._c(p);
        }
      }

      /**
       * 抓牌效果
       * @param {number} i 抓牌到手上第几张
       * @param {object} o 牌墙上牌张的坐标
       */
      draw(i, o) {
        let p = wall0();
        super._draw(i, o, p, 0, 0);
        this.c_.addChild(p);
        p.scale.set(this.f_.scale.x / this.c_.scale.x);
        new TWEEN.Tween(p.scale).to({x:1,y:1}, DRDT).start();
      }

      /**
       * 抓牌
       * @param {number} i 抓牌到手上第几张
       * @param {number} t 牌张索引
       */
      draw0(i, t) {
        let p = this.s_[i];
        if (p) p.updt(t);
      }

      /**
       * 理牌
       */
      sort() {
        let s = this.s_;
        s.sort(function(a, b) { return a.i_ - b.i_; });
        s.forEach((p, i)=>{
          let x = W0 * i;
          if (i === 13) x += GP;
          if (p.x !== x) {
            if (p.visible) {
              new TWEEN.Tween(p).to({x:x}, STDT).start();
            }
            else {
              p.x = x;
            }
          }
        });

        // 重新设置index，使得每次摸上来的牌，在参与理牌时，都暂时在最外面
        setTimeout(()=>{
          this.s_.forEach((p, i)=>{
            p.parent.setChildIndex(p, i);
          });
        }, STDT);
      }

      /**
       * 补花效果
       * @param {number} u 使用的花牌
       * @param {number} n 抓回来的新牌
       * @param {object} o 牌墙上牌张的坐标
       */
      rpflw(u, n, o) {
        let s = this.s_;
        let i = s.findIndex(e=>e.visible && e.i_ === u);
        if (i === -1) {
          tz.reenter();
          return;
        }

        let q = s[i];
        q.i_ = 0xff;
        q.visible = false;
        if (i === 13) {  // 抓到的牌补花
          s[13].updt(n);
          this.draw(13, o);
        } else {  // 手里的牌补花
          if (s[13].visible) {  // 摸到牌时
            // 先把13位置的牌转移走，再补花
            this.sort();

            s[13].updt(n);
            this.draw(13, o);
          } else {  // 未摸到牌时（只会出现在配牌补花过程中）
            s[13].i_ = 0xff;

            q.updt(n);
            this.draw(i, o);

            // 移动手牌动画
            this.sort();
          }
        }
      }

      /**
       * 打牌效果
       * @param {number} t 牌张索引
       * @param {boolean} h 手摸切（对于自己来说，这个参数并不使用，反正要从手牌中查找）
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      dscd(t, h, d) {
        let s = this.s_;
        let i = st_find(s, 0, t);
        if (i === -1) {
          console.log('discard 0 error');
          tz.reenter();
          return;
        }

        let p = new PlTl0(t);
        d.parent.addChild(p);
        super._dscd(i, p, d, 0, 0, 10, 10);

        p.scale.set(this.c_.scale.x / this.f_.scale.x);
        new TWEEN.Tween(p.scale).to({x:1,y:1}, DSDT).start();

        s[i].i_ = 0xff;
        setTimeout(()=>this.sort(), 500);

        return p;
      }

      /**
       * 创建断线重联后的飞牌
       * @param {number} t 牌张索引
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      fly(t, d) {
        let p = new PlTl0(t);
        d.parent.addChild(p);
        p.x = d.x + 10;
        p.y = d.y + 10;
        return p;
      }

      /**
       * 点击手牌回调
       * @param {object} p 牌张（精灵）
       */
      _c(p) {
        // 本身高亮，就打出；本身未高亮，就将其切换为高亮
        if (p.hlt) {
          this.dscd_(p);
          p.hlt = false;
        } else {
          this.s_.forEach(e=>e.hlt = (e === p));
        }

        // 刷新钢琴键
        (function(){
          let gm = tz.game;
          let p3 = gm.p3_, p2 = gm.p2_;
          if (p3 && p3.visible) p3.rfsh();
          else if (p2 && p2.visible) p2.rfsh();
        })();
      }

      /**
       * 适配
       * @param {number} s 副露的缩放比
       * @param {number} w 允许宽度
       * @param {number} h 允许高度
       */
      layt(s, w, h) {
        let f = this.f_, c = this.c_, o = this.o_;
        f.scale.set(s);

        // 当立牌缩放后超过允许高度时，不再放大，居中显示
        let s1 = w / HdCtn0.W, h1 = H0F * s1;
        if (h1 > h) {
          s1 = h / H0F;
          f.x = c.x = (w - HdCtn0.W * s1) * .5;
        }
        else {
          f.x = c.x = 0;
        }
        c.scale.set(s1);
        f.y = h - HdCtn0.H * s;
        c.y = h - HdCtn0.H * s1;

        o.scale.set(s1);
        o.x = c.x;
        o.y = c.y;
        //return s1;
      }

      /**
       * 设置数据
       * @param {array} s 立牌
       * @param {array} p 副露
       */
      setup(s, p) {
        // 立牌
        if (!p) p = [];
        let o = p ? p.length * 3 : 0;
        this.s_.forEach((e, i)=>{
          if (i >= o) {
            e.visible = true;
            e.updt(s[i - o]);
          }
          else {
            e.visible = false;
            e.i_ = -1;
          }
        });

        // 摸到的牌
        let v = s[13 - o], e = this.s_[13];
        if (typeof v !== 'undefined') {
          e.visible = true;
          e.updt(v);
        }
        else {
          e.visible = false;
          e.i_ = 255;
        }

        super._setup(s, p, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
      }

      /**
       * 鸣牌放置的位置
       * @param {number} c 副露类型
       * @param {number} z 横放的哪一张
       * @return {array} 各牌张的位置
       */
      dstpos(c, z) {
        // 本次副露起始位置
        let x = this.x_;

        // 计算下次副露初始位置
        if (c !== 2) {
          this.x_ += W0 * 2 + W1 + GF;
        }
        else {
          this.x_ += (z !== 3 ? W0 * 3 + W1 : W0 * 4) + GF;
        }

        let y = HdCtn0.H - H0F, y0 = HdCtn0.H - H1F;
        let p = [];
        switch (z) {
        case 0:  // 鸣上家
          p.push({x:x, y:y0}, {x:(x + W1), y:y}, {x:(x + W1 + W0), y:y});
          if (c === 2) p.push({x:(x + W1 + W0 * 2), y:y});
          break;
        case 1:  // 鸣对家
          p.push({x:x, y:y}, {x:(x + W0), y:y0}, {x:(x + W1 + W0), y:y});
          if (c === 2) p.push({x:(x + W1 + W0 * 2), y:y});
          break;
        case 2:  // 鸣下家
          p.push({x:x, y:y}, {x:(x + W0), y:y});
          if (c !== 2) p.push({x:(x + W0 * 2), y:y0});
          else p.push({x:(x + W0 * 2), y}, {x:(x + W0 * 3), y:y0});
          break;
        case 3:  // 暗杠
          p.push({x:x, y:y}, {x:(x + W0), y:y}, {x:(x + W0 * 2), y:y}, {x:(x + W0 * 3), y:y});
          break;
        case 4:  // 碰上家，加杠
          p.push({x:x, y:(y0 - H1)}, {x:x, y:y0}, {x:(x + W1), y:y}, {x:(x + W1 + W0), y:y});
          break;
        case 5:  // 碰对家，加杠
          p.push({x:x, y:y}, {x:(x + W0), y:(y0 - H1)}, {x:(x + W0), y:y0}, {x:(x + W1 + W0), y:y});
          break;
        case 6:  // 碰下家，加杠
          p.push({x:x, y:y}, {x:(x + W0), y:y}, {x:(x + W0 * 2), y:(y0 - H1)}, {x:(x + W0 * 2), y:y0});
          break;
        }
        return p;
      }

      /**
       * 移动手牌
       */
      move() {
        let s = this.s_;
        s.forEach((p, i)=>{
          let x = W0 * i;
          if (i === 13) x += GP;
          if (p.x !== x) {
            if (p.visible) {
              new TWEEN.Tween(p).to({x:x}, STDT).start();
            }
            else {
              p.i_ = -1;
              p.x = x;
            }
          }
        });
      }

      /**
       * 吃
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      c(p, o) {
        let t = pk_tl(p), s = this.s_, a = this.p_.length * 3;

        // 测试：随机选择手里的牌张
        //let r = rnd_idx(13 - a, 2, a);

        // 精准查找手里的牌张
        let r = new Int8Array(2);
        let t0 = t - 4 + ((p >> 10) & 3), t1 = t + ((p >> 12) & 3), t2 = t + 4 + ((p >> 14) & 3);
        switch (pk_ofr(p)) {
        default:
          r[0] = st_find(s, a, t1);
          r[1] = st_find(s, a, t2);
          break;
        case 2:
          r[0] = st_find(s, a, t0);
          r[1] = st_find(s, a, t2);
          break;
        case 3:
          r[0] = st_find(s, a, t0);
          r[1] = st_find(s, a, t1);
          break;
        }

        s[r[0]].i_ = -1;
        s[r[1]].i_ = -1;
        s[13].i_ = -1;
        super._c(p, o, 0, r, 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 碰
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      p(p, o) {
        let t = pk_tl(p), s = this.s_, a = this.p_.length * 3;

        // 测试：随机选择手里的牌张
        //let r = rnd_idx(13 - a, 2, a);

        // 精准查找手里的牌张
        let r = new Int8Array(2);
        let tm = t + ((p >> 10) & 3);
        r[0] = st_find_n(s, a, tm);
        r[1] = st_find_n(s, r[0] + 1, tm);

        s[r[0]].i_ = -1;
        s[r[1]].i_ = -1;
        s[13].i_ = -1;
        super._p(p, o, 0, r, 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 直杠
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      dk(p, o) {
        let t = pk_tl(p), s = this.s_, a = this.p_.length * 3;

        // 测试：随机选择手里的牌张
        //let r = rnd_idx(13 - a, 3, a);

        // 精准查找手里的牌张
        let r = new Int8Array(3);
        r[0] = st_find_f(s, a, t);
        r[1] = st_find_f(s, r[0] + 1, t);
        r[2] = st_find_f(s, r[1] + 1, t);

        s[r[0]].i_ = -1;
        s[r[1]].i_ = -1;
        s[r[2]].i_ = -1;
        super._dk(p, o, 0, r, 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 暗杠
       * @param {number} p 牌组数据
       */
      ck(p) {
        let t = pk_tl(p), s = this.s_, a = this.p_.length * 3;

        // 测试：随机选择手里的牌张
        //let r = rnd_idx(14 - a, 4, a);

        // 精准查找手里的牌张
        let r = new Int8Array(4);
        r[0] = st_find_f(s, a, t);
        r[1] = st_find_f(s, r[0] + 1, t);
        r[2] = st_find_f(s, r[1] + 1, t);
        r[3] = st_find_f(s, r[2] + 1, t);

        s[r[0]].i_ = -1;
        s[r[1]].i_ = -1;
        s[r[2]].i_ = -1;
        s[r[3]].i_ = -1;
        super._ck(p, 0, r, 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 加杠
       * @param {number} p 牌组数据
       * @return {JSON} {s:牌张精灵，p:{目标位置}}
       */
      pk(p) {
        let t = pk_tl(p), s = this.s_, a = this.p_.length * 3;

        // 测试：随机选择手里的牌张
        //let r = Math.trunc(Math.random() * (14 - a));

        // 精准查找手里的牌张
        let r = st_find_f(s, a, t);
        s[r].i_ = -1;
        let q = super._pk(p, 0, r, 0, 0,
          (o, p)=>{
            let i = this.f_.getChildIndex(o);
            this.f_.addChildAt(p, i);
          },
          p=>({x:p.x, y:(p.y - H1 - GP), dx:p.x, dy:(p.y - H1)})
        );
        this.move();
        return q;
      }

      /**
       * 和牌
       * @param {number} t 牌张
       * @param {object} o 供牌的起点坐标
       */
      win(t, o) {
        super._win(t, o, 0, 0, 0, p=>this.c_.addChild(p));
      }

      /**
       * 打开手牌
       * @param {array} s 立牌
       * @param {array} p 副露
       * @param {number} t 和牌张
       * @param {number} m 定时移走
       */
      open(s, p, t, m) {
        super._open(s, p, t, m, 0, (n, o)=>{
          this.o_.addChild(n);
          n.x = o.x;
          n.y = o.y;
        }, (n, o)=>{
          this.f_.addChild(n);
          n.x = o.x;
          n.y = o.y;
        });
      }

    }
    HdCtn0.W = W0 * 14 + GP;
    HdCtn0.H = H1 + H1F + GP;

    // 最小缩放比：使四组直杠占12张立牌的宽度
    // 立牌至少要缩放这么多才能使副露不堆叠在立牌上
    HdCtn0.WF = (W0 * 3 + W1) * 4 + GF * 3;
    HdCtn0.S = (W0 * 12) / HdCtn0.WF;
    HdCtn0.W0 = HdCtn0.W / HdCtn0.S;
    HdCtn0.H0 = HdCtn0.H / HdCtn0.S;

    /**
     * 下家手牌的容器
     * @typedef {object} HdCtn1
     */
    class HdCtn1 extends HdCtn {
      constructor() {
        super();

        // 立牌容器
        let c = this.c_;
        this.addChild(c);

        // 打开的立牌容器
        this.addChild(this.o_);

        // 副露容器
        let f = this.f_;
        this.addChild(f);

        // // 测试代码，最大高度
        // // 2张牌（手牌与和牌，摊开状态）
        // let t = new PlTl1(0x45);
        // t.y = H1SF - H1F;
        // c.addChild(t);

        // t = new PlTl1(0x45);
        // t.y = H1SF - H1F + H1 + GP;
        // c.addChild(t);

        // // 2张牌（手牌与和牌，立起状态）
        // t = st_tl1();
        // t.x = W1 - W1S;
        // c.addChild(t);

        // t = st_tl1();
        // t.x = W1 - W1S;
        // t.y = H1 + GP;
        // c.addChild(t);

        // // 4组直杠
        // for (let i = 0; i < 4; ++i) {
        //   for (let k = 0; k < 3; ++k) {
        //     let t = new PlTl1(0x41 + i*4);
        //     t.x = HdCtn1.W - W1;
        //     t.y = H1 * k + (H1 * 3 + H0 + GF) * i;
        //     f.addChild(t);
        //   }

        //   let t = new PlTl0(0x41 + i*4);
        //   t.x = HdCtn1.W - W0;
        //   t.y = H1 * 3 + (H1 * 3 + H0 + GF) * i;
        //   f.addChild(t);
        // }
/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, HdCtn1.W, HdCtn1.H);
        g.endFill();
        this.addChild(g);

        g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, HdCtn1.W, FH1);
        g.endFill();
        f.addChild(g);
*/
        // 逆序设置
        let s = this.s_;
        for (let i = 0; i < 14; ++i) {
          let p = s[13 - i] = st_tl1();
          p.x = HdCtn1.W - W1S;
          p.y = H1 * i;
          if (i !== 0) p.y += GP;
          c.addChild(p);
          p.visible = false;
        }

        f.y = H1SF - H1F + (H1 + GP) * 2;

        this.y_ = FH1 - (H1F - H1);  // 哨兵位置
      }

      /**
       * 初始化
       */
      init() {
        super.init();
        this.y_ = FH1 - (H1F - H1);
      }

      /**
       * 抓牌效果
       * @param {number} i 抓牌到手上第几张
       * @param {object} o 牌墙上牌张的坐标
       */
      draw(i, o) {
        let p = wall1();
        super._draw(i, o, p, W1S - W1, H1SF - H1F);
        this.c_.addChildAt(p, 0);
      }

      /**
       * 假的理牌效果
       */
      sort() {
        shfl(this.s_, 0, 13);
        this.move();
      }

      /**
       * 打牌效果
       * @param {number} t 牌张索引
       * @param {boolean} h 手摸切
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      dscd(t, h, d) {
        let a = this.p_.length * 3;
        let i = h ? (Math.trunc(Math.random() * (13 - a)) + a) : 13;
        let p = new PlTl1(t);
        d.parent.addChildAt(p, 0);
        super._dscd(i, p, d, W1S - W1, H1SF - H1F, 10, -10);
        if (h) {
          shft_bhd(this.s_, i);
          setTimeout(()=>this.move(), 500);
        }
        return p;
      }

      /**
       * 创建断线重联后的飞牌
       * @param {number} t 牌张索引
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      fly(t, d) {
        let p = new PlTl1(t);
        d.parent.addChildAt(p, 0);
        p.x = d.x + 10;
        p.y = d.y - 10;
        return p;
      }

      /**
       * 设置数据
       * @param {array} s 立牌
       * @param {array} p 副露
       */
      setup(s, p) {
        super._setup(s, p, 1, p=>this.f_.addChildAt(p, 0), this.dstpos.bind(this));
      }

      /**
       * 鸣牌放置的位置
       * @param {number} c 副露类型
       * @param {number} z 横放的哪一张
       * @return {array} 各牌张的位置
       */
      dstpos(c, z) {
        // 本次副露起始位置
        let y = this.y_;

        // 计算下次副露初始位置
        if (c !== 2) {
          this.y_ -= H1 * 2 + H0 + GF;
        }
        else {
          this.y_ -= (z !== 3 ? H1 * 3 + H0 : H1 * 4) + GF;
        }

        let x = HdCtn1.W - W1, x0 = HdCtn1.W - W0;
        let p = [];
        switch (z) {
        case 0:  // 鸣上家
          p.push({x:x0, y:(y - H0)}, {x:x, y:(y - H0 - H1)}, {x:x, y:(y - H0 - H1 * 2)});
          if (c === 2) p.push({x:x, y:(y - H0 - H1 * 3)});
          break;
        case 1:  // 鸣对家
          p.push({x:x, y:(y - H1)}, {x:x0, y:(y - H1 - H0)}, {x:x, y:(y - H0 - H1 * 2)});
          if (c === 2) p.push({x:x, y:(y - H0 - H1 * 3)});
          break;
        case 2:  // 鸣下家
          p.push({x:x, y:(y - H1)}, {x:x, y:(y - H1 * 2)});
          if (c !== 2) p.push({x:x0, y:(y - H0 - H1 * 2)});
          else p.push({x:x, y:(y - H1 * 3)}, {x:x0, y:(y - H0 - H1 * 3)});
          break;
        case 3:  // 暗杠
          p.push({x:x, y:(y - H1)}, {x:x, y:(y - H1 * 2)}, {x:x, y:(y - H1 * 3)}, {x:x, y:(y - H1 * 4)});
          break;
        case 4:  // 碰上家，加杠
          p.push({x:x0, y:(y - H0)}, {x:(x0 - W0), y:(y - H0)}, {x:x, y:(y - H0 - H1)}, {x:x, y:(y - H0 - H1 * 2)});
          break;
        case 5:  // 碰对家，加杠
          p.push({x:x, y:(y - H1)}, {x:x0, y:(y - H1 - H0)}, {x:(x0 - W0), y:(y - H1 - H0)}, {x:x, y:(y - H0 - H1 * 2)});
          break;
        case 6:  // 碰下家，加杠
          p.push({x:x, y:(y - H1)}, {x:x, y:(y - H1 * 2)}, {x:x0, y:(y - H0 - H1 * 2)}, {x:(x0 - W0), y:(y - H0 - H1 * 2)});
          break;
        }
        return p;
      }

      /**
       * 移动手牌
       */
      move() {
        let s = this.s_;
        s.forEach((p, i)=>{
          let y = H1 * (13 - i);
          if (i === 12) y += GP;
          if (p.y !== y) {
            if (p.visible) {
              new TWEEN.Tween(p).to({y:y}, STDT).start();
            }
            else {
              p.y = y;
            }
          }
          p.parent.setChildIndex(p, 13 - i);
        });
      }

      /**
       * 吃
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      c(p, o) {
        let a = this.p_.length * 3;
        super._c(p, o, 1, rnd_idx(13 - a, 2, a), W1S - W1, H1SF - H1F, p=>this.f_.addChildAt(p, 0), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 碰
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      p(p, o) {
        let a = this.p_.length * 3;
        super._p(p, o, 1, rnd_idx(13 - a, 2, a), W1S - W1, H1SF - H1F, p=>this.f_.addChildAt(p, 0), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 直杠
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      dk(p, o) {
        let a = this.p_.length * 3;
        super._dk(p, o, 1, rnd_idx(13 - a, 3, a), W1S - W1, H1SF - H1F, p=>this.f_.addChildAt(p, 0), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 暗杠
       * @param {boolean} h 手牌四张true，抓来暗杠false
       */
      ck(h) {
        let a = this.p_.length * 3, r = rnd_idx(13 - a, 4, a);
        if (!h) {
          r[3] = 13;
        }
        super._ck(h, 1, r, W1S - W1, H1SF - H1F, p=>this.f_.addChildAt(p, 0), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 加杠
       * @param {number} p 牌组数据
       * @param {boolean} h 手牌的true，抓来的false
       * @return {JSON} {s:牌张精灵，p:{目标位置}}
       */
      pk(p, h) {
        let a = this.p_.length * 3;
        let s = super._pk(p, 1, h ? (Math.trunc(Math.random() * (13 - a)) + a) : 13, W1S - W1, H1SF - H1F,
          (o, p)=>{
            let i = this.f_.getChildIndex(o);
            this.f_.addChildAt(p, i);
          },
          p=>({x:0, y:p.y, dx:GP, dy:p.y})
        );
        this.move();
        return s;
      }

      /**
       * 和牌
       * @param {number} t 牌张
       * @param {object} o 供牌的起点坐标
       */
      win(t, o) {
        super._win(t, o, 1, W1S - W1, H1SF - H1F, p=>this.c_.addChildAt(p, 0));
      }

      /**
       * 打开手牌
       * @param {array} s 立牌
       * @param {array} p 副露
       * @param {number} t 和牌张
       * @param {number} m 定时移走
       */
      open(s, p, t, m) {
        super._open(s, p, t, m, 1, (n, o)=>{
          this.o_.addChildAt(n, 0);
          n.x = o.x + (W1S - W1);
          n.y = o.y + (H1SF - H1F);
        }, (n, o)=>{
          this.f_.addChildAt(n, this.f_.getChildIndex(o) + 1);
          n.x = o.x;
          n.y = o.y;
        });
      }

    }
    // 一行布局
    HdCtn1.H = FH1 + GP * 2 + H1 + H1SF - OL;
    HdCtn1.W = FW1 + GP;

    // 两行布局
    //HdCtn1.H = FH1;
    //HdCtn1.W = H0 * 2 + GP * 2 + H1;

    /**
     * 对家手牌的容器
     * @typedef {object} HdCtn2
     */
    class HdCtn2 extends HdCtn {
      constructor() {
        super();

        // 立牌容器
        let c = this.c_;
        this.addChild(c);

        // 打开的立牌容器
        this.addChild(this.o_);

        // 副露容器
        let f = this.f_;
        this.addChild(f);

        // // 4组直杠
        // for (let i = 0; i < 4; ++i) {
        //   for (let k = 0; k < 3; ++k) {
        //     let t = new PlTl2(0x41 + i*4);
        //     t.x = FW0 - (W0 * 3 + W1 + GF) * i - W0 * (k + 1);
        //     f.addChild(t);
        //   }

        //   let t = new PlTl1(0x41 + i*4);
        //   t.x = FW0 - (W0 * 3 + W1 + GF) * i - W0 * 3 - W1;
        //   f.addChild(t);
        // }

/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, HdCtn2.W, HdCtn2.H);
        g.endFill();
        this.addChild(g);
*/

        // 逆序设置
        let s = this.s_;
        for (let i = 0; i < 14; ++i) {
          let p = s[13 - i] = st_tl2();
          p.x = W0 * i;
          if (i !== 0) p.x += GP;
          c.addChild(p);
          p.visible = false;
        }

        f.x = HdCtn2.W - FW0;

        this.x_ = FW0;  // 哨兵位置
      }

      /**
       * 初始化
       */
      init() {
        super.init();
        this.x_ = FW0;
      }

      /**
       * 抓牌效果
       * @param {number} i 抓牌到手上第几张
       * @param {object} o 牌墙上牌张的坐标
       */
      draw(i, o) {
        let p = wall0();
        super._draw(i, o, p, 0, 0);
        this.c_.addChild(p);
      }

      /**
       * 假的理牌效果
       */
      sort() {
        shfl(this.s_, 0, 13);
        this.move();
      }

      /**
       * 打牌效果
       * @param {number} t 牌张索引
       * @param {boolean} h 手摸切
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      dscd(t, h, d) {
        let a = this.p_.length * 3;
        let i = h ? (Math.trunc(Math.random() * (13 - a)) + a) : 13;
        let p = new PlTl2(t);
        d.parent.addChildAt(p, 0);
        super._dscd(i, p, d, 0, 0, -10, -10);
        if (h) {
          shft_bhd(this.s_, i);
          setTimeout(()=>this.move(), 500);
        }
        return p;
      }

      /**
       * 创建断线重联后的飞牌
       * @param {number} t 牌张索引
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      fly(t, d) {
        let p = new PlTl2(t);
        d.parent.addChild(p);
        p.x = d.x - 10;
        p.y = d.y - 10;
        return p;
      }

      /**
       * 设置数据
       * @param {array} s 立牌
       * @param {array} p 副露
       */
      setup(s, p) {
        super._setup(s, p, 2, p=>this.f_.addChild(p), this.dstpos.bind(this));
      }

      /**
       * 鸣牌放置的位置
       * @param {number} c 副露类型
       * @param {number} z 横放的哪一张
       * @return {array} 各牌张的位置
       */
      dstpos(c, z) {
        // 本次副露起始位置
        let x = this.x_;

        // 计算下次副露初始位置
        if (c !== 2) {
          this.x_ -= W0 * 2 + W1 + GF;
        }
        else {
          this.x_ -= (z !== 3 ? W0 * 3 + W1 : W0 * 4) + GF;
        }

        let p = [];
        switch (z) {
        case 0:  // 鸣上家
          p.push({x:(x - W1), y:0}, {x:(x - W1 - W0), y:0}, {x:(x - W1 - W0 * 2), y:0});
          if (c === 2) p.push({x:(x - W1 - W0 * 3), y:0});
          break;
        case 1:  // 鸣对家
          p.push({x:(x - W0), y:0}, {x:(x - W0 - W1), y:0}, {x:(x - W1 - W0 * 2), y:0});
          if (c === 2) p.push({x:(x - W1 - W0 * 3), y:0});
          break;
        case 2:  // 鸣下家
          p.push({x:(x - W0), y:0}, {x:(x - W0 * 2), y:0});
          if (c !== 2) p.push({x:(x - W0 * 2 - W1), y:0});
          else p.push({x:(x - W0 * 3), y:0}, {x:(x - W0 * 3 - W1), y:0});
          break;
        case 3:  // 暗杠
          p.push({x:(x - W0), y:0}, {x:(x - W0 * 2), y:0}, {x:(x - W0 * 3), y:0}, {x:(x - W0 * 4), y:0});
          break;
        case 4:  // 碰上家，加杠
          p.push({x:(x - W1), y:0}, {x:(x - W1), y:H1}, {x:(x - W1 - W0), y:0}, {x:(x - W1 - W0 * 2), y:0});
          break;
        case 5:  // 碰对家，加杠
          p.push({x:(x - W0), y:0}, {x:(x - W0 - W1), y:0}, {x:(x - W0 - W1), y:H1}, {x:(x - W1 - W0 * 2), y:0});
          break;
        case 6:  // 碰下家，加杠
          p.push({x:(x - W0), y:0}, {x:(x - W0 * 2), y:0}, {x:(x - W0 * 2 - W1), y:0}, {x:(x - W0 * 2 - W1), y:H1});
          break;
        }
        return p;
      }

      /**
       * 移动手牌
       */
      move() {
        let s = this.s_;
        s.forEach((p, i)=>{
          let x = W0 * (13 - i);
          if (i !== 13) x += GP;
          if (p.x !== x) {
            if (p.visible) {
              new TWEEN.Tween(p).to({x:x}, STDT).start();
            }
            else {
              p.x = x;
            }
          }
        });
      }

      /**
       * 吃
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      c(p, o) {
        let a = this.p_.length * 3;
        super._c(p, o, 2, rnd_idx(13 - a, 2, a), 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 碰
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      p(p, o) {
        let a = this.p_.length * 3;
        super._p(p, o, 2, rnd_idx(13 - a, 2, a), 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 直杠
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      dk(p, o) {
        let a = this.p_.length * 3;
        super._dk(p, o, 2, rnd_idx(13 - a, 3, a), 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 暗杠
       * @param {boolean} h 手牌四张true，抓来暗杠false
       */
      ck(h) {
        let a = this.p_.length * 3, r = rnd_idx(13 - a, 4, a);
        if (!h) {
          r[3] = 13;
        }
        super._ck(h, 2, r, 0, 0, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 加杠
       * @param {number} p 牌组数据
       * @param {boolean} h 手牌的true，抓来的false
       * @return {JSON} {s:牌张精灵，p:{目标位置}}
       */
      pk(p, h) {
        let a = this.p_.length * 3;
        let s = super._pk(p, 2, h ? (Math.trunc(Math.random() * (13 - a)) + a) : 13, 0, 0,
          (o, p)=>{
            let i = this.f_.getChildIndex(o);
            this.f_.addChildAt(p, i + 1);
          },
          p=>({x:p.x, y:(H1 + GP), dx:p.x, dy:H1})
        );
        this.move();
        return s;
      }

      /**
       * 和牌
       * @param {number} t 牌张
       * @param {object} o 供牌的起点坐标
       */
      win(t, o) {
        super._win(t, o, 2, 0, 0, p=>this.c_.addChild(p));
      }

      /**
       * 打开手牌
       * @param {array} s 立牌
       * @param {array} p 副露
       * @param {number} t 和牌张
       * @param {number} m 定时移走
       */
      open(s, p, t, m) {
        super._open(s, p, t, m, 2, (n, o)=>{
          this.o_.addChild(n);
          n.x = o.x;
          n.y = o.y;
        }, (n, o)=>{
          this.f_.addChild(n);
          n.x = o.x;
          n.y = o.y;
        });
      }

    }
    HdCtn2.W = FW0 + W0 * 2 + GP * 2;
    HdCtn2.H = FH0 + GP;

    /**
     * 上家手牌的容器
     * @typedef {object} HdCtn3
     */
    class HdCtn3 extends HdCtn {
      // c_ = null;  // 立牌容器
      // f_ = null;  // 副露容器
      // s_ = null;  // 立牌精灵
      // p_ = null;  // 副露数据
      // y_ = 0;  // 哨兵位置

      constructor() {
        super();

        // 副露容器
        let f = this.f_;
        this.addChild(f);

        // 立牌容器
        let c = this.c_;
        this.addChild(c);

        // 打开的立牌容器
        this.addChild(this.o_);

        // 测试代码，最大高度
        // // 4组直杠
        // for (let i = 0; i < 4; ++i) {
        //   for (let k = 0; k < 3; ++k) {
        //     let t = new PlTl3(0x41 + i*4);
        //     t.x = 0;
        //     t.y = H1 * k + (H1 * 3 + H0 + GF) * i;
        //     f.addChild(t);
        //   }

        //   let t = new PlTl2(0x41 + i*4);
        //   t.y = H1 * 3 + (H1 * 3 + H0 + GF) * i;
        //   f.addChild(t);
        // }

        // // 2张牌（手牌与和牌，摊开状态）
        // let t = new PlTl3(0x45);
        // t.y = H1 * 12 + (H1SF - H1F);
        // c.addChild(t);

        // t = new PlTl3(0x45);
        // t.y = H1 * 13 + GP + (H1SF - H1F);
        // c.addChild(t);

        // // 2张牌（手牌与和牌，立起状态）
        // t = st_tl3();
        // t.y = H1 * 12;
        // c.addChild(t);

        // t = st_tl3();
        // t.y = H1 * 13 + GP;
        // c.addChild(t);

/*
        // 范围测试
        let g = new PIXI.Graphics();
        g.lineStyle(2, 0x0000FF, 1);
        g.beginFill(0xFF00BB, .25);
        g.drawRect(0, 0, HdCtn3.W, HdCtn3.H);
        g.endFill();
        this.addChild(g);
*/

        // 正序设置
        let s = this.s_;
        for (let i = 0; i < 14; ++i) {
          let p = s[i] = st_tl3();
          p.y = H1 * i;
          if (i === 13) p.y += GP;
          c.addChild(p);
          p.visible = false;
        }

        // 4组直杠比立牌放倒多出来的空间，就是手牌的起始位置
        c.y = H0 * 4 + GF * 3 - H1SF + H1F + OL;
        this.o_.y = c.y;

        this.y_ = 0;  // 哨兵位置
      }

      /**
       * 初始化
       */
      init() {
        super.init();
        this.y_ = 0;
      }

      /**
       * 抓牌效果
       * @param {number} i 抓牌到手上第几张
       * @param {object} o 牌墙上牌张的坐标
       */
      draw(i, o) {
        let p = wall1();
        super._draw(i, o, p, 0, H1SF - H1F);
        this.c_.addChild(p);
      }

      /**
       * 假的理牌效果
       */
      sort() {
        shfl(this.s_, 0, 13);
        this.move();
      }

      /**
       * 打牌效果
       * @param {number} t 牌张索引
       * @param {boolean} h 手摸切
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      dscd(t, h, d) {
        let a = this.p_.length * 3;
        let i = h ? (Math.trunc(Math.random() * (13 - a)) + a) : 13;
        let p = new PlTl3(t);
        d.parent.addChild(p);
        super._dscd(i, p, d, 0, H1SF - H1F, -10, 10);
        if (h) {
          shft_bhd(this.s_, i);
          setTimeout(()=>this.move(), 500);
        }
        return p;
      }

      /**
       * 创建断线重联后的飞牌
       * @param {number} t 牌张索引
       * @param {object} d 目标牌池精灵
       * @return {object} 飞牌
       */
      fly(t, d) {
        let p = new PlTl3(t);
        d.parent.addChild(p);
        p.x = d.x - 10;
        p.y = d.y + 10;
        return p;
      }

      /**
       * 设置数据
       * @param {array} s 立牌
       * @param {array} p 副露
       */
      setup(s, p) {
        super._setup(s, p, 3, p=>this.f_.addChild(p), this.dstpos.bind(this));
      }

      /**
       * 鸣牌放置的位置
       * @param {number} c 副露类型
       * @param {number} z 横放的哪一张
       * @return {array} 各牌张的位置
       */
      dstpos(c, z) {
        // 本次副露起始位置
        let y = this.y_;

        // 计算下次副露初始位置
        if (c !== 2) {
          this.y_ += H1 * 2 + H0 + GF;
        }
        else {
          this.y_ += (z !== 3 ? H1 * 3 + H0 : H1 * 4) + GF;
        }

        let p = [];
        switch (z) {
        case 0:  // 鸣上家
          p.push({x:0, y:y}, {x:0, y:(y + H0)}, {x:0, y:(y + H0 + H1)});
          if (c === 2) p.push({x:0, y:(y + H0 + H1 * 2)});
          break;
        case 1:  // 鸣对家
          p.push({x:0, y:y}, {x:0, y:(y + H1)}, {x:0, y:(y + H1 + H0)});
          if (c === 2) p.push({x:0, y:(y + H0 + H1 * 2)});
          break;
        case 2:  // 鸣下家
          p.push({x:0, y:y}, {x:0, y:(y + H1)}, {x:0, y:(y + H1 * 2)});
          if (c === 2) p.push({x:0, y:(y + H1 * 3)});
          break;
        case 3:  // 暗杠
          p.push({x:0, y:y}, {x:0, y:(y + H1)}, {x:0, y:(y + H1 * 2)}, {x:0, y:(y + H1 * 3)});
          break;
        case 4:  // 碰上家，加杠
          p.push({x:0, y:y}, {x:W0, y:y}, {x:0, y:(y + H0)}, {x:0, y:(y + H0 + H1)});
          break;
        case 5:  // 碰对家，加杠
          p.push({x:0, y:y}, {x:0, y:(y + H1)}, {x:W0, y:(y + H1)}, {x:0, y:(y + H1 + H0)});
          break;
        case 6:  // 碰下家，加杠
          p.push({x:0, y:y}, {x:0, y:(y + H1)}, {x:0, y:(y + H1 * 2)}, {x:W0, y:(y + H1 * 2)});
          break;
        }
        return p;
      }

      /**
       * 移动手牌
       */
      move() {
        let s = this.s_;
        s.forEach((p, i)=>{
          let y = H1 * i;
          if (i !== 12) y += GP;
          if (p.y !== y) {
            if (p.visible) {
              new TWEEN.Tween(p).to({y:y}, STDT).start();
            }
            else {
              p.y = y;
            }
          }
          p.parent.setChildIndex(p, i);
        });
      }

      /**
       * 吃
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      c(p, o) {
        let a = this.p_.length * 3;
        super._c(p, o, 3, rnd_idx(13 - a, 2, a), 0, H1SF - H1F, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 碰
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      p(p, o) {
        let a = this.p_.length * 3;
        super._p(p, o, 3, rnd_idx(13 - a, 2, a), 0, H1SF - H1F, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 直杠
       * @param {number} p 牌组数据
       * @param {object} o 供牌的起点坐标
       */
      dk(p, o) {
        let a = this.p_.length * 3;
        super._dk(p, o, 3, rnd_idx(13 - a, 3, a), 0, H1SF - H1F, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 暗杠
       * @param {boolean} h 手牌四张true，抓来暗杠false
       */
      ck(h) {
        let a = this.p_.length * 3, r = rnd_idx(13 - a, 4, a);
        if (!h) {
          r[3] = 13;
        }
        super._ck(h, 3, r, 0, H1SF - H1F, p=>this.f_.addChild(p), this.dstpos.bind(this));
        this.move();
      }

      /**
       * 加杠
       * @param {number} p 牌组数据
       * @param {boolean} h 手牌的true，抓来的false
       * @return {JSON} {s:牌张精灵，p:{目标位置}}
       */
      pk(p, h) {
        let a = this.p_.length * 3;
        let s = super._pk(p, 3, h ? (Math.trunc(Math.random() * (13 - a)) + a) : 13, 0, H1SF - H1F,
          (o, p)=>{
            let i = this.f_.getChildIndex(o);
            this.f_.addChildAt(p, i);
          },
          p=>({x:(W0 + GP), y:p.y, dx:W0, dy:p.y})
        );
        this.move();
        return s;
      }

      /**
       * 和牌
       * @param {number} t 牌张
       * @param {object} o 供牌的起点坐标
       */
      win(t, o) {
        super._win(t, o, 3, 0, H1SF - H1F, p=>this.c_.addChild(p));
      }

      /**
       * 打开手牌
       * @param {array} s 立牌
       * @param {array} p 副露
       * @param {number} t 和牌张
       * @param {number} m 定时移走
       */
      open(s, p, t, m) {
        super._open(s, p, t, m, 3, (n, o)=>{
          this.o_.addChild(n);
          n.x = o.x;
          n.y = o.y + (H1SF - H1F);
        }, (n, o)=>{
          this.f_.addChildAt(n, this.f_.getChildIndex(o) + 1);
          n.x = o.x;
          n.y = o.y;
        });
      }

    }
    // 一行布局
    HdCtn3.H = FH1 + GP + H1 + H1SF - OL;
    HdCtn3.W = FW1 + GP;

    // 两行布局
    //HdCtn3.H = FH1;
    //HdCtn3.W = H0 * 2 + GP * 2 + H1;

    /**
     * 牌池的容器
     * @typedef {object} Pool
     */
    class Pool extends PIXI.Container {
      constructor() {
        super();

        this.s_ = new Array(30);
      }

      /**
       * 初始化
       */
      init() {
        this.s_.forEach(e=>e.visible = e.acpt_ = false);
      }

      /**
       * 获取一张
       */
      pick() {
        return this.s_.find(e=>!e.acpt_);
      }

      /**
       * 掉线重联时设置一堆的值
       * @param {array} p
       */
      setup(p) {
        p.forEach((e,i)=>{
          let s = this.s_[i];
          s.updt(e);
          s.visible = s.acpt_ = true;
        });
      }
    }

    /**
     * 自己牌池的容器
     * @typedef {object} Pool0
     */
    class Pool0 extends Pool {
      constructor() {
        super();

        let s = this.s_;
        let x = 0, y = 0;
        for (let i = 0; i < 30; ++i) {
          let p = s[i] = new PlTl0(0);
          this.addChild(p);
          p.x = x;
          p.y = y;
          x += W0;
          if (i < 18 && i % 6 === 5) {
            y += H0;
            x = 0;
          }
          p.visible = false;
        }

        // 范围测试
        // let g = new PIXI.Graphics();
        // g.lineStyle(2, 0x0000FF, 1);
        // g.beginFill(0xFF00BB, .25);
        // g.drawRect(0, 0, this.width, this.height);
        // g.endFill();
        // this.addChild(g);
      }
    }
    Pool0.W = W0 * 12;
    Pool0.H = H0 * 3 + H0F;

    /**
     * 下家牌池的容器
     * @typedef {object} Pool1
     */
    class Pool1 extends Pool {
      constructor() {
        super();

        let s = this.s_;
        let x = 0, y = H1 * 11;
        for (let i = 0; i < 30; ++i) {
          let p = s[i] = new PlTl1(0);
          this.addChildAt(p, 0);
          p.x = x;
          p.y = y;
          y -= H1;
          if (i < 18 && i % 6 === 5) {
            x += W1;
            y = H1 * 11;
          }
          p.visible = false;
        }

        // 范围测试
        // let g = new PIXI.Graphics();
        // g.lineStyle(2, 0x0000FF, 1);
        // g.beginFill(0xFF00BB, .25);
        // g.drawRect(0, 0, this.width, this.height);
        // g.endFill();
        // this.addChild(g);
      }
    }
    Pool1.W = W1 * 4;
    Pool1.H = H1 * 11 + H1F;

    /**
     * 对家牌池的容器
     * @typedef {object} Pool2
     */
    class Pool2 extends Pool {
      constructor() {
        super();

        let s = this.s_;
        let x = W0 * 11, y = H0 * 3;
        for (let i = 0; i < 30; ++i) {
          let p = s[i] = new PlTl2(0);
          this.addChildAt(p, 0);
          p.x = x;
          p.y = y;
          x -= W0;
          if (i < 18 && i % 6 === 5) {
            y -= H0;
            x = W0 * 11;
          }
          p.visible = false;
        }

        // 范围测试
        // let g = new PIXI.Graphics();
        // g.lineStyle(2, 0x0000FF, 1);
        // g.beginFill(0xFF00BB, .25);
        // g.drawRect(0, 0, this.width, this.height);
        // g.endFill();
        // this.addChild(g);
      }
    }
    Pool2.W = W0 * 12;
    Pool2.H = H0 * 3 + H0F;

    /**
     * 上家牌池的容器
     * @typedef {object} Pool3
     */
    class Pool3 extends Pool {
      constructor() {
        super();

        let s = this.s_;
        let x = W1 * 3, y = 0;
        for (let i = 0; i < 30; ++i) {
          let p = s[i] = new PlTl3(0);
          this.addChild(p);
          p.x = x;
          p.y = y;
          y += H1;
          if (i < 18 && i % 6 === 5) {
            x -= W1;
            y = 0;
          }
          p.visible = false;
        }

        // 范围测试
        // let g = new PIXI.Graphics();
        // g.lineStyle(2, 0x0000FF, 1);
        // g.beginFill(0xFF00BB, .25);
        // g.drawRect(0, 0, this.width, this.height);
        // g.endFill();
        // this.addChild(g);
      }
    }
    Pool3.W = W1 * 4;
    Pool3.H = H1 * 11 + H1F;

    /**
     * 钢琴键
     * @typedef {object} PnoKy
     */
    class PnoKy extends PIXI.Container {
      // fg_ = null;  // 前景

      /**
       * @param {number} w 宽
       * @param {number} h 高
       * @param {function(PnoKy):void} cb 点击回调
       */
      constructor(w, h, cb) {
        super();

        //this.width = w;
        //this.height = h;

        let c = ()=>cb(this);
        let l = ()=>this.fg_.visible = true;
        let n = ()=>this.fg_.visible = false;

        let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
        bg.tint = 0;
        bg.alpha = .25;
        bg.width = w;
        bg.height = h;
        this.addChild(bg);

        let fg = this.fg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        fg.alpha = .25;
        fg.width = w;
        fg.height = h;
        this.addChild(fg);
        fg.visible = false;

        this.interactive = true;
        this.on('click', c);
        this.on('mouseover', l);
        this.on('mouseout', n);
        this.on('tap', c);
        this.on('touchstart', l);
        this.on('touchendoutside', n);
        this.on('touchend', n);
      }
    }

    /**
     * 三格钢琴
     * @typedef {object} Piano3
     */
    class Piano3 extends PIXI.Container {
      // s_ = null;  // 手牌
      // bc_ = null;  // 三组状态的钢琴相互切换
      // o_ = -1;  // 当前偏移

      /**
       * @param {number} w 总宽度
       * @param {array} s 手牌
       */
      constructor(w, s) {
        super();

        //this.width = w;
        //this.height = 220;

        let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
        bg.width = w;
        bg.height = 220;
        bg.tint = 0x0c1e2c;
        bg.alpha = .85;
        this.addChild(bg);

        let b = new EptBtn(w * .5, 80, ()=>this._o(-1));
        b.y = 140;
        this.addChild(b);

        b = new EptBtn(w * .5, 80, ()=>this._o(1));
        b.x = w * .5;
        b.y = 140;
        this.addChild(b);

        this.s_ = s;
        this.bc_ = new Array(3);  // 三组状态的钢琴相互切换
        this.o_ = -1;  // 当前偏移

        const WB = W0 * 3;
        let xs = -WB;  // 起始位置
        let xm = w - WB;  // 最大位置

        for (let k = 0; k < 3; ++k) {
          let bc = this.bc_[k] = new PIXI.Container();
          this.addChild(bc);

          let cvs = document.createElement('canvas');
          cvs.width = w;
          cvs.height = 140;
          let ctx = cvs.getContext('2d');
          ctx.lineWidth = 3;

          let ky = [];
          for (let i = 0; i < 7; ++i) {
            let x = xs + WB * i + k * W0;
            let w1 = WB;
            let xh = WB * .5;  // 一半的位置，画中线需要
            if (x < 0) {
              // 超出左边的
              w1 = WB + x;
              x = 0;
              xh = w1 - WB * .5;
            }
            else if (x > xm) {
              // 超出右边的
              w1 = WB - (x - xm);
              if (w1 < WB * .5) {
                xh = -1;
              }
            }

            if (w1 < 0) {
              break;
            }

            b = new PnoKy(w1, 140, function(k, b){
              let bc = this.bc_[k];
              let s = this.s_;
              let p = s[b.ri_];
              if (p && p.visible) {
                if (p.hlt) {
                  p.click();
                  p.hlt = false;
                }
                else {
                  p.hlt = true;
                  s.forEach(e=>e.hlt = (e === p));
                  bc.ky_.forEach(k=>k.fg_.visible = false);
                  b.fg_.visible = true;
                }
              }
            }.bind(this, k));
            b.x = x;
            bc.addChild(b);
            ky.push(b);
            b.ri_ = i * 3 + k - 2;

            if (xh > 0) {
              ctx.beginPath();
              ctx.moveTo(x + xh, 0);
              ctx.lineTo(x + xh, 75);

              // 以下代码：箭头状
              // ctx.moveTo(x + xh + 15, 25);
              // ctx.lineTo(x + xh, 5);
              // ctx.moveTo(x + xh - 15, 25);
              // ctx.lineTo(x + xh, 5);

              ctx.strokeStyle = '#ffffff';
              ctx.stroke();
            }
            ctx.beginPath();
            ctx.rect(x, 0, w1, 140);
            ctx.strokeStyle = '#808080';
            ctx.stroke();

            bc.addChild(new PIXI.Sprite(PIXI.Texture.from(cvs)));
          }
          bc.visible = (k === 0);
          bc.ky_ = ky;
        }

        let cvs = document.createElement('canvas');
        cvs.width = w;
        cvs.height = 220;
        let ctx = cvs.getContext('2d');
        ctx.lineWidth = 3;

        ctx.beginPath();
        ctx.moveTo(0, 220);
        ctx.lineTo(w, 220);

        // 左右移动中间的竖线
        ctx.moveTo(w * .5, 140);
        ctx.lineTo(w * .5, 220);
        ctx.strokeStyle = '#808080';
        ctx.stroke();

        // 左边的箭头
        ctx.beginPath();
        ctx.moveTo(w * .25 + 5, 175);
        ctx.lineTo(w * .25 - 5, 180);
        ctx.lineTo(w * .25 + 5, 185);

        // 右边的箭头
        ctx.moveTo(w * .75 - 5, 175);
        ctx.lineTo(w * .75 + 5, 180);
        ctx.lineTo(w * .75 - 5, 185);
        ctx.strokeStyle = '#ffffff';
        ctx.stroke();

        this.addChild(new PIXI.Sprite(PIXI.Texture.from(cvs)));
      }

      /**
       * 移动
       * @param {number} o 方向+右，-左
       */
      _o(o) {
        let s = this.s_;

        // 找到高亮的牌
        let hlt = s.findIndex(p=>(p && p.visible && p.hlt));

        if (hlt !== -1) {
          // 高亮的牌对应的钢琴
          let bc = this.bc_[(hlt + 2) % 3];
          if (bc.visible) {
            s[hlt].hlt = false;

            let p = s[hlt + o];
            if (p && p.visible) {
              p.hlt = true;
            }
          }
        }

        o = this.o_ + o;
        if (o > 1) o = -1;
        if (o < -1) o = 1;
        this.o_ = o;

        this.bc_.forEach((bc, k)=>{
          if (k !== (o + 1)) {
            bc.visible = false;
          }
          else {
            bc.visible = true;
            bc.ky_.forEach((k, i)=>{
              let ri = i * 3 + k - 2;
              let p = s[ri];
              k.fg_.visible = (p && p.visible && p.hlt);
            });
          }
        });
      }

      /**
       * 刷新
       */
      rfsh() {
        this.bc_.forEach((b)=>{
          if (b.visible) {
            let s = this.s_;
            b.ky_.forEach((k, i)=>{
              let ri = i * 3 + k - 2;
              let p = s[ri];
              k.fg_.visible = (p && p.visible && p.hlt);
            });
          }
        });
      }
    }
    Piano3.H = 220;

    /**
     * 二格钢琴
     * @typedef {object} Piano2
     */
    class Piano2 extends PIXI.Container {
      // s_ = null;  // 立牌
      // ky_ = null;  // 琴键

      /**
       * @param {number} w 总宽度
       * @param {array} s 手牌
       */
      constructor(w, s) {
        super();

        //this.width = w;
        //this.height = 200;

        let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
        bg.width = w;
        bg.height = 200;
        bg.tint = 0x0c1e2c;
        bg.alpha = .85;
        this.addChild(bg);

        this.s_ = s;
        this.ky_ = new Array(14);

        const WB = W0 * 2;
        let cb = (b)=>{
          let s = this.s_;
          let p = s[b.ri_];
          if (p && p.visible) {
            if (p.hlt) {
              p.click();
              p.hlt = false;
            }
            else {
              p.hlt = true;
              s.forEach(e=>e.hlt = (e === p));
              this.ky_.forEach(k=>k.fg_.visible = false);
              b.fg_.visible = true;
            }
          }
        };

        let cvs = document.createElement('canvas');
        cvs.width = w;
        cvs.height = 200;
        let ctx = cvs.getContext('2d');
        ctx.lineWidth = 3;
        ctx.fillStyle = '#ffffff';

        for (let i = 0; i < 7; ++i) {
          let x = WB * i;
          let b = this.ky_[i * 2] = new PnoKy(WB, 100, cb);
          b.x = x;
          this.addChild(b);
          b.ri_ = i * 2;

          ctx.fillRect(x, 0, W0, 10);
          ctx.moveTo(x + WB, 0);
          ctx.lineTo(x + WB, 100);
        }

        for (let i = 0; i < 6; ++i) {
          let x = W0 + WB * i;
          let b = this.ky_[i * 2 + 1] = new PnoKy(WB, 100, cb);
          b.x = x;
          b.y = 100;
          this.addChild(b);
          b.ri_ = i * 2 + 1;

          ctx.fillRect(x, 100, W0, 10);
          ctx.moveTo(x, 100);
          ctx.lineTo(x, 200);
        }

        {
          let x = W0 + WB * 6;
          let w1 = w - WB * 6.5;
          let b = this.ky_[13] = new PnoKy(w1, 100, cb);
          b.x = x;
          b.y = 100;
          this.addChild(b);
          b.ri_ = 13;

          ctx.fillRect(x, 100, W0, 10);
          ctx.moveTo(x, 100);
          ctx.lineTo(x, 200);
        }

        ctx.rect(0, 0, w, 200);
        ctx.moveTo(0, 100);
        ctx.lineTo(w, 100);

        ctx.strokeStyle = '#808080';
        ctx.stroke();

        this.addChild(new PIXI.Sprite(PIXI.Texture.from(cvs)));
      }

      /**
       * 刷新
       */
      rfsh() {
        let s = this.s_;
        this.ky_.forEach((k, i)=>{
          let p = s[i];
          k.fg_.visible = (p && p.visible && p.hlt);
        });
      }
    }
    Piano2.H = 200;


    /**
     * 一手和牌
     * @typedef {object} WinHand
     */
    class WinHand extends PIXI.Container {
      /**
       * @param {JSON} h 手牌
       * @param {number} w 和牌
       * @param {number} f 花牌数
       */
      constructor(h, w, f) {
        super();

        const h0 = Math.max(H1 + H1F, H0 + 40);
        let x = 0;

        // 副露
        let p = h['p'];
        if (p) {
          const y = h0 - H0F, y0 = h0 - H1F;
          p.forEach(e=>{
            let s = [], c = pk_tp(e), t = pk_tl(e), o = pk_ofr(e);
            let z = new_ca(0, c, t, o, s);

            // 自己的暗杠要显示出来
            if (c === 2 && o === 0) {
              s[1] = new PlTl0(t);
              s[2] = new PlTl0(t);
            }

            if (x !== 0) x += GF;

            let p = [];
            switch (z) {
            case 0:  // 鸣上家
              p.push({x:x, y:y0}, {x:(x + W1), y:y}, {x:(x + W1 + W0), y:y});
              x += W0 * 2 + W1;
              if (c === 2) { p.push({x:(x + W1 + W0 * 2), y:y}); x += W0; }
              break;
            case 1:  // 鸣对家
              p.push({x:x, y:y}, {x:(x + W0), y:y0}, {x:(x + W1 + W0), y:y});
              x += W0 * 2 + W1;
              if (c === 2) { p.push({x:(x + W1 + W0 * 2), y:y}); x += W0; }
              break;
            case 2:  // 鸣下家
              p.push({x:x, y:y}, {x:(x + W0), y:y});
              if (c !== 2) { p.push({x:(x + W0 * 2), y:y0}); x += W0 * 2 + W1; }
              else { p.push({x:(x + W0 * 2), y}, {x:(x + W0 * 3), y:y0}); x += W0 * 3 + W1; }
              break;
            case 3:  // 暗杠
              p.push({x:x, y:y}, {x:(x + W0), y:y}, {x:(x + W0 * 2), y:y}, {x:(x + W0 * 3), y:y});
              x += W0 * 4;
              break;
            case 4:  // 碰上家，加杠
              p.push({x:x, y:(y0 - H1)}, {x:x, y:y0}, {x:(x + W1), y:y}, {x:(x + W1 + W0), y:y});
              x += W0 * 3 + W1;
              break;
            case 5:  // 碰对家，加杠
              p.push({x:x, y:y}, {x:(x + W0), y:(y0 - H1)}, {x:(x + W0), y:y0}, {x:(x + W1 + W0), y:y});
              x += W0 * 3 + W1;
              break;
            case 6:  // 碰下家，加杠
              p.push({x:x, y:y}, {x:(x + W0), y:y}, {x:(x + W0 * 2), y:(y0 - H1)}, {x:(x + W0 * 2), y:y0});
              x += W0 * 3 + W1;
              break;
            }
            s.forEach((e, i)=>{
              this.addChild(e);
              e.position = p[i];
            });
          });
          x += GP;
        }

        // 立牌
        let s = h['s'];
        if (s) {
          s.forEach(e=>{
            let p = new PlTl0(e);
            this.addChild(p);
            p.x = x;
            p.y = h0 - H0F;
            x += W0;
          });
          x += GP;
        }

        // 和牌
        if (typeof w !== 'undefined') {
          let p = new PlTl0(w);
          this.addChild(p);
          p.x = x;
          p.y = h0 - H0F;
          x += W0;
        }

        // 花
        if (f) {
          let s = new PIXI.Sprite(T64.F);
          this.addChild(s);
          s.scale.set(.6);
          s.anchor.set(.5);
          s.x = x - 55;
          s.y = 15;

          let t = new PIXI.Text(`\u00D7 ${f}`, {
            fontFamily: FF,
            fontSize: 18,
            fill: '#ffffff',
            padding: 10
          });
          this.addChild(t);
          t.anchor.set(.5);
          t.x = x - 25;
          t.y = 15;
        }

/*
        // 范围测试
        {
        let bg = new PIXI.Graphics();
        this.addChild(bg);
        bg.lineStyle(2, 0x0000FF, 1);
        bg.beginFill(0xFF00BB, .25);
        bg.drawRect(0, 0, x, h0);
        bg.endFill();
        }
*/
      }
    }


    /**
     * 结算界面中的每一项番
     * @param {number} f 番种索引
     * @param {number} v 番值
     */
    function fan_item(f, v) {
      let c = hibyte(v) + 1, p = lobyte(v);
      return `${tz.ls('FanName'+f)} ${c===1?`${tz.ls('FanPoint', p)}`:`${tz.ls('FanPoint', p)}\x20\u00D7\x20${c}`}`;
    }

    /**
     * 创建番表每行3个
     * @param {number} w 宽度
     * @param {JSON} f 番表
     */
    function fan_tbl3(w, f) {
      let c = new PIXI.Container();
      let i = 0;
      const w0 = w / 3;
      for (let e in f) {
        let x = 5 + (i % 3) * w0;
        let y = 10 + 35 * Math.floor(i / 3);

        let t = new PIXI.Text(fan_item(e, f[e]), {
          fontFamily: FF,
          fontSize: tz.ffs,
          fill: '#99ffff',
          padding: 10
        });
        c.addChild(t);
        t.anchor.y = .5;
        t.x = x;
        //t.x = w0 + gap; t.anchor.x = 1;
        t.y = y;
        scl_txt(t, w0 - 10);
        ++i;
      }

      return c;
    }

    /**
     * 结算界面
     * @typedef {object} Settle
     */
    class Settle extends AutoTgl {
      // ic_ = null;  // 内部容器

      // ht = {"s":[22,22,22,23,35,35,35,38,39,40,52,53,54]}
      // wt = 21
      // ft = {"50":6,"62":2,"68":2}
      // dt = {"r":0,"f":10,"p":0x0103,"t":[34,-8,-8,-18],"s":[34,-8,-8,-18],"n":[0,0,0,0]}
      // ns = ['东','南','西','北']
      // vs = 1
      /**
       * @param {JSON} h 手牌
       * @param {number} w 和牌
       * @param {JSON} f 番表
       * @param {JSON} d 详情
       * @param {array} n 玩家名字
       * @param {number} v 视角
       * @param {number} c 倒时计
       * @param {function(Settle):void} cb 关闭回调
       */
      constructor(h, w, f, d, n, v, c, cb) {
        super();

        const w0 = Settle.W, h0 = Settle.H, gap = 20;

        let bg = this.ic_ = new PIXI.Graphics();
        this.addChild(bg);
        bg.interactive = true;

        // 和牌展示
        if (h && f) {
          (function(){
            let wh = new WinHand(h, w, hibyte(f['81']) + 1);
            bg.addChild(wh);
            wh.y = gap;
            if (wh.width > w0 - gap * 2) {
              wh.scale.set((w0 - gap * 2) / wh.width);
              wh.x = gap;
            }
            else {
              wh.x = (w0 - wh.width) * .5;
            }
          })();
        }

        // 谁和牌谁点炮
        let cl = -1, wn = -1;
        (function(){
          let p = d['p'];
          if (typeof p === 'undefined') {
            p = -1;
          }
          if (p >= 0) {
            cl = lobyte(p);
            wn = hibyte(p);
          }

          let tx = '';
          let f = d['f'];
          if (p < 0) {
            tx = tz.ls('Tie');
          }
          else {
            tx = cl !== wn ? tz.ls('ShootBrief', n[wn], n[cl], f) : tz.ls('SelfDrawnBrief', n[wn], f);
          }
          let t = new PIXI.Text(tx, {
            fontFamily: FF,
            fontSize: 26,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.x = .5;
          t.x = w0 * .5;
          t.y = 135;
          scl_txt(t, w0 - gap * 2);
        })();

        // 罗列番种
        (function(){
          let c = fan_tbl3(w0 - gap * 2, f);
          bg.addChild(c);
          c.x = gap;
          c.y = 185;
        })();

        // 结算四家
        (function(){
          const x1 = 200, /*y1 = 400,*/ w1 = 200, h1 = 100;
          let cx = Float32Array.of(w0 * .5, w0 - gap - x1 * .5, w0 * .5, gap + x1 * .5);
          let cy = Float32Array.of(h0 - gap - h1 * .5, h0 - h1 - gap * 2.5, h0 - h1 * 1.5 - gap * 4, h0 - h1 - gap * 2.5);

          // 中间的x风x
          let t = new PIXI.Text(tz.ls('Order' + d['r']), {
            fontFamily: 'sans-serif',
            fontSize: 32,
            fontWeight: 'bold',
            fill: '#ffffff',
            stroke: '#808080',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.set(.5);
          t.x = w0 * .5;
          t.y = cy[1];


          // 本盘得分、本盘罚分、累计分数
          let s = d['s'] || new Uint8Array(4), p = d['n'], a = d['t'];

          // 四家得分
          for (let i = 0; i < 4; ++i) {
            let k = (i + v) & 3;

            // 背景板
            let g = new PIXI.Sprite(PIXI.Texture.WHITE);
            g.tint = (k != wn ? (k != cl ? 0xbbded6 : 0x89a4c7) : 0xffaaa5);
            g.alpha = .5;
            g.width = w1;
            g.height = h1;
            bg.addChild(g);
            g.x = cx[i] - w1 * .5;
            g.y = cy[i] - h1 * .5;

            // 门风
            let t = new PIXI.Text(tz.ls(WIND[i]), {
              fontFamily: 'sans-serif',
              fontSize: 48,
              fontWeight: 'bold',
              fill: '#ffffff',
              stroke: '#808080',
              strokeThickness: 2,
              lineJoin: 'round',
              padding: 10
            });
            bg.addChild(t);
            t.anchor.y = .5;
            t.x = cx[i] - w1 * .5 + 10;
            t.y = cy[i] + 15;

            // 昵称
            t = new PIXI.Text(n[k], {
              fontFamily: FF,
              fontSize: 24,
              fontWeight:'bold',
              fill: '#ffffff',
              //stroke: '#0066ff',
              //strokeThickness: 2,
              //lineJoin: 'round',
              padding: 10
            });
            bg.addChild(t);
            t.anchor.set(.5);
            t.x = cx[i];
            t.y = cy[i] - 30;
            scl_txt(t, w1 - 10);

            // 本盘得分+罚分
            let xx = cx[i] + 25;
            let p0 = p[k];
            t = new PIXI.Text(`${tz.ls('CT')} ${psgn(s[k])}${p0===0?'':psgn(p0)}`, {
              fontFamily: FF,
              fontSize: 20,
              fill: '#ffffff',
              //stroke: '#0066ff',
              //strokeThickness: 2,
              //lineJoin: 'round',
              padding: 10
            });
            bg.addChild(t);
            t.anchor.set(.5);
            t.x = xx;
            t.y = cy[i] + 2;

            // 累计得分
            t = new PIXI.Text(`${tz.ls('ST')} ${psgn(a[k])}`, {
              fontFamily: FF,
              fontSize: 20,
              fill: '#ffffff',
              //stroke: '#0066ff',
              //strokeThickness: 2,
              //lineJoin: 'round',
              padding: 10
            });
            bg.addChild(t);
            t.anchor.set(.5);
            t.x = xx;
            t.y = cy[i] + 32;

            // 错和标记
            if (p0 < 0) {
              t = new PIXI.Text(tz.ls('FalseHu'), {
                fontFamily: FF,
                fontSize: 16,
                fill: '#ffffff',
                stroke: '#000000',
                strokeThickness: 2,
                lineJoin: 'round',
                padding: 10
              });
              bg.addChild(t);
              t.anchor.y = .5;
              t.x = cx[i] - w1 * .5 + 10;
              t.y = cy[i] + 35;
            }
          }
        })();

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w0, h0);
        bg.endFill();

        const w1 = 120, h1 = 50;

        let t = new PIXI.Text(c, {
          fontFamily: FF,
          fontSize: 18,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.set(1);
        t.x = w1;
        t.y = h1;

        // 倒计时
        t.ct_ = c;
        t.end_ = new Date().getTime() + c * 1000;
        t.timer_ = setInterval(()=>{
          let n = (t.end_ - new Date().getTime());
          let s = Math.round(n / 1000);
          if (s > 0) {
            if (s !== t.ct_) {
              t.ct_ = s;
              t.text = s;
              if (s <= 3) {
                tz.play('snd/03-cd.wav');
              }
            }
          }
          else {
            t.text = '0';
            clearInterval(t.timer_);
            t.timer_ = null;
            cb(this);
          }
        }, 100);

        let b = new TxtBtn('OK', {
          fontFamily: FF,
          fontSize: 36,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=> {
          clearInterval(t.timer_);
          t.timer_ = null;
          cb(this);
        });
        bg.addChild(b);
        b.x = w0 - w1 - gap;
        b.y = h0 - h1 - gap;
        b.addChild(t);
      }

      /**
       * 外部按下，由子类自己实现
       */
      outdown() {
        this.ic_.visible = false;
      }

      /**
       * 外部松开，由子类自己实现
       */
      outup() {
        this.ic_.visible = true;
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        super.layt();
        const w0 = Settle.W, h0 = Settle.H, s0 = Settle.S;
        let c = this.ic_, s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale Settle =', s);
      }
    }
    Settle.W = 760;
    Settle.H = 650;
    Settle.S = .95;

    /**
     * 错和界面
     * @typedef {object} FalseWin
     */
    class FalseWin extends AutoTgl {
      // ic_ = null;  // 内部容器

      /**
       * @param {number} n 番数
       * @param {JSON} f 番表
       */
      constructor(n, f) {
        super();

        const w0 = 500, gap = 20;
        let y = 0;

        let bg = this.ic_ = new PIXI.Graphics();
        this.addChild(bg);
        bg.interactive = true;

        let t = new PIXI.Text(tz.ls('FalseWinTitle', n), {
          fontFamily: FF,
          fontSize: 26,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.x = .5;
        t.x = w0 * .5;
        t.y = gap;

        let i = 0;
        const frp = (w0 - gap * 2) / 2;
        for (let e in f) {
          let x0 = gap + (i & 1) * frp;
          let y0 = 70 + 35 * (i >> 1);

          let t = new PIXI.Text(fan_item(e, f[e]), {
            fontFamily: FF,
            fontSize: tz.ffs,
            fill: '#99ffff',
            padding: 10
          });
          bg.addChild(t);
          scl_txt(t, frp - 10);
          t.x = x0;
          //t.x = frp + gap; t.anchor.x = 1;
          t.y = y0;
          y = y0;

          ++i;
        }

        let h0 = Math.max(y + 150, 340);

        t = new PIXI.Text(tz.ls('FalseWinHint'), {
          fontFamily: FF,
          fontSize: 22,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.x = .5;
        t.x = w0 * .5;
        t.y = h0 - 110;
        scl_txt(t, w0 - gap * 2);

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w0, h0);
        bg.endFill();

        const w1 = 120, h1 = 50;
        let b = new TxtBtn('OK', {
          fontFamily: FF,
          fontSize: 36,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>{
          this.dsty();
        });
        bg.addChild(b);
        b.x = w0 - w1 - gap;
        b.y = h0 - h1 - gap;

        this.w_ = w0;
        this.h_ = h0;
      }

      /**
       * 外部按下，由子类自己实现
       */
      outdown() {
        this.ic_.visible = false;
      }

      /**
       * 外部松开，由子类自己实现
       */
      outup() {
        this.ic_.visible = true;
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        super.layt();
        let c = this.ic_, w0 = this.w_, h0 = this.h_, s0 = FalseWin.S;
        let s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale FalseWin =', s);
      }
    }
    FalseWin.S = .95;

    /**
     * 游戏结束界面
     * @typedef {object} Result
     */
    class Result extends PIXI.Container {
      /**
       * @param {string} s 标题
       * @param {number} v 视角
       * @param {array} p 玩家
       * @param {Date} u 时间戳（服务器）
       * @param {function(object):void} cb 关闭回调
       */
      constructor(s, v, p, u, cb) {
        super();

        let g = this.ic_ = new PIXI.Graphics();
        this.addChild(g);

        // 600*540
        // 表格与背景边距50，表格行高60
        // 名次、昵称、得分 列宽80+300+120=500,500+50*2=600
        const w0 = Result.W, h0 = Result.H;

        g.lineStyle(2, 0x26608C, 1);
        g.beginFill(0x060F16, .85);
        g.drawRect(0, 0, w0, h0);
        g.endFill();

        let cvs = document.createElement('canvas');
        cvs.width = w0;
        cvs.height = h0;
        let ctx = cvs.getContext('2d');
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ffffff';
        ctx.rect(50, 110, 500, 300);

        // 横线
        for (let i = 1; i < 5; ++i) {
          ctx.moveTo(50, 110 + 60 * i);
          ctx.lineTo(550, 110 + 60 * i);
        }

        // 竖线
        ctx.moveTo(130, 110);
        ctx.lineTo(130, 110 + 60 * 5);

        ctx.moveTo(430, 110);
        ctx.lineTo(430, 110 + 60 * 5);

        ctx.stroke();

        let sp = new PIXI.Sprite(PIXI.Texture.from(cvs));
        g.addChild(sp);
        sp.tint = 0x808080;

        let t = new PIXI.Text(tz.ls('GameResult'), {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        g.addChild(t);
        t.anchor.set(.5);
        t.x = w0 * .5;
        t.y = 35;
        scl_txt(t, w0 - 20);

        t = new PIXI.Text(s, {
          fontFamily: FF,
          fontSize: 22,
          fill: '#ffffff',
          padding: 10
        });
        g.addChild(t);
        t.anchor.set(.5);
        t.x = w0 * .5;
        t.y = 80;
        scl_txt(t, w0 - 20);

        // 每列中心位置
        const xx = Float32Array.of(90, 280, 490);

        // 表头
        ['Rank', 'Nickname', 'Scores']
        .forEach((e, i)=>{
          let t = new PIXI.Text(tz.ls(e), {
            fontFamily: FF,
            fontSize: 24,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
          });
          g.addChild(t);
          t.anchor.set(.5);
          t.x = xx[i];
          t.y = 140;
        });

        p.forEach((e, i)=>{
          let y = 200 + 60 * i, f = (v !== e['w']);  // 自己显示为青色
          [i + 1, e['n'], e['s']].forEach((a, k)=>{
            let t = new PIXI.Text(a, {
              fontFamily: FF,
              fontSize: 24,
              fontWeight: k !== 1 ? 'bold' : '',
              fill: f ? '#ffffff' : '#5cdbd3',
              padding: 10
            });
            g.addChild(t);
            t.x = xx[k];
            t.y = y;
            t.anchor.set(.5);
            if (k === 1) scl_txt(t, 280);
          });
        });

        // 时间
        t = new PIXI.Text(
          (function(ud) {
            let y = ud.getFullYear(),
              m = ud.getMonth() + 1,
              d = ud.getDate(),
              h = ud.getHours(),
              mm = ud.getMinutes(),
              s = ud.getSeconds(),
              o = ud.getTimezoneOffset();
            let oa = Math.abs(o), oh = Math.floor(oa / 60), om = oa - oh * 60;
            return `${y}-${pad2(m)}-${pad2(d)} ${pad2(h)}:${pad2(mm)}:${pad2(s)}  UTC${o<=0?'+':'-'}${pad2(oh)}:${pad2(om)}`;
          })(new Date(u)), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        g.addChild(t);
        t.anchor.set(.5);
        t.x = w0 * .5;
        t.y = h0 - 105;

        const w1 = 120, h1 = 50;
        let b = new TxtBtn('OK', {
          fontFamily: FF,
          fontSize: 36,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>cb(this));
        g.addChild(b);
        b.x = (w0 - w1) * .5;
        b.y = h0 - h1 - 30;
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        const w0 = Result.W, h0 = Result.H, s0 = Result.S;
        let c = this.ic_, s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale Result =', s);
      }
    }
    Result.W = 600;
    Result.H = 540;
    Result.S = .95;

    /**
     * 和牌简介
     * @typedef {object} WinBrf
     */
    class WinBrf extends PIXI.Container {
      /**
       * @param {number} r 盘序
       * @param {JSON} b 和牌详情
       */
      constructor(r, b) {
        super();

        const w0 = 700, gap = 20;

        let bg = new PIXI.Graphics();
        this.addChild(bg);
        bg.interactive = true;

        let t = new PIXI.Text(tz.ls('Order' + r), {
            fontFamily: FF,
            fontSize: 32,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = 350;
        t.y = 40;

        // 手牌、和牌张、番表
        let h = b['h'], w = b['w'], f = b['f'], n = ((f)=>{
          let n = 0;
          for (let e in f) {
            let v = f[e], c = hibyte(v) + 1, p = lobyte(v);
            n += p * c;
          }
          return n;
        })(f);
        let wh = new WinHand(h, w, hibyte(f['81']) + 1);
        bg.addChild(wh);
        wh.y = 65;
        if (wh.width > w0 - gap * 2) {
          wh.scale.set((w0 - gap * 2) / wh.width);
          wh.x = gap;
        }
        else {
          wh.x = (w0 - wh.width) * .5;
        }

        let ftb = fan_tbl3(w0 - gap * 2, f);
        bg.addChild(ftb);
        ftb.x = gap;
        ftb.y = 190;

        let h0 = 210 + ftb.height;

        t = new PIXI.Text(tz.ls('TotalFans', n), {
            fontFamily: FF,
            fontSize: 26,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
        });
        bg.addChild(t);
        t.anchor.x = .5;
        t.x = w0 * .5;
        t.y = h0;

        h0 += 50;

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w0, h0);
        bg.endFill();
      }
    }

    /**
     * 根据一盘得分计算谁点炮，谁和牌
     * @param {array} s 本盘得分
     * @return {JSON} {w:0,c:0}
     */
    function calcwc(s) {
      // 正分的人和牌
      let i = s.findIndex(e=>e > 0);
      if (i !== -1) {
        if (s[(i + 1) & 3] === s[(i + 2) & 3] && s[(i + 1) & 3] == s[(i + 3) & 3]) {
          // 另外三家扣分一样，说明是自摸
          return {w:i};
        } else {
          // 扣得最多的人是点炮
          let n = 0, c = -1;
          for (let k = (i + 1) & 3; k != i; k = (k + 1) & 3) {
            if (s[k] < n) {
              n = s[k];
              c = k;
            }
          }
          return {w:i,c:c};
        }
      } else {
        // 荒庄
        return {w:-1};
      }
    }

    /**
     * 计分表界面
     * @typedef {object} HstTbl
     */
    class HstTbl extends AutoHide {
      // ic_ = null;  // 内部容器
      // cb_ = null;  // 回调
      // nt_ = null;  // 昵称
      // gt_ = null;  // 合计
      // st_ = null;  // 每一行的得分/累计
      // hb_ = null;  // 每一行的按钮

      constructor() {
        super();

        const w = HstTbl.W, h = HstTbl.H;

        //this.width = w;
        //this.height = h;

        this.bf_ = new Array(16);

        let bg = this.ic_ = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w, h);
        bg.endFill();
        bg.interactive = true;
        bg.on('click', this._xbrf.bind(this));
        bg.on('tap', this._xbrf.bind(this));

        let t = new PIXI.Text(tz.ls('History'), {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = w * .5;
        t.y = 35;

        let cvs = document.createElement('canvas');
        cvs.width = w;
        cvs.height = h;
        let ctx = cvs.getContext('2d');
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ffffff';
        ctx.rect(30, 70, w - 60, 760);

        t = new PIXI.Text(tz.ls('Nickname'), {
          fontFamily: FF,
          fontSize: 20,
          fontWeight: 'bold',
          fill: '#dcdcdc',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        scl_txt(t, 75);
        t.x = 70;
        t.y = 90;

        let nt = new Array(4), gt = new Array(4);
        for (let i = 0; i < 4; ++i) {
          // 昵称
          t = nt[i] = new PIXI.Text('', {
            fontFamily: FF,
            fontSize: 20,
            fontWeight: 'bold',
            fill: '#ffd700',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.set(.5);
          t.x = 190 + 160 * i;
          t.y = 90;

          // 合计
          t = gt[i] = new PIXI.Text('', {
            fontFamily: FF,
            fontSize: 20,
            fontWeight: 'bold',
            fill: '#ffd700',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.set(.5);
          t.x = 190 + 160 * i;
          t.y = 810;
        }
        this.nt_ = nt;
        this.gt_ = gt;

        // 子标题
        t = new PIXI.Text(tz.ls('Order'), {
          fontFamily: FF,
          fontSize: 20,
          fontWeight: 'bold',
          fill: '#dcdcdc',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        scl_txt(t, 75);
        t.x = 70;
        t.y = 130;

        for (let i = 0; i < 8; ++i) {
          t = new PIXI.Text(tz.ls(i & 1 ? 'ST' : 'CT'), {
            fontFamily: FF,
            fontSize: 20,
            fontWeight: 'bold',
            fill: '#dcdcdc',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.set(.5);
          scl_txt(t, 75);
          t.x = 150 + i * 80;
          t.y = 130;
        }

        // 子标题与上方的分隔横线
        ctx.moveTo(30, 110);
        ctx.lineTo(w - 30, 110);

        // 每一盘
        let st = new Array(16);
        let hb = new Array(16);
        let b;
        for (let i = 0; i < 16; ++i) {
          let yy = 170 + i * 40;
          b = hb[i] = new HvrBtn(w - 60, 40, this._hvrchg.bind(this, i));
          bg.addChild(b);
          b.x = 30;
          b.y = yy - 20;

          // 盘序名
          t = new PIXI.Text(tz.ls('Order' + i), {
            fontFamily: FF,
            fontSize: 20,
            fontWeight: 'bold',
            fill: '#dcdcdc',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.set(.5);
          t.x = 70;
          t.y = yy;

          // 偶数列是当前盘，奇数列是累计
          st[i] = new Array(8);
          for (let k = 0; k < 8; ++k) {
            t = st[i][k] = new PIXI.Text('', {
              fontFamily: FF,
              fontSize: 20,
              fontWeight: 'bold',
              padding: 10
            });
            bg.addChild(t);
            t.anchor.set(.5);
            t.x = 150 + k * 80;
            t.y = yy;
          }

          // 每列与上方的分隔横线
          ctx.moveTo(30, yy - 20);
          ctx.lineTo(w - 30, yy - 20);
        }
        this.hb_ = hb;
        this.st_ = st;

        t = new PIXI.Text(tz.ls('GT'), {
          fontFamily: FF,
          fontSize: 20,
          fontWeight: 'bold',
          fill: '#dcdcdc',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = 70;
        t.y = 810;

        // 合计上方的横线
        ctx.moveTo(30, 790);
        ctx.lineTo(w - 30, 790);

        // 每列一长一短两条竖线
        for (let i = 0; i < 4; ++i) {
          let xx = 110 + 160 * i;
          ctx.moveTo(xx, 70);
          ctx.lineTo(xx, 830);
          xx += 80;
          ctx.moveTo(xx, 110);
          ctx.lineTo(xx, 790);
        }
        ctx.stroke();

        let sp = new PIXI.Sprite(PIXI.Texture.from(cvs));
        bg.addChild(sp);
        sp.tint = 0x808080;

        const w1 = 120, h1 = 50;
        b = new TxtBtn('OK', {
          fontFamily: FF,
          fontSize: 36,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>this.visible = false);
        bg.addChild(b);
        b.x = (w - w1) * .5;
        b.y = h - h1 - 20;
      }

      /**
       * 初始化
       */
      init() {
        this.nt_.forEach(e=>e.visible = false);
        this.gt_.forEach(e=>e.visible = false);
        this.st_.forEach(e=>e.forEach(l=>l.visible = false));
        this.hb_.forEach(e=>e.visible = false);
      }

      /**
       * 设置
       * @param {array} n 玩家昵称
       */
      setup(n) {
        this.nt_.forEach((e, i)=>{ e.visible = true; e.text = n[i]; });
        this.gt_.forEach(e=>{ e.visible = true; e.text = ''; });
        this.bf_.fill({});  // NOTE: 可能有问题
      }

      /**
       * 添加数据
       * @param {number} o 盘序
       * @param {array} s 本盘得分
       * @param {array} p 本盘罚分
       * @param {array} t 累计
       * @param {JSON} h 手牌
       * @param {number} w 和牌张
       * @param {JSON} f 番表
       */
      add(o, s, p, t, h, w, f) {
        let st = this.st_[o];

        // 转换座位
        function os(o, a) {
          let i = St2Ogn[o];
          return [a[i[0]], a[i[1]], a[i[2]], a[i[3]]];
        }
        s = os(o, s);
        p = os(o, p);
        t = os(o, t);

        // 累计
        this.gt_.forEach((e, i)=>{
          e.text = t[i];
          e.visible = true;
        });

        // 偶数列是当前盘，奇数列是累计
        [
          s[0] + p[0], t[0],
          s[1] + p[1], t[1],
          s[2] + p[2], t[2],
          s[3] + p[3], t[3]
        ].forEach((e, i)=>{
          st[i].text = e;
          st[i].visible = true;
        });

        // 颜色设置
        let r = calcwc(s), i = r['w'];
        if (i !== -1) {
          let c = r['c'];
          for (let k = 0; k < 8; ++k) {
            let e = st[k];
            if (k & 1) {
              // 奇数列是累计，灰色
              e.style.fill = '#dcdcdc';
            } else {
              // 偶数列是当前盘，和牌红色，点炮蓝色，错和紫色，其他绿色
              let n = k >> 1;
              if (n === i) {
                e.style.fill = '#ff6a6a';
              }
              else if (n === c) {
                e.style.fill = '#00bfff';
              }
              else if (p[n] < 0) {
                e.style.fill = '#da70d6';
              }
              else {
                e.style.fill = '#00cd66';
              }
            }
          }

          // 添加记录
          this.bf_[o] = {h:h, w:w, f:f};
          this.hb_[o].visible = true;
        } else {
          // 荒庄
          st.forEach(e=>e.style.fill = '#dcdcdc');
          this.bf_[o] = {};
        }
      }

      /**
       * 显示
       * @param {array} n 名字
       * @param {array} s 得分
       * @param {array} p 罚分
       * @param {number} o 盘序
       * @param {number} l 初始分
       * @param {number} b 负底分（底分的相反数）
       */
/*
      show(n, s, p, o, l, b) {
        this.visible = true;

        let nt = this.nt_, gt = this.gt_, st = this.st_, hb = this.hb_;

        let tl = new Int16Array(4).fill(l);  // 每盘结束后的分数
        let ors = new Int16Array(4);  // 每圈得分
        let orp = new Int16Array(4);  // 每圈罚分

        for (let i = 0; i < 16; ++i) {
          if (i < o) {  // 已打的盘
            for (let k = 0; k < 4; ++k) {
              ors[k] = s[k][i];
              orp[k] = p[k][i];
            }
            let sd = ors.every(function(b, e){return e !== b;}.bind(this, b));  // 每个人的得分都不等于底分，就是自摸
            let tie = ors.every(e=>e === 0);  // 荒庄
            hb[i].visible = true;

            // 偶数列是当前盘，奇数列是累计
            for (let k = 0; k < 8; ++k) {
              let tx = '', cl = '#dcdcdc';
              let rs = ors[k >> 1], rp = orp[k >> 1];
              let rr = rs + rp;
              if (k & 1) {
                // 累计
                tl[k >> 1] += rr;
                rr = tl[k >> 1];
              }
              else {
                // 当前盘
                if (!tie) {
                  cl = (rs < 0) ? ((rs == b || sd) ? '#00cd66' : '#00bfff') : '#ff6a6a';
                }
              }
              tx = rr;

              let t = st[i][k];
              t.text = tx;
              t.style.fill = cl;
              t.visible = true;
            }
          }
          else {  // 未打的盘
            hb[i].visible = false;
            st[i].forEach(t=>t.visible = false);
          }
        }

        for (let i = 0; i < 4; ++i) {
          let t = nt[i];
          t.text = n[i];
          scl_txt(t, 130);

          t = gt[i];
          t.text = tl[i];
        }
      }
*/
      /**
       * 掉线重联时的恢复
       * @param {JSON} p 玩家
       * @param {JSON} b 和牌信息
       */
      rcvr(p, b) {
        //测试数据
        //p=
        //[
        //  {"n":"aaa","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},
        //  {"n":"bbb","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},
        //  {"n":"ccc","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},
        //  {"n":"ddd","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
        //];
        //this.winBriefs_ = r['b'];  // 历史和牌记录

        this.init();

        // 根据当前盘序，将座位转换成开局座位
        let o = b.length, m = St2Ogn[o];

        // 昵称
        this.nt_.forEach((e, i)=>{ e.visible = true; e.text = p[m[i]]['n']; });

        let t = [0, 0, 0, 0];  // 累计
        b.forEach((e, o)=>{
          // 本盘得分，罚分，本盘小计
          let s = [0, 0, 0, 0], n = [0, 0, 0, 0], a = [0, 0, 0, 0];
          for (let k = 0; k < 4; ++k) {
            let i = m[k], u = p[i];  // 转换座位
            s[i] = u['rs'];
            n[i] = u['rp'];
            a[i] = s[i] + n[i];
            t[i] += a[i];  // 累计
          }

          let st = this.st_[o];
          a.forEach((v, i)=>{
            let e = st[i << 1];
            e.text = v;
            e.style.fill = '#dcdcdc';
            e.visible = true;
          });

          t.forEach((v, i)=>{
            let e = st[(i << 1) + 1];
            e.text = v;
            e.visible = true;
          });

          let r = calcwc(s), i = r['w'];
          if (i !== -1) {
            let c = r['c'];
            for (let k = 0; k < 8; ++k) {
              if (!(k & 1)) {
                let e = st[k], l = k >> 1;
                if (l === i) {
                  e.style.fill = '#ff6a6a';
                }
                else if (l === c) {
                  e.style.fill = '#00bfff';
                }
                else if (p[l] < 0) {
                  e.style.fill = '#da70d6';
                }
                else {
                  e.style.fill = '#00cd66';
                }
              }
            }

            this.bf_[o] = {h:e['h'], w:e['w'], f:e['f']};
            this.hb_[o].visible = true;
          } else {
            // 荒庄
            st.forEach(e=>e.style.fill = '#dcdcdc');
            this.bf_[o] = {};
          }
        });

        this.gt_.forEach((e, i)=>{ e.visible = true; e.text = t[i]; });
      }

      /**
       * 关闭和牌简介
       */
      _xbrf() {
        let wb = this.wb_;
        if (wb) {
          wb.dsty();
          this.wb_ = null;
        }
      }

      /**
       * 回调
       * @param {number} i 下标
       * @param {HvrBtn} h 当前的按钮
       * @param {number} s 状态
       */
      _hvrchg(i, h, s) {
        //console.log('_hvrchg', i, h, s);
        let wb = this.wb_;
        if (s) {
          // 移出的时候，删除旧的，生成新的
          if (wb) {
            wb.dsty();
            this.wb_ = null;
          }

          // 测试数据
          //let d = {"f":8,"h":{"p":[0x21B],"s":[69,70,75,76,81,97,104,105,106,107,100]},"t":{"44":8,"46":8,"55":4,"56":4,"58":4,"60":2,"61":2,"64":2,"66":2,"67":2,"72":1,"73":1,"75":1,"78":1,"81":0x101}};
          let d = this.bf_[i];
          if (d && d['f']) {
            let c = this.ic_;
            wb = this.wb_ = new WinBrf(i, d);
            c.addChild(wb);
            wb.rd_ = i;

            // 和牌简介放置的位置
            //let bg = h.parent;
            let p = c.toLocal(h.position, c);

            // 80为列宽，使之不覆盖盘序一列
            wb.x = p.x + 80;

            // 先尝试往这一行的下方布局，如果空间不够，再改为往上布局
            let y = p.y + h.height;
            if (y + wb.height < HstTbl.H) {
              wb.y = y;
            }
            else {
              wb.y = p.y - wb.height;
            }
          }
        }
        else {
          // 移出的时候，删除旧的
          if (wb && wb.rd_ === i) {
            wb.dsty();
            this.wb_ = null;
          }
        }
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        super.layt();
        const w0 = HstTbl.W, h0 = HstTbl.H, s0 = HstTbl.S;
        let c = this.ic_, s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale HstTbl =', s);
      }
    }
    // 9列，昵称+行标题+16盘+合计=19行
    // 左右各30边距，列宽80：80*9+30*2=780
    // 标题70，下方110（边距20，按钮70），列高40：70+110+40*19=940
    HstTbl.W = 780;
    HstTbl.H = 940;
    HstTbl.S = .95;

    /**
     * 追分策略界面
     * @typedef {object} ChsStg
     */
    class ChsStg extends AutoHide {
      // ic_ = null;  // 内部容器
      // txt_ = null;  // 各个文本标签

      constructor() {
        super();

        const w = ChsStg.W, h = ChsStg.H;

        //this.width = w;
        //this.height = h;

        let bg = this.ic_ = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w, h);
        bg.endFill();
        bg.interactive = true;

        // 标题
        let t = new PIXI.Text(tz.ls('ChaseStrategy'), {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = w * .5;
        t.y = 35;

        // 画板
        let cvs = document.createElement('canvas');
        cvs.width = w;
        cvs.height = h;
        let ctx = cvs.getContext('2d');
        ctx.lineWidth = 2;
        ctx.strokeStyle = '#ffffff';
        ctx.rect(40, 70, w - 80, 400);

        // 横线，有一些占几行的格子，所以起点不同
        Uint16Array.of(40, 40, 40, 40, 160, 40, 40, 160, 160)
        .forEach((x, i)=>{
          let y = 110 + 40 * i;
          ctx.moveTo(x, y);
          ctx.lineTo(w - 40, y);
        });

        // 竖线，每列的宽度不同，这个数组是格子右边的坐标
        Uint16Array.of(160, 280, 360, 440, 520)
        .forEach(x=>{
          ctx.moveTo(x, 70);
          ctx.lineTo(x, 110);

          ctx.moveTo(x, 150);
          ctx.lineTo(x, 190);

          ctx.moveTo(x, 230);
          ctx.lineTo(x, 310);

          ctx.moveTo(x, 350);
          ctx.lineTo(x, 470);
        });
        ctx.stroke();

        let sp = new PIXI.Sprite(PIXI.Texture.from(cvs));
        bg.addChild(sp);
        sp.tint = 0x808080;

        // 每列的颜色
        const cls = ['#ffd700', '#ffd700', '#dcdcdc', '#ff6a6a', '#00bfff', '#00cd66'];

        // 每列的中心x坐标
        const xps2 = Uint16Array.of(100, 220, 320, 400, 480, 560);

        // 标题
        ['Chaser', 'Chasee', 'Diff', 'S-D', 'D-S', 'O-S']
        .forEach((e, i)=>{
          t = new PIXI.Text(tz.ls(e), {
            fontFamily: FF,
            fontSize: 20,
            fontWeight: 'bold',
            fill: cls[i],
            padding: 10
          });
          bg.addChild(t);
          t.anchor.set(.5);
          t.x = xps2[i];
          t.y = 90;
        });

        const yps1 = Uint16Array.of(170, 270, 410);
        const yps2 = Uint16Array.of(170, 250, 370);

        // 0为追者昵称，1的数组为每一组被追者的昵称、分差、自摸、对点、旁点
        let txt = [[null, new Array(1)], [null, new Array(2)], [null, new Array(3)]];
        for (let i = 0; i < 3; ++i) {
          // 追者的昵称
          t = new PIXI.Text('', {
            fontFamily: FF,
            fontSize: 20,
            fontWeight: 'bold',
            fill: cls[0],
            padding: 10
          });
          bg.addChild(t);
          t.anchor.set(.5);
          t.x = xps2[0];
          t.y = yps1[i];
          txt[i][0] = t;

          // 被追者的昵称、分差、自摸、对点、旁点
          for (let k = 0; k <= i; ++k) {
            txt[i][1][k] = new Array(5);
            for (let l = 0; l < 5; ++l) {
              t = new PIXI.Text('', {
                fontFamily: FF,
                fontSize: 20,
                fontWeight: 'bold',
                fill: cls[l + 1],
                padding: 10
              });
              bg.addChild(t);
              t.anchor.set(.5);
              t.x = xps2[l + 1];
              t.y = yps2[i] + 40 * k;
              txt[i][1][k][l] = t;
            }
          }
        }
        this.txt_ = txt;

        // 算法提示文本
        t = new PIXI.Text(tz.ls('ChaseHint'), {
          fontFamily: FF,
          fontSize: 24,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          lineHeight: 40,
          padding: 10
        });
        bg.addChild(t);
        t.anchor.x = .5;
        t.x = w * .5;
        t.y = 485;

        const w1 = 120, h1 = 50;
        let b = new TxtBtn('OK', {
          fontFamily: FF,
          fontSize: 36,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>this.visible = false);
        bg.addChild(b);
        b.x = (w - w1) * .5;
        b.y = h - h1 - 20;
      }

      /**
       * 显示
       * @param {array} p 玩家[{n:xxx,s:0}*4]
       */
      show(p) {
        p.sort(function(a, b) { return b['s'] - a['s']; });

        let t;
        let txt = this.txt_;
        for (let i = 0; i < 3; ++i) {
          // 追者昵称
          t = txt[i][0];
          t.text = p[i + 1]['n'];
          scl_txt(t, 110);

          for (let k = 0; k <= i; ++k) {
            let dt = p[i - k]['s'] - p[i + 1]['s'];
            let sd = 8, dd = 8, od = 8;
            if (dt > 32) {
              let oo = dt - 32;
              sd = Math.max((oo >> 2) + 1, 8);
              dd = Math.max((oo >> 1) + 1, 8);
              od = Math.max(oo + 1, 8);
            }

            // 被追者的昵称、分差、自摸、对点、旁点
            [p[i - k]['n'], dt, sd, dd, od].forEach(function(t, e, l){
              let m = t[l];
              m.text = e;
              if (l == 0) scl_txt(m, 110);
            }.bind(this, txt[i][1][k]));
          }
        }

        this.visible = true;
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        super.layt();
        const w0 = ChsStg.W, h0 = ChsStg.H, s0 = ChsStg.S;
        let c = this.ic_, s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale ChsStg =', s);
      }
    }
    // 左右各30边距，昵称两列宽120，4列内容宽80：40*2+120*2+80*4 = 640
    // 二位1列+三位2列+四位3列+空2列+表头2列=10列，列高40，说明文本+OK按钮210：70+40*10+210=680
    ChsStg.W = 640;
    ChsStg.H = 680;
    ChsStg.S = .8;

    /**
     * 鸣牌设置界面
     * @typedef {object} CalOpt
     */
    class CalOpt extends AutoHide {
      // ic_ = null;  // 内部容器
      // cbs_ = null;  // 万、饼、条、字四组复选框
      // cba_ = null;  // 四个全部复选杠
      // ign_ = null;  // 自摸不问
      // rw_ = null;  // 右键弃

      constructor() {
        super();

        const w = CalOpt.W, h = CalOpt.H;

        let bg = this.ic_ = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w, h);
        bg.endFill();
        bg.interactive = true;

        let t = new PIXI.Text(tz.ls('CallOptions'), {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = w * .5;
        t.y = 35;

        t = new PIXI.Text(tz.ls('NoPrompt'), {
          fontFamily: FF,
          fontSize: 28,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.x = 20;
        t.y = 70;

        let cbs = [[], [], [], []];
        let row1 = (n, s)=>{
          let y = 120 + n * (H0F + 30);
          for (let i = 0; i < s; ++i) {
            let x = 20 + i * (W0 + 50);

            let c = new ChkBox(undefined, function(n, c) {
              // 当不选择时，下方的所有xx要对应取消
              if (!(c.astl_.visible = c.sel)) {
                this.cba_[n].sel = false;
              }
            }.bind(this, n));
            bg.addChild(c);
            c.x = x;
            c.y = y;
            cbs[n].push(c);

            // 显示为立牌的形式
            let t0 = new StTl((n * 9 + i) << 2);
            bg.addChild(t0);
            t0.x = x + 50;
            t0.y = y;

            // 灰色前景，当不鸣该牌时显示
            let t1 = new PIXI.Sprite(new PIXI.Texture(PlTl.tx0.baseTexture, new PIXI.Rectangle(
              (W0 + 2) * 7 + 2, (H0F + 2) * 3 + 2,
              W0, H0F)));
            bg.addChild(t1);
            t1.alpha = .5;
            t1.x = x + 50;
            t1.y = y;
            t1.visible = false;
            c.astl_ = t1;

            // 使牌张也能点击
            t0.interactive = true;
            t0.on('click', function(n, c) {
              if (!(c.sel = c.astl_.visible = !c.sel)) {
                this.cba_[n].sel = false;
              }
            }.bind(this, n, c));
            t0.on('tap', function(n, c) {
              if (!(c.sel = c.astl_.visible = !c.sel)) {
                this.cba_[n].sel = false;
              }
            }.bind(this, n, c));
          }
        };
        row1(0, 9);
        row1(1, 9);
        row1(2, 9);
        row1(3, 7);
        this.cbs_ = cbs;

        let cba = [];
        ['AllCharacters', 'AllBamboos', 'AllDots', 'AllHonors']
        .forEach((e, i)=>{
          let c = new ChkBox(tz.ls(e), function(i, a) {
            let s = a.sel;
            this.cbs_[i].forEach(c=>c.sel = c.astl_.visible = s);
          }.bind(this, i));
          bg.addChild(c);
          c.x = w * .5 + 240 * (i & 1);
          c.y = h - 310 + 70 * (i >> 1);
          cba.push(c);
        });
        this.cba_ = cba;

        let c;
        c = this.ig_ = new ChkBox(tz.ls('NoPromptEvenSD'));
        bg.addChild(c);
        c.x = 20;
        c.y = h - 310;

        c = this.rw_ = new ChkBox(tz.ls('RClickWaive'));
        bg.addChild(c);
        c.x = 20;
        c.y = h - 230;

        t = new PIXI.Text(tz.ls('CalOptNote'), {
          fontFamily: FF,
          fontSize: 24,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.x = .5;
        t.x = w * .5;
        t.y = h - 160;

        const w1 = 150, h1 = 60;
        let b = new TxtBtn(tz.ls('Cancel'), {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>this.visible = false);
        bg.addChild(b);
        b.x = w * .25 - w1;
        b.y = h - h1 - 20;

        b = new TxtBtn(tz.ls('Confirm'), {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>{
          let o = this.opt_;
          let np = o['np'] = [];
          this.cbs_.forEach(t=>t.forEach(e=>np.push(e.sel)));

          o['ig'] = this.ig_.sel;
          o['rw'] = this.rw_.sel;

          this.visible = false;
        });
        bg.addChild(b);
        b.x = w * .75;
        b.y = h - h1 - 20;

        this.opt_ = {
          rw:false,
          ig:false,
          np:new Array(34).fill(false)
        };
      }

      /**
       * 初始化
       */
      init() {
        let o = this.opt_;
        o['rw'] = false;
        o['ig'] = false;
        o['np'].fill(false);

        this.cbs_.forEach(t=>t.forEach(e=>e.sel = false));
        this.cba_.forEach(e=>e.sel = false);
        this.ig_.sel = false;
        this.rw_.sel = false;
      }

      /**
       * 显示
       */
      show() {
        let o = this.opt_, n = o['np'], s = this.cbs_;

        let f = (n, i, e)=>{
          let c = s[n][i];
          c.sel = c.astl_.visible = e;
        };
        n.slice(0, 9).forEach((e, i)=>f(0, i, e));
        n.slice(9, 18).forEach((e, i)=>f(1, i, e));
        n.slice(18, 27).forEach((e, i)=>f(2, i, e));
        n.slice(27, 34).forEach((e, i)=>f(3, i, e));

        this.cba_.forEach(e=>e.sel = this.cbs_.every(e=>e.sel));
        this.ig_.sel = o['ig'];
        this.rw_.sel = o['rw'];

        this.visible = true;
      }

      /**
       * 获取设置
       * @return {JSON}
       */
      opt() {
        return this.opt_;
      }

      /**
       * @return {boolean} 右键=弃
       */
      rw() {
        return this.opt_['rw'];
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        super.layt();
        const w0 = CalOpt.W, h0 = CalOpt.H, s0 = CalOpt.S;
        let c = this.ic_, s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale CalOpt =', s);
      }
    }
    CalOpt.W = (W0 + 50) * 9 + 50;
    CalOpt.H = 860;
    CalOpt.S = .95;

    // =====================================================================================================

    /**
     * 游戏界面
     * @typedef {object} Game
     */
    class Game extends PIXI.Container {
      constructor() {
        super();

        (function(){
/*
          // 透明全屏的按钮，用来监听其他外部的点击事件
          let bg = this.bg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
          bg.alpha = 0;
          this.addChild(bg);

          bg.interactive = true;
          bg.on('click', this._tapbg.bind(this));
          bg.on('tap', this._tapbg.bind(this));
*/

          // 牌桌背景
          let b = this.tbbg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
          b.tint = 0x89a4c7;
          b.alpha = .5;
          this.addChild(b);

          // 只有把监听放在同一棵子树上，才会上向传递
          // 这里竟然不用额外判断就神奇地达到了牌桌等大的监听范围！！！
          this.interactive = true;
          if (!tz.phn) {
            this.on('rightclick', ()=>this.rclk());
          } else {
            this.on('tap', (e)=>this.tapbg(e));
            this.on('click', (e)=>this.tapbg(e));
          }

          // NOTE：本来是想创建一个与牌桌大小相等的按钮，置于最顶层，用来监听鼠标右键
          // 但由于它优先级高，会把桌面上的牌、按钮的点击事件都拦截了
          // 所以这里把鼠标右键的事件监听放在桌面背景上
/*
          v = this.rcls_ = new PIXI.Sprite(PIXI.Texture.WHITE);
          v.alpha = 0;
          this.addChild(v);

          v.interactive = true;
          v.on('rightclick', (s)=>this.rclk(s));
*/
        }.bind(this))();

        // 标题
        let ti = this.ti_ = new PIXI.Text('', {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        this.addChild(ti);
        ti.anchor.y = .5;
        ti.y = 20;
        ti.dh_ = 40;  // 设计高度

        // 所有桌内除自己手牌之外的元素的根结点
        let ic = this.ic_ = new PIXI.Container();
        this.addChild(ic);

        /*
          相对位置与zorder
               h2
               p2
          h3 p3  p1 h1
               p0
               h0

          自身内部：p3>h3, h0>p0, p1>h1, p2>h2
          相互之间：p0>p1, p3>p2
          综合：p3>(h3)>p2>h2, h0>p0>p1>h1
          由于所有的p在一个结点上：h0>(p3>p2>p0>p1)>h3>h2>h1
        */
        // 四家手牌
        let ht = this.ht_ = [new HdCtn0(p=>{
          //this.dscd(0, p.i_);  // 测试，直接打
          let i = p.i_;
          //console.log('discard', i);
          if (i !== 0xff && this.ht_[0].candscd()) {
            tz.ws.send(`{"m":2,"r":2,"v":${i}}`);
            this.cd_.rm();
          }
        }), new HdCtn1(), new HdCtn2(), new HdCtn3()];
        this.addChild(ht[0]);
        ic.addChild(ht[1]);
        ic.addChild(ht[2]);
        ic.addChild(ht[3]);

        // 牌池与中间面板
        let ro = this.ro_ = new PIXI.Container();
        ic.addChild(ro);
        (function(){
          let ro = this.ro_;

          // 牌池尺寸
          Game.WP = W1 * 8 + CtrPnl.W;
          Game.HP = H0 * 6 + H0F * 2 + CtrPnl.H;

          // 测试背景
/*
          let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
          bg.tint = 0x89a4c7;
          bg.alpha = .5;
          bg.width = Game.WP;
          bg.height = Game.HP;
          ro.addChild(bg);
*/
          // 中间面板
          let c = this.cr_ = new CtrPnl();
          ro.addChild(c);
          c.x = W1 * 4;
          c.y = H0 * 3 + H0F;

          let t = new PIXI.Text(tz.ls('NoGambling'), {
            fontFamily: FF,
            fontSize: 26,
            fill: '#ffffff',
            padding: 10
          });
          ro.addChild(t);
          t.anchor.set(.5);
          t.x = Game.WP * .5;
          t.y = Game.HP - 45;

          // 四家昵称等信息
          let ub = this.ub_ = new Array(4);
          [
            {p:{x:(W1 * 4 - 10), y:(c.y + CtrPnl.H + H0 * 4)}, r:0},
            {p:{x:(W1 * 8 + CtrPnl.W), y:(c.y + CtrPnl.H + OL + 10)}, r:(-Math.PI * .5)},
            {p:{x:(c.x + CtrPnl.W + 10), y:0}, r:Math.PI},
            {p:{x:0, y:(c.y - OL - 10)}, r:(Math.PI * .5)}
          ].forEach((e, i)=>{
            let u = ub[i] = new UsrBrf();
            ro.addChild(u);
            u.pivot.set(UsrBrf.W, UsrBrf.H);
            u.position = e['p'];
            u.rotation = e['r'];
          });

          // 四家牌池
          let pl = this.pl_ = [new Pool0(), new Pool1(), new Pool2(), new Pool3()];
          [
            {x:(W1 * 4), y:(H0 * 3 + H0F + CtrPnl.H)},
            {x:(W1 * 4 + CtrPnl.W), y:(H0 * 3 + H0F + CtrPnl.H - H1 * 12)},
            {x:(W1 * 4 + CtrPnl.W - W0 * 12), y:0},
            {x:0, y:(H0 * 4)}
          ].forEach((e, i)=>{
            pl[i].position = e;
          });
          ro.addChild(pl[1]);
          ro.addChild(pl[2]);
          ro.addChild(pl[3]);
          ro.addChild(pl[0]);

/*
          // 测试设置
          for (let i = 0; i < 4; ++i) {
            let u = ub[i];
            u.name = '姓名';
            u.flower = 8;
            u.conn = false;
            u.flswn = true;
          }
          c.order(2);
          c.setup(1, [0, 50, -50, 0]);
          c.remain = 91;
          c.turn = 2;
*/
        }.bind(this))();

        // 四家牌墙
        ic.addChildAt((this.wa_ = new WaCtn()), 0);
        //this.wa_.dice(0, [1, 1, 1, 1]);

        // 鸣牌字样的位置
        this.calpos_ = [{x:0,y:0,ax:.5,ay:1},{x:0,y:0,ax:1,ay:.5},{x:0,y:0,ax:.5,ay:0},{x:0,y:0,ax:0,ay:.5}];
        //this.calpos_ = [new PIXI.Sprite(PIXI.Texture.WHITE),new PIXI.Sprite(PIXI.Texture.WHITE),new PIXI.Sprite(PIXI.Texture.WHITE),new PIXI.Sprite(PIXI.Texture.WHITE)];
        //this.calpos_.forEach(e=>{ic.addChild(e); e.width = 200; e.height = 200;});
        //[{x:0,y:0,ax:.5,ay:1},{x:0,y:0,ax:1,ay:.5},{x:0,y:0,ax:.5,ay:0},{x:0,y:0,ax:0,ay:.5}].forEach((e,i)=>{this.calpos_[i].anchor.set(e.ax, e.ay); });
        this.catx_ = new Array(4);

        // 同样的位置放准备按钮
        this.rdyf_ = new Array(4);
        this.calpos_.forEach((e, i)=>{
          let s = this.rdyf_[i] = new PIXI.Sprite(T64.R);
          this.ic_.addChild(s);
          s.anchor.set(e['ax'], e['ay']);
          s.visible = false;
        });

        let v;
        // 手机/PC不同面板，不同的缩放比
        if (!tz.phn) {
          XchgRd.S = .65;
          Settle.S = .75;
          FalseWin.S = .75;
          Result.S = .75;
          HstTbl.S = .75;
          ChsStg.S = .65;
          CalOpt.S = .75;
          Setting2.S = .65;

          v = this.hlp_ = new HlpCtn(this);
          ic.addChild(v);

          v = this.opt1_ = new OptGrp();
          this.addChild(v);

          v = this.ca1_ = new CalCtn();
          ic.addChild(v);
          v.visible = false;

          v = this.ca2_ = new CalSel();
          ic.addChild(v);
          v.visible = false;

          v = this.cd_ = new CD();
          ic.addChild(v);
          v.visible = false;
        }
        else {
          XchgRd.S = .75;
          Settle.S = .95;
          FalseWin.S = .95;
          Result.S = .95;
          HstTbl.S = .95;
          ChsStg.S = .8;
          CalOpt.S = .95;
          Setting2.S = .95;

          // 使选项菜单上鸣牌选项上面
          v = this.hlp_ = new HlpPop(this);
          this.addChild(v);

          v = this.opt1_ = new OptPop((o, s)=>{
            if (s && this.ca1_.ac()) {
              this.ca1_.tgl(false);
            }
          });
          this.addChild(v);

          v = this.ca1_ = new CalPop();
          this.addChild(v);
          v.visible = false;

          v = this.ca2_ = new CalSel();
          this.addChild(v);
          v.visible = false;

          v = this.cd_ = new CD();
          this.addChild(v);
          v.visible = false;

          // 手机钢琴键
          v = this.p3_ = new Piano3(HdCtn0.W, ht[0].s_);
          this.addChild(v);
          v.visible = false;

          v = this.p2_ = new Piano2(HdCtn0.W, ht[0].s_);
          this.addChild(v);
          v.visible = false;
        }

        // 所有二级弹出界面的容器结点
        let sc = this.sc_ = new PIXI.Container();
        this.addChild(sc);

        (function(){
          // 超时标记
          let t = this.tmot_ = new PIXI.Text(tz.ls('TimeoutHint'), {
            fontFamily: FF,
            fontSize: 32,
            fill: '#dedede',
            stroke: '#000000',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
          });
          t.anchor.set(.5);
          sc.addChild(t);
          t.visible = false;

          // 为配合上层容器，实现一个这样的接口
          t.layt = (x, y, w, h)=>{
            t.x = x + w * .5;
            t.y = y + h * .75;
            scl_txt(t, w - 20);
          };
        }.bind(this))();

/*
        // 最顶层的结点，用来监听弹出界面的外部，从而实现点击外面关闭
        let fg = this.fg_ = new PIXI.Sprite(PIXI.Texture.WHITE);
        fg.alpha = .5;
        this.addChild(fg);
        fg.visible = false;
        fg.interactive = true;
        fg.on('rightclick', ()=>this.rclk());
*/

        v = this.opt2_ = new CalOpt();
        sc.addChild(v);
        v.visible = false;

        v = this.chs_ = new ChsStg();
        sc.addChild(v);
        v.visible = false;

        v = this.hst_ = new HstTbl();
        sc.addChild(v);
        v.visible = false;

/*
        {
          setTimeout(() => {
            this.reconn({"m":4,"v":0,"s":1598809929116,"g":{"t":"fds","n":4,"d":false,"i":500,"l":8,"b":8,"r12":10,"r30":15,"dt":0,"d12":false,"fa":false,"fc":true,"s":true,"o":false,"a":true,"r":false},"u":[{"n":"码龙","s":500,"l":0,"g":0,"o":true,"f":2,"w":false,"v":1,"rs":[],"rp":[]},{"n":"192.168.1.*","s":500,"l":0,"g":0,"o":false,"f":2,"w":false,"v":0,"rs":[],"rp":[]},{"n":"192.168.1.*","s":500,"l":0,"g":0,"o":true,"f":0,"w":false,"v":0,"rs":[],"rp":[]},{"n":"192.168.1.*","s":500,"l":0,"g":0,"o":true,"f":0,"w":false,"v":0,"rs":[],"rp":[]}],"i":{"e":true,"d":0,"s":128,"t":0,"w":{"f":105,"b":4,"d":22101},"p":[[109,76,78,134,90,28,128,133,62,75,29,135,126],[114,120,132,129,71,112,117,119,46,63,17,96,30,54],[44,22,47,64,116,102,73,131,3,34,33,142,118],[20,16,66,92,21,130,140,13,99,5,79,6]],"h":[{"p":[3456,3530],"s":[14,37,48,50,67,122,123,23]},{"p":[2458,26837],"s":[-1,-1,-1,-1,-1,-1,-1]},{"p":[],"s":[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]},{"p":[],"s":[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]}]},"b":[]});
          }, 1000);

          {
            //let p = wall0();
            //let p = wall1();
            let p = new StTl(1, s=>console.log(s));
            //let p = st_tl1();
            //let p = st_tl2();
            //let p = st_tl3();
            //let p = new PlTl0(1);
            //let p = new PlTl1(1);
            //let p = new PlTl2(1);
            //let p = new PlTl3(1);
            //p.x = p.y = 100;
            //p.anchor.set(.5);
            //p.layt();
            p.updt(80);
            this.addChild(p);

            let b = new PIXI.filters.BlurFilter();
            b.blur = 1;
            p.filters = [b];
            p.filters = [];
          }

          for (let i = 0; i < 4; ++i) {
            ht[i].setup([69,70,75,76,81,97,104,105,106,107,100],[0x21B]);
            //ht[i].setup([69,70,75,76,81,97,104,105,106,107,100],[mk_pk(0,30,1),mk_pk(0,30,2),mk_pk(0,30,3)]);
            //ht[i].setup([69,70,75,76,81,97,104,105,106,107,100],[mk_pk(1,38,1),mk_pk(1,42,2),mk_pk(1,46,3)]);
            //ht[i].setup([69,70,75,76,81,97,104,105,106,107,100],[mk_pk(2,50,1),mk_pk(2,54,2),mk_pk(2,58,3),mk_pk(2,62,0)]);
            //ht[i].setup([69,70,75,76,81,97,104,105,106,107,100],[mk_pk(2,80,1),mk_pk(2,84,2),mk_pk(2,88,3),mk_pk(2,92,3)]);
            //ht[i].setup([69,70,75,76,81,97,104,105,106,107,100],[mk_pk(3,70,1),mk_pk(3,74,2),mk_pk(3,78,3)]);
          }

          // 测试按钮
          let b = new EptBtn(50, 50, ()=>{
            // 牌墙测试
            //let t = this.wa_.back();
            //console.log('wall', t.position, this.wa_.rem_);
            //this.cr_.remain = this.wa_.rem_;

            this.caltxt(0, '花');
            return;

            //this.onwin({d:{f:11,n:[0,0,0,0],p:0,r:0,s:[57,-19,-19,-19],t:[57,-19,-19,-19],w:1},f:2,i:100,m:2,p:{56:4,66:2,70:1,75:1,76:1,81:257},r:12,t:[{s:[12,13,26,28,35,82,83,92,93,94,99,102,104]},{s:[5,21,38,56,58,66,67,79,80,96,119,129,132],{s:[11,22,27,34,45,53,88,90,109,117,121,135,141]},{s:[14,33,42,44,47,60,62,68,87,98,103,114,125]}],v:0,w:81});
            this.cfg_ = {'r30':99};
            this.pls_ = [
              {"n":"aaa","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},
              {"n":"bbb","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},
              {"n":"ccc","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]},
              {"n":"ddd","l":0,"s":0,"g":0,"o":0,"v":0,"rs":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"rp":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}
            ];
            //this.onwin({"d":{"f":11,"n":[0,0,0,0],"p":0,"r":0,"s":[57,-19,-19,-19],"t":[57,-19,-19,-19],"w":1},"f":2,"i":100,"m":2,"p":{"56":4,"66":2,"70":1,"75":1,"76":1,"81":257},"r":12,"t":[{"s":[12,13,26,28,35,82,83,92,93,94,99,102,104]},{"s":[5,21,38,56,58,66,67,79,80,96,119,129,132]},{"s":[11,22,27,34,45,53,88,90,109,117,121,135,141]},{"s":[14,33,42,44,47,60,62,68,87,98,103,114,125]}],"v":0,"w":81});
            //this.onp({v:1,p:2378});
            this.onwin({"i":111,"m":2,"r":12,"v":769,"w":62,"f":1,"d":{"r":1,"w":1,"f":21,"p":769,"t":[-8,-29,-8,45],"s":[-8,-29,-8,45],"n":[0,0,0,0]},"t":[{"s":[4,5,24,52,73,81,84,91,102,120,123,133,138]},{"s":[7,14,18,23,48,51,57,58,75,85,87,98,117]},{"s":[22,25,29,34,47,49,74,78,97,100,116,125,141]},{"p":[6221],"s":[0,3,11,13,16,37,43,46,64,70]}],"p":{"28":16,"63":2,"75":1,"77":1,"81":1}});
            //this.ontie({"m":2,"r":13,"d":{"r":0,"w":0,"t":[0,0,0,0],"n":[0,0,0,0]},"t":[{"s":[3,10,17,18,25,27,30,45,54,74,76,79,87]},{"s":[19,33,53,56,63,88,102,105,114,117,123,124,140]},{"s":[8,11,22,43,55,75,86,90,93,94,95,108,138]},{"s":[1,12,24,41,47,72,106,110,120,122,125,132,135]}]});
            return;
            // 发牌测试
            this.onxchg(1, [{'n':'东','s':0},{'n':'南','s':0},{'n':'西','s':0},{'n':'北','s':0}]);

            this.init();
            this.send(0, 3, [
              Math.trunc(Math.random() * 6) + 1,
              Math.trunc(Math.random() * 6) + 1,
              Math.trunc(Math.random() * 6) + 1,
              Math.trunc(Math.random() * 6) + 1],
            [1,4,7,109,108,112,58,34,96,25,20,19,35]);
          });
          this.addChild(b);

          b = new EptBtn(50, 50, ()=>{
            // 鸣牌测试
            let h = this.ht_[0];
            h.open([69,70,75,76,81,97,104,105,106,107,100],[0x21B],100);
            //h.win(0x7e, {x:0, y:0});
            //h.c(0x45, {x:0, y:0});  // 吃
            //h.p(0x17e, {x:0, y:0});  // 碰上家
            //h.p(0x1be, {x:0, y:0});  // 碰对家
            //h.p(0x1fe, {x:0, y:0});  // 碰下家
            //setTimeout(()=>h.pk(0x1ef, false), 3000);
            //h.dk(0x27e, {x:0, y:0});  // 杠上家
            //h.dk(0x2be, {x:0, y:0});  // 杠对家
            //h.dk(0x2fe, {x:0, y:0});  // 杠下家
            //h.ck(false);  // 暗杠

            //this.flw123(2);// 碰2378
            // this.dscd(3, 96, false);
            // this.draw(1, false);
          });
          this.addChild(b);
          b.y = 100;

          //this.addChild(new Setting2(500, 500));
          //this.addChild(new Setting(500, 500));


          // 测试一手和牌
          //let w = new WinHand({"p":[0x21B],"s":[69,70,75,76,81,97,104,105,106,107]},100,5);
          //this.addChild(w);

          // // 测试结算界面
          // // 15个番的测试用例
          // let h = {"p":[0x21B],"s":[69,70,75,76,81,97,104,105,106,107]};
          // let f = {"44":8,"46":8,"55":4,"56":4,"58":4,"60":2,"61":2,"64":2,"66":2,"67":2,"72":1,"73":1,"75":1,"78":1,"81":0x101};
          // let d = {"r":0,"f":44,"p":0x0000,"t":[156,-52,-52,-52],"s":[156,-52,-52,-52],"n":[0,0,0,0]};
          // let n = ['玩家1','玩家2','玩家3','玩家4'];
          // let v = 1;
          // let s = new Settle(h, 100, f, d, n, v, 10, (s)=>{ this.sc_.removeChild(s); s.dsty(); });
          // //view.scale.set(1.25);
          // this.sc_.addChild(s);

          // 测试错和界面
          //let f = new FalseWin(1, {"44":8,"46":8,/*"55":4,"56":4,"58":4,"60":2,"61":2,"64":2,"66":2,"67":2,"72":1,"73":1,"75":1,"78":1,"81":0x101});
          //this.sc_.addChild(f);

          // 测试鸣牌选择界面
          //this.ca2_.setup(5, [0x0001, 0x0102], (a)=>{
          //this.ca2_.setup(3, [0x21b, 0x21f], (a)=>{
          //  console.log('calsel returns', a);
          //});

          // 测试倒计时
          //this.cd_.setup(99);
        }
*/
      }

      /**
       * 适配
       * @param {number} w 宽度
       * @param {number} h 高度
       */
      layt(w, h) {
        console.log('width, height', w, h);
/*
        this.bg_.width = w;
        this.bg_.height = h;
*/

        let w0 = HdCtn3.W + Pool3.W + CtrPnl.W + Pool1.W + HdCtn1.W,
          h0 = HdCtn2.H + Pool2.H + CtrPnl.H + Pool0.H,
          w1 = 0, h1 = 0;
        let wa = this.wa_;

        wa.visible = tz.wall;
        if (tz.wall) {
          // 一方牌墙的宽度+打牌需要的偏移
          w1 = Wall3.W + 10;
          h1 = Wall0.H + 10;
        }

        // 总宽高
        w0 += w1 * 2;
        h0 += h1 * 2;

        let ti = this.ti_, ht = this.ht_, ic = this.ic_, op = this.opt1_, hl = this.hlp_, ca1 = this.ca1_, ca2 = this.ca2_, cd = this.cd_, cp = this.calpos_;
        let ht0 = ht[0];

        let ht1_yf = 0;  // 手机横屏时下家调整

        // PC、平板适配
        if (!tz.phn) {
          // 标题放最上方
          // 按桌面与手牌的最大宽度适配
          // 布局结构为：
          // ┌─┬─────┐
          // │ ├───┬─┤
          // └─┘   │ │
          //       └─┘
          w0 = Math.max(w0, HdCtn3.W + HdCtn2.W);
          h0 = Math.max(h0, HdCtn2.H + HdCtn1.H) + ti.dh_;

          let hh = (w0 / (HdCtn0.W)) * HdCtn0.H;  // 立牌铺满宽度时，整个的高度
          let sx = w / w0, sy = h / (h0 + hh + OptGrp.H);
          if (sx <= sy) {
            //console.log('case sx <= sy');

            let cy = ti.dh_ * sx;

            // 桌面
            ic.x = 0;
            ic.y = cy;
            ic.scale.set(sx);

            // 鸣牌字样位置
            cp[0].x = w0 * .5;
            cp[0].y = h0 - 40;
            cp[1].x = w0 - 40;
            cp[1].y = h0 * .5;
            cp[2].x = w0 * .5;
            cp[2].y = 40;
            cp[3].x = 40;
            cp[3].y = h0 * .5;

            // 桌面式操作按钮
            hl.layt(w0, h0);

            // 标题
            ti.x = 0;
            ti.y = cy * .5;
            ti.scale.set(sx);

            let h2 = h0 * sx, h3 = hh * sx;

            // 覆盖桌面宽度
            this.lyt_ = {x:0, y:cy, w:w, h:(h2 + h3 - cy)};

            // 手牌
            ht0.x = 0;
            ht0.y = h2;
            ht0.layt(sx, w, h3);

            // 鸣牌按钮
            ca1.layt(w0, h0);
            ca2.layt(w0, h0);

            // 倒计时
            cd.x = w0 - 100;
            cd.y = h0 - 145;

            // 下方菜单
            op.x = 0;
            op.y = h2 + h3 + 5;
            op.scale.set(w / OptGrp.W);
          }
          else {
            //console.log('case sx > sy');
            let w2 = w0 * sy;  // 桌面宽度
            let cx = (w - w2) / 2;  // 使桌面居中的x位置
            let cy = ti.dh_ * sy;  // 桌面开始的y位置
            let h2 = h0 * sy, h3 = hh * sy;  // 桌度高度，手牌范围高度

            // 都与桌面共用x位置
            ht0.x = op.x = ic.x = ti.x = cx;
            ic.y = cy;
            ic.scale.set(sy);

            // 鸣牌字样位置
            cp[0].x = w0 * .5;
            cp[0].y = h0 - 40;
            cp[1].x = w0 - 40;
            cp[1].y = h0 * .5;
            cp[2].x = w0 * .5;
            cp[2].y = 40;
            cp[3].x = 40;
            cp[3].y = h0 * .5;

            // 桌面式操作按钮
            hl.layt(w0, h0);

            // 覆盖桌面宽度
            this.lyt_ = {x:cx, y:cy, w:w2, h:(h2 + h3 - cy)};

            // 标题
            ti.y = cy * .5;
            ti.scale.set(sy);

            // 手牌
            ht0.y = h2;
            ht0.layt(sy, w2, h3);

            // 鸣牌按钮
            ca1.layt(w0, h0);
            ca2.layt(w0, h0);

            // 倒计时
            cd.x = w0 - 100;
            cd.y = h0 - 145;

            // 下方菜单
            op.y = h2 + h3 + 5;
            op.scale.set(w2 / OptGrp.W);
          }
        }
        // 手机适配
        else {
          // 竖屏
          if (w < h) {
            // 按桌面与手牌的最大宽度适配
            // 布局结构同PC
            w0 = Math.max(w0, HdCtn3.W + HdCtn2.W);
            h0 = Math.max(h0, HdCtn2.H + HdCtn1.H) + ti.dh_;

            let hh = (w0 / (HdCtn0.W)) * HdCtn0.H;  // 立牌铺满宽度时，整个的高度
            let s = Math.min(w / w0, h / (h0 + hh));

            let w2 = w0 * s;  // 桌面宽度
            let cx = (w - w2) / 2;  // 使桌面居中的x位置
            let cy = ti.dh_ * s;  // 桌面开始的y位置
            let h2 = h0 * s, h3 = hh * s;  // 桌度高度，手牌范围高度

            // 桌面
            ic.x = cx;
            ic.y = cy;
            ic.scale.set(s);

            // 鸣牌字样位置
            cp[0].x = w0 * .5;
            cp[0].y = h0 - 40;
            cp[1].x = w0 - 40;
            cp[1].y = h0 * .5;
            cp[2].x = w0 * .5;
            cp[2].y = 40;
            cp[3].x = 40;
            cp[3].y = h0 * .5;

            // 鸣牌按钮
            ca1.scale.set(s);
            ca1.x = w - CalPop.W * s;
            ca1.y = cy + h2 - (CD.R + CalPop.H) * s;

            ca2.scale.set(s);
            ca2.x = w - CalSel.W * s;
            ca2.y = cy + h2 - (CD.R + CalPop.H + CalSel.H) * s;

            // 倒计时
            cd.scale.set(s);
            cd.x = w - (CD.R + 20) * s;
            cd.y = cy + h2 - CD.R * s;

            // 弹出式菜单
            op.scale.set(s);
            op.x = w - OptPop.W * s;
            op.y = cy + h2 - (CD.R + OptPop.H) * s;

            // 弹出式操作按钮
            hl.scale.set(s);
            hl.x = w - HlpPop.W * s;
            hl.y = cy;

            // 覆盖桌面宽度
            this.lyt_ = {x:cx, y:cy, w:w2, h:(h2 + h3 - cy)};

            // 覆盖桌面宽度+手牌超出部分宽度
            // this.lyt_ = {x:0, y:cy, w:w, h:(h2 + h3 - cy)};

            // 标题
            ti.x = cx;
            ti.y = cy * .5;
            ti.rotation = 0;
            ti.scale.set(s);

            // 手牌
            ht0.x = 0;
            ht0.y = h2;
            ht0.layt(s, w, h3);

            // 钢琴键
            let y = h2 + h3, s1 = w / HdCtn0.W, p3 = this.p3_, p2 = this.p2_;
            let enf3 = (y, h, s)=>(y + Piano3.H * s <= h);
            let enf2 = (y, h, s)=>(y + Piano2.H * s <= h);
            let lyt3 = (p2, p3, y, s)=>{
              p2.visible = false;
              p3.visible = true;
              p3.y = y;
              p3.scale.set(s);
            };
            let lyt2 = (p2, p3, y, s)=>{
              p3.visible = false;
              p2.visible = true;
              p2.y = y;
              p2.scale.set(s);
            };
            switch (tz.piano) {
            default:  // 自动
              if (enf3(y, h, s1)) {  // 三格够放
                lyt3(p2, p3, y, s1);
              }
              else if (enf2(y, h, s1)) {  // 两格够放
                lyt2(p2, p3, y, s1);
              }
              else {
                p2.visible = p3.visible = false;
              }
              break;
            case 1:
              if (enf3(y, h, s1)) {  // 三格够放
                lyt3(p2, p3, y, s1);
              }
              else {
                p2.visible = p3.visible = false;
              }
              break;
            case 2:
              if (enf2(y, h, s1)) {  // 两格够放
                lyt2(p2, p3, y, s1);
              }
              else {
                p2.visible = p3.visible = false;
              }
            }
          }
          // 横屏
          else {
            // 按桌面和手牌的最大宽度适配
            // 布局结构为：
            // ┌─┬─────┬─┐
            // │ ├─────┤ │
            // └─┘     └─┘
            w0 = Math.max(w0, HdCtn3.W + HdCtn2.W + HdCtn1.W);
            h0 = Math.max(h0, HdCtn1.H);

            let hh = (w0 / (HdCtn0.W)) * HdCtn0.H;  // 立牌铺满宽度时，整个的高度
            let s = Math.min(w / w0, h / (h0 + hh));

            let w2 = w0 * s;  // 桌面宽度
            let cx = (w - w2) / 2;  // 使桌面居中的x位置
            let h2 = h0 * s, h3 = hh * s;  // 桌度高度，手牌范围高度

            // 桌面
            ic.x = cx;
            ic.y = 0;
            ic.scale.set(s);

            // 鸣牌字样位置
            cp[0].x = w0 * .5;
            cp[0].y = h0 - 40;
            cp[1].x = w0 - 40;
            cp[1].y = h0 * .5;
            cp[2].x = w0 * .5;
            cp[2].y = 40;
            cp[3].x = 40;
            cp[3].y = h0 * .5;

            // 弹出式操作按钮、鸣牌选择按钮、弹出式菜单三者占满屏幕高度
            // 由于手牌宽容了15，这里再保持一点距离
            let s1 = Math.max(s, (h2 - 25) / (HlpPop.H + CalSel.H + CalPop.H));

            // 鸣牌按钮
            let dx = cx * .25;  // 使之稍微能超出桌面范围一点
            ca1.scale.set(s1);
            ca1.x = cx + w2 - CalPop.W * s1 + dx;
            ca1.y = (h2 - 25) - CalPop.H * s1;

            ca2.scale.set(s1);
            ca2.x = cx + w2 - CalSel.W * s1 + dx;
            ca2.y = (h2 - 25) - (CalPop.H + CalSel.H) * s1;

            // 倒计时
            cd.scale.set(s1);
            // 能够放在超出桌面的范围内
            if (cx + w2 + dx + (10 + CD.R) * s1 <= w) {
              cd.x = cx + w2 + dx + 10 * s1;
              cd.y = h2 - 25 - CD.R * s1;
            }
            else {
              cd.x = cx + w2 - (CD.R + 10) * s1;
              cd.y = h2 - 25;
            }

            // 弹出式菜单
            op.scale.set(s1);
            op.x = cx + w2 - OptPop.W * s1 + dx;
            op.y = (h2 - 25) - OptPop.H * s1;

            // 弹出式操作按钮
            hl.scale.set(s1);
            hl.x = cx + w2 - HlpPop.W * s1 + dx;
            hl.y = 0;

            // 覆盖桌面宽度
            this.lyt_ = {x:cx, y:0, w:w2, h:(h2 + h3)};

            // 标题放在桌面左侧
            ti.rotation = Math.PI * .5;
            ti.x = cx - ti.dh_ * s * .5;
            ti.y = 0;
            ti.scale.set(s);

            // 手牌，再宽容15像素
            ht0.y = h2 - 15;
            ht0.layt(s, w, h3 + 15);

            // 下家手牌校正高度
            ht1_yf = (1 - s) * (h3 + 15 - H0F);

            this.p3_.visible = false;
            this.p2_.visible = false;
          }
        }

        // 桌面背景、右键监听者及所有二级子界面适配
        (function() {
          let l = this.lyt_, b = this.tbbg_;//, r = this.rcls_;
          let x = l['x'], y = l['y'], w = l['w'], h = l['h'];
          b.x = x; b.y = y; b.width = w; b.height = h;
          //r.x = x; r.y = y; r.width = w; r.height = h;
          this.sc_.children.forEach(v=>v.layt(x, y, w, h));
        }.bind(this))();

/*
        // 测试范围
        {
          let l = this.lyt_, fg = this.fg_;
          fg.x = l['x'];
          fg.y = l['y'];
          fg.width = l['w'];
          fg.height = l['h'];
        }
*/

        // 牌墙位置
        wa.layt(w0, h0);

        // 牌池居中
        let ro = this.ro_;
        ro.x = (w0 - Game.WP) * .5;
        ro.y = (h0 + HdCtn2.H - Game.HP) * .5;

        // 手牌位置
        ht[1].x = w0 - HdCtn1.W;
        ht[1].y = Math.max(h0 - HdCtn1.H - ht1_yf, 0);

        ht[2].x = Math.max(w0 - HdCtn1.W - HdCtn2.W, HdCtn3.W);

        // 准备标记
        cp.forEach((e, i)=>this.rdyf_[i].position.set(e['x'], e['y']));

        // 测试鸣牌按钮
        //this.addcal([0x10000]);
        //262277,262177,219228,219232,202780,327756
        //this.addcal([[262194, 207924, 209976]]);//[5144, 6176]
      }

      // 一堆代理函数
      //['测速', '追分策略', '鸣牌设置', '设置', '计分表']
      onspd() {
        tz.ws.send(`{"m":5,"t":${new Date().getTime()}}`);
      }

      onchs() {
        let p = [], s = this.cr_.seat;
        this.pls_.forEach(e=>p.push({'n':e['n'], 's':e['s']}));
        this.ub_.forEach((e, i)=>{
          if (e.flswn) {
            p[(i + s) & 3] -= 40;
          }
        });
        this.chs_.show(p);
      }

      oncal() {
        this.opt2_.show();
      }

      onset() {
        let v = new Setting2();
        this.sc_.addChild(v);

        let l = this.lyt_;
        let x = l['x'], y = l['y'], w = l['w'], h = l['h'];
        v.layt(x, y, w, h);
      }

      onhst() {
        this.hst_.visible = true;
      }
      // 一堆代理函数结束

      /**
       * 清理，当点击结束界面的OK后执行
       * @param {JSON} 配置
       */
      tidy() {
        this.ca1_.visible = false;
        this.ca2_.visible = false;
        this.cd_.visible = false;
        this.opt2_.visible = false;
        this.chs_.visible = false;
        this.hst_.visible = false;
      }

      /**
       * 开始当前局计时
       * @param {number} t 当前时间戳（服务器传过来）
       */
      startup(t) {
        this.hlp_.strt(t);
        this.visible = true;
      }

      /**
       * 开始
       * @param {JSON} 配置
       */
      setup(g) {
        // 测试数据
        //{"t":"sfda","n":4,"d":false,"i":500,"l":8,"b":8,"r12":5,"r30":10,"dt":0,"d12":false,"fa":true,"fc":false,"s":true,"o":true,"a":false,"r":false}
        this.cfg_ = g;
        this.ti_.text = `${g['t']} [${g['n']} | ${g['l']} (${g['b']}) | ${g['r30']}/${g['r12']}s]`;
        this.cr_.cfg(g);
      }

      /**
       * 初始化
       */
      init() {
        this.wa_.init();
        this.cr_.init();
        this.ub_.forEach(e=>e.init());
        this.pl_.forEach(e=>e.init());
        this.ht_.forEach(e=>e.init());
        this.opt1_.init();
        this.opt2_.init();
        this.ca1_.visible = false;
        this.ca2_.visible = false;
        this.cd_.visible = false;
        this.catx_.forEach(e=>{ if (e) { e.dsty(); }});  // BUG
        this.rdyf_.forEach(e=>e.visible = false);

        this.stpflw_ = false;
        let f = this.fly_;
        if (f) {
          f.dsty();
          this.fly_ = null;
        }
      }

      /**
       * 发牌
       * @param {number} o 盘序
       * @param {number} v 自己座位（门风）
       * @param {array} d 骰子
       * @param {array} h 自己的手牌
       */
      send(o, v, d, h) {
        let w = this.wa_, c = this.cr_;
        c.remain = 144;
        c.order(o);
        w.dice(v, d);  // 牌墙设置骰子

        this.xstl();  // 叉掉结算界面

        // 换圈后多一个提示
        if (o & 3) {
          this._send1(d, h);
        }
        else {
          let p = this.pls_, n = [p[0]['n'], p[1]['n'], p[2]['n'], p[3]['n']];
          let b = new XchgRd(o >> 2, n, [p[0]['s'], p[1]['s'], p[2]['s'], p[3]['s']]);
          this.sc_.addChild(b);

          let l = this.lyt_;
          b.layt(l['x'], l['y'], l['w'], l['h']);

          new TWEEN.Tween(b).to({alpha:0}, 200).delay(1300).start();

          setTimeout(()=>{ b.dsty(); this._send1(d, h); }, 1500);

          if (o) {
            tz.play('snd/25-xchg.wav');
          }
          else {
            // 东风东时，设置计分表的人名
            tz.play('snd/01-start.wav');
            this.hst_.setup(n);
          }
        }
      }

      /**
       * 发牌第一步
       * @param {array} d 骰子
       * @param {number} h 自己的手牌
       */
      _send1(d, h) {
        let c = this.cr_;
        let dca = n=>{
          let t = tz.res[`img/dice/${n}.png`].texture;
          let f = [];
          [
            new PIXI.Rectangle(2,2,72,200),new PIXI.Rectangle(76,2,90,200),new PIXI.Rectangle(168,2,70,200),
            new PIXI.Rectangle(240,2,72,200),new PIXI.Rectangle(312,2,70,200),new PIXI.Rectangle(384,2,70,200),
            new PIXI.Rectangle(2,204,72,200),new PIXI.Rectangle(74,204,70,200),new PIXI.Rectangle(146,204,58,200)
          ]
          .forEach(e=>f.push(new PIXI.Texture(t, e)));
          //let a = new PIXI.extras.AnimatedSprite(f);  // v4.x
          let a = new PIXI.AnimatedSprite(f);  // v4.x
          a.x = 100;
          a.y = 100;
          a.animationSpeed = .4;
          a.loop = false;
          a.play();
          return a;
        };

        // 第一次掷骰子
        c.turn = 0;
        for (let i = 0; i < 2; ++i) {
          let s = dca(d[i]);
          this.ro_.addChild(s);
          // 让位置看起来随机一些
          s.x = this.cr_.x + 30 + 120 * i + Math.random() * 50;
          s.y = this.cr_.y - Math.random() * 100;
          setTimeout(s.dsty.bind(s), DCDT * .5);
        }
        tz.play('snd/02-dice.wav');

          // 第一次掷完后的方位
          //   d0+d1 | res | %4 | (+3)%4
          // --------+-----+----+--------
          //  2 6 10 |  1  |  2 |   1
          //  3 7 11 |  2  |  3 |   2
          //  4 8 12 |  3  |  0 |   3
          //  5 9    |  0  |  1 |   0
        setTimeout(()=>c.turn = (d[0] + d[1] + 3) & 3, DCDT * .4);

          // 第二次掷骰子
        setTimeout(()=>{
          for (let i = 0; i < 2; ++i) {
            let s = dca(d[i + 2]);
            this.ro_.addChild(s);
            // 让位置看起来随机一些
            s.x = this.cr_.x + 30 + 120 * i + Math.random() * 50;
            s.y = this.cr_.y - Math.random() * 100;
            setTimeout(s.dsty.bind(s), DCDT * .5);
          }
          tz.play('snd/02-dice.wav');
        }, DCDT * .5);

        //this.wa_.prep();  // 起牌墙效果

        // 发牌第二步
        setTimeout(this._send2.bind(this, h), DCDT);
      }

      /**
       * 发牌第二步
       * @param {number} h 自己的手牌
       */
      _send2(h) {
        /**
         * 抓牌效果
         * @param {object} ctx
         * @param {number} k 谁的手牌（以庄家为0）
         * @param {number} o 手牌偏移
         * @param {object} p 抓到的牌（精灵）
         */
        function draw(ctx, k, o, p) {
          let c = ctx.cr_, h = ctx.ht_[(k + 4 - c.seat) & 3];  // 转换成自己的视角
          let l = p.length;
          for (let i = 0; i < l; ++i) {
            let e = p[i];
            e.visible = false;
            h.draw(o + i, e.toGlobal({x:0,y:0}));
          }
          c.remain -= l;
          c.turn = k;
          tz.play('snd/05-draw.wav');
        }

        let w = this.wa_, ht = this.ht_, v = this.cr_.seat;

        ht[0].prep(h, v === 0);  // 更新手里的牌

        let t = new Array(53);  // 暂存要发走的牌13*4+1=53张
        for (let i = 0; i < 53; ++i) {
          let p = t[i] = w.front();
          p.visible = true;
        }

        // 每人3手，每手4张
        for (let n = 0; n < 3; ++n) {  // 第n手
          for (let k = 0; k < 4; ++k) {  // 第k家
            let m = n * 16 + k * 4;
            setTimeout(draw.bind(this, this, k, n * 4, [t[m], t[m + 1], t[m + 2], t[m + 3]]),
              (n * 4 + k) * DRDT);
          }
        }

        // 跳牌
        // 庄家跳两张
        setTimeout(draw.bind(this, this, 0, 12, [t[48], t[52]]), DRDT * 12);

        // 闲家各一张
        for (let k = 1; k < 4; ++k) {
          setTimeout(draw.bind(this, this, k, 12, [t[48 + k]]), DRDT * (12 + k));
        }

        setTimeout(()=>this.cr_.turn = 0, DRDT * 16);

        // 理牌
        setTimeout(()=>{
          this.ht_.forEach(e=>e.sort());
          tz.play('snd/05-draw.wav');
        }, DRDT * 17);
      }

      /**
       * 出牌
       * @param {number} n 玩家
       * @param {number} t 牌
       * @param {boolean} h 手切true，摸切false
       */
      dscd(n, t, h) {
        tz.play('snd/06-discard.wav');
        this.cd_.rm();
        this.rmcal();

        // 归位旧的飞牌（网络卡顿时会有）
        let f = this.fly_;
        if (f && f.pnd_) {
          f.pnd_();
        }

        // 从牌池中找一个位置
        let d = this.pl_[n].pick();
        if (!d) {
          console.log('dst error when discarding');
          return;
        }

        d.updt(t);

        // 从手牌中打出
        f = this.fly_ = this.ht_[n].dscd(t, h, d);

        // 归位回调
        f.pnd_ = ()=>{
          this.fly_ = null;
          d.acpt_ = true;
          new TWEEN.Tween(f).to({x:d.x, y:d.y}, DRDT).onComplete(()=>{
            d.visible = true;
            f.dsty();
          }).start();
        };

        // 自己打牌后不再阻拦自动补花
        if (n === 0) {
          this.stpflw_ = false;
        }
      }

      /**
       * 摸牌
       * @param {number} n 玩家
       * @param {boolean} b 正向false，逆向true
       * @param {number} t 牌张（对于其他三家而言，该值无意义）
       */
      draw(n, b, t) {
        // 使飞牌归位
        let f = this.fly_;
        if (f && f.pnd_) {
          f.pnd_();
        }

        // 摸牌动画
        if (n === 0) {
          this.ht_[0].draw0(13, t);
        }
        let p = !b ? this.wa_.front() : this.wa_.back();
        this.ht_[n].draw(13, p.toGlobal({x:0,y:0}));
        tz.play('snd/05-draw.wav');
      }

      /**
       * 添加鸣牌按钮
       * @param {array} a 可选择的鸣牌
       */
      addcal(a) {
        let s = this.cr_.self(), o2 = this.opt2_.opt(), f = this.fly_;

        // 别人打牌，设置了不鸣这张，直接过或者弃
        if (!s && f && o2['np'][f.i_ >> 2]) {
          tz.ws.send(o2['rw'] ? '{"m":2,"r":10,"v":0}' : '{"m":2,"r":9,"v":0}');
          this.cd_.rm();
          return;
        }

        // 下方选项
        let o = this.opt1_.opt();
        if (!a || a.length === 0) {  // 无法鸣牌
          if (s && (o & 64)) {  // 自动摸打 (1 << 6) = 64
            setTimeout(()=>{
              this.ht_[0].dd();
            }, DSDT + 1000);
          }
          return;
        }

        // 把相同类型的鸣牌整合在一个按钮的数据中，
        // 如果某个按钮出现一组数据，需要弹出鸣法选择
        let d = {}, n = 0;
        a.forEach(e=>{
          let t = hiword(e), b = loword(e);
          if (typeof d[t] === 'undefined') {
            d[t] = [b];
            ++n;
          } else {
            d[t].push(b);
          }
        });
        if (n === 0) {
          return;
        }

        // 根据选项过滤
        if ((o & 1) && d[1] && !this.stpflw_ ) {  // 自动补花
          setTimeout(()=>{
            tz.ws.send('{"m":2,"r":1,"v":0}');
            this.cd_.rm();
          }, DSDT * 2);
          return;
        }

        if ((o & 2) && d[3]) {  // 不吃
          --n;
          delete d[3];
        }
        if ((o & 4) && d[4]) {  // 不碰
          --n;
          delete d[4];
        }
        if ((o & 8) && d[5]) {  // 不杠
          --n;
          delete d[5];
        }

        // 可和
        if (d[6]) {
          let j = false;
          if ((o & 16) && !s) {  // 只和自摸
            --n;
            delete d[6];
            j = true;
          }

          // 自摸，但属于指定不提示的那张
          if (s && o2['ig'] && o2['np'][this.ht_[0].wt() >> 2]) {
            --n;
            delete d[6];
            j = true;
          }

          if (!j && (o & 32)) {  // 自动和牌
            setTimeout(()=>{
              tz.ws.send(`{"m":2,"r":6,"v":${d[6][0]}}`);
              this.cd_.rm();
            }, DSDT * 2);
            return;
          }
        }

        if ((o & 64)) {  // 自动摸打
          if (!d[6] && !d[5] &&!d[1] && s) {
            setTimeout(()=>{
              this.ht_[0].dd();
            }, DSDT + 1000);
            return;
          }
        }

        // 过滤之后没有动作了
        if (n == 0) {
          if (!s) {
            tz.ws.send(o2['rw'] ? '{"m":2,"r":10,"v":0}' : '{"m":2,"r":9,"v":0}');
            this.cd_.rm();
          }
          return;
        }

        // 插入“过”
        d[9] = [];
        ++n;

        // 插入“弃”
        d[10] = [];
        ++n;

        let c = this.ca1_;
        c.init();
        n = 0;  // 按钮个数
        // 命令顺序：10弃、9过、1花、6和、5杠、4碰、3吃
        Uint8Array.of(10, 9, 1, 6, 5, 4, 3).forEach((e, i)=>{
          let v = d[e];
          if (v) {
            c.setup(n, 6 - i, this.aplcal.bind(this, e, v));
            ++n;
          }
        });

        // 出牌阶段
        if (this.phs_) {
          // 轮到自己打牌时，隐藏“过”和“弃”
          if (s) {
            c.hide(0);
            c.hide(1);
            n -= 2;
          }
          else if (!this.cfg_['s'] || ((this.cr_.turn + 1) & 3) === this.cr_.seat) {
            // 无战术鸣牌或者上家打牌后，隐藏“过”
            c.hide(1);
            --n;
          }
        }
        else {
          // 补花时，隐藏“弃”
          c.hide(0);
          --n;
        }

        if (n > 0) {
          c.visible = true;
          if (tz.phn) {
            c.commit();
            c.tgl(true);
            this.opt1_.tgl(false);
          }
          if (!tz.cfg['mutecall']) {
            tz.play('snd/08-inquire.wav');
          }
        }
      }

      /**
       * 提交鸣牌请求
       * @param {number} t 鸣牌类型
       * @param {array} v 鸣牌数据
       */
      aplcal(t, v) {
        console.log('aplcal', t, v);
        switch (v.length) {
        case 0:
          this.rmcal();
          tz.ws.send(`{"m":2,"r":${t},"v":0}`);
          this.cd_.rm();
          break;
        case 1:
          this.rmcal();
          tz.ws.send(`{"m":2,"r":${t},"v":${v[0]}}`);
          this.cd_.rm();
          break;
        default:
          // 多种鸣法选择
          this.ca2_.setup(t, v, (a)=>{
            this.ca2_.visible = false;
            if (typeof a !== 'undefined') {
              this.rmcal();
              tz.ws.send(`{"m":2,"r":${t},"v":${a}}`);
              this.cd_.rm();
            }
          });
          break;
        }
      }

      /**
       * 移除鸣牌按钮
       */
      rmcal() {
        this.ca1_.visible = false;
        this.ca2_.visible = false;
      }

      /**
       * 吃牌
       * @param {number} n 玩家
       * @param {number} p 副露
       */
      c(n, p) {
        let f = this.fly_;
        this.ht_[n].c(p, f.toGlobal({x:0,y:0}));

        f.dsty();
        this.fly_ = null;

        this.cr_.turn = n;
        if (n === 0) {
          this.cd_.setup(this.cfg_['r30']);
        }
      }

      /**
       * 碰牌
       * @param {number} n 玩家
       * @param {number} p 副露
       */
      p(n, p) {
        let f = this.fly_;
        this.ht_[n].p(p, f.toGlobal({x:0,y:0}));

        f.dsty();
        this.fly_ = null;

        this.cr_.turn = n;
        if (n === 0) {
          this.cd_.setup(this.cfg_['r30']);
        }
      }

      /**
       * 直杠
       * @param {number} n 玩家
       * @param {number} p 副露
       */
      dk(n, p) {
        let f = this.fly_;
        this.ht_[n].dk(p, f.toGlobal({x:0,y:0}));

        f.dsty();
        this.fly_ = null;

        this.cr_.turn = n;

        if (n === 0) {
          this.stpflw_ = true;
        }
      }

      /**
       * 加杠
       * @param {number} n 玩家
       * @param {number} p 副露
       */
      pk(n, p) {
        let f = this.fly_;
        if (f && f.pnd_) {
          f.pnd_();
        }

        let o = this.ht_[n].pk(p), d = o['p'];
        f = this.fly_ = o['s'];
        f.pnd_ = ()=>{
          this.fly_ = null;
          new TWEEN.Tween(f).to(d, DRDT).start();
        };

        if (n === 0) {
          this.stpflw_ = true;
        }
      }

      /**
       * 暗杠
       * @param {number} n 玩家
       * @param {number} p 副露
       */
      ck(n, p) {
        this.ht_[n].ck(p);

        if (n === 0) {
          this.stpflw_ = true;
        }
      }

      /**
       * 显示鸣牌字样
       * @param {number} n 玩家
       * @param {string} s 文本
       * @param {boolean} a 常亮（仅用在和牌后）
       */
      caltxt(n, s, a) {
        let t = this.catx_[n];
        if (t) {
          // 直接隐藏就可以了，反正在创建时的TWEEN.Tween动作中会删除
          t.visible = true;
        }

        let p = this.calpos_[n];
        t = this.catx_[n] = new PIXI.Text(s, {
          fontFamily: 'sans-serif',
          fontSize: 84,
          fontWeight: 'bold',
          fill: '#ffffff',
          stroke: '#000000',
          strokeThickness: 5,
          lineJoin: 'round',
          dropShadow: true,
          dropShadowColor: '#000000',
          //dropShadowAngle: Math.PI / 6,
          dropShadowDistance: 8,
          padding: 10
        });
        //t.anchor.x = p['ax'];
        //t.anchor.y = p['ay'];
        //t.x = p['x'];
        //t.y = p['y'];
        // 为使缩放效果以中心为锚点，这里计算其位置
        t.anchor.set(.5);
        t.x = p['x'] + (.5 - p['ax']) * t.width;
        t.y = p['y'] + (.5 - p['ay']) * t.height;
        this.ic_.addChild(t);

        if (!a) {
          t.scale.set(2);
          (new TWEEN.Tween(t)).to({alpha:1}, 200).start();
          (new TWEEN.Tween(t.scale)).to({x:1,y:1}, 200).onComplete(()=>{
            (new TWEEN.Tween(t)).to({alpha:0}, 200).delay(1500).onComplete(()=>{
              if (this.catx_[n] === t) {
                this.catx_[n] = null;
              }
              t.dsty();
            }).start();
          }).start();
        }
      }

      /**
       * 下家、对家、上家补花
       * @param {number} n 玩家
       */
      flw123(n) {
        let p = this.wa_.back();
        this.ht_[n].rpflw(p.toGlobal({x:0,y:0}));
      }

      /**
       * 自己补花
       * @param {number} o 使用的花牌
       * @param {number} n 抓回来的新牌
       */
      flw0(o, n) {
        let p = this.wa_.back();
        this.ht_[0].rpflw(o, n, p.toGlobal({x:0,y:0}));
      }

      /**
       * @param {JSON} h 手牌
       * @param {number} w 和牌张
       * @param {JSON} f 番表
       * @param {JSON} d 详情
       */
      stl(h, w, f, d){
        let p = this.pls_;
        let v = this.stl_ = new Settle(h, w, f, d, [p[0]['n'], p[1]['n'], p[2]['n'], p[3]['n']],
          this.cr_.seat, this.cfg_['r30'], ()=>{
          // 对局未结束，点OK就是准备；结束了就显示结束界面
          if (!this.rslt_) {
             tz.ws.send('{"m":2,"r":8,"v":0}');
          }
          else {
            this.rslt_.visible = true;
          }
          this.xstl();
        });
        this.sc_.addChild(v);
        let l = this.lyt_;
        v.layt(l['x'], l['y'], l['w'], l['h']);

        // 把和牌添加到历史记录里
        this.hst_.add(d['r'], d['s'] || new Uint8Array(4), d['n'], d['t'], h, w, f);
      }

      /**
       * 叉掉结算界面
       */
       xstl() {
        let v = this.stl_;
        if (v) v.dsty();
        this.stl_ = null;
      }

      /**
       * 显示错和界面
       * @param {number} f 错和番数
       * @param {JSON} t 番表
       */
      fwtip(f, t) {
        let v = new FalseWin(f, t);
        this.sc_.addChild(v);
        let l = this.lyt_;
        v.layt(l['x'], l['y'], l['w'], l['h']);

        // 轮到自己时错和，说明是自摸的错和，给4秒，再打牌
        if (this.cr_.self()) {
          setTimeout(()=>this.cd_.setup(this.cfg_['r30']), 4000);
        }
      }

      /**
       * 打开手牌
       * @param {array} h 四家的手牌
       * @param {boolean} f 和牌成功true，错和false
       * @param {number} w 和牌者
       * @param {number} c 放炮者
       * @param {number} t 和牌张
       */
      shhd(h, f, w, c, t) {
        let s = this.cr_.seat;
        if (f) {
          // 点炮和牌的飞牌效果
          let o = this.fly_;
          if (o && typeof w != 'undefined' && typeof c != 'undefined' && w !== c) {
            this.ht_[(w + 4 - s) & 3].win(t, o.toGlobal({x:0,y:0}));
            o.dsty();
          }
          this.fly_ = null;

          // 打开手牌
          setTimeout(()=>{
            this.ht_.forEach((e, i)=>{
              let v = (s + i) & 3, g = h[v];
              e.open(g['s'], g['p'], w === v ? t : undefined);
              if (w === v) {
                this.caltxt(i, tz.ls('Hu'), true);
              } else if (c === v) {
                this.caltxt(i, tz.ls('Shoot'), true);
              }
            }, DSDT * 3);
          });
        } else {
          // 错和打开手牌给大家看
          let g = h[w], n = (w + 4 - s) & 3;
          this.ht_[n].open(g['s'], g['p'], t, 5000);
          this.caltxt(n, tz.ls('FalseHu'));
        }
      }

      /**
       * 鼠标右键
       */
      rclk() {
        // 正在询问是否要鸣牌
        if (this.ca1_.visible) {
          this.rmcal();
          tz.ws.send(this.opt2_.rw() ? '{"m":2,"r":10,"v":0}' : '{"m":2,"r":9,"v":0}');
          this.cd_.rm();
        }

        // 右键摸切牌
        if (tz.cfg['rightdiscard'] && this.cr_.self()) {
          this.ht_[0].dd();
        }
      }

      /**
       * 点击桌面（手机用）
       */
      tapbg(e) {
        // 当target!==this时，说明是点击到了其他控件上
        if (e.target === this) {
          // TODO: 收起所有展开的面板
          //this.sc_.children.forEach(v=>v.visible = false);
          //if (tz.phn) {
          //  this.opt1_.tgl(false);
          //  this.hlp_.tgl(false);
          //}
          if (this.cr_.self()) {
            this.ht_[0].clk(13);
          }
        }
      }

      /**
       * 测速
       * @param {JSON} r 服务器传回的json
       */
      echo(r) {
        this.hlp_.spd(r['t']);
      }

      /**
       * 开始
       * @param {JSON} r 服务器传回的json
       */
      onstart(r) {
        this.setup(r['g']);
        this.hst_.init();
        this.stp_ = 0;  // 包序
      }

      /**
       * 发牌
       * @param {JSON} r 服务器传回的json
       */
      onsend(r) {
        this.init();
        this.send(r['h'], r['p'], r['d'], r['v']);
        this.phs_ = false;
        this.stp_ = 3;
      }

      /**
       * 询问补花
       * @param {JSON} r 服务器传回的json
       */
      onask(r) {
        let c = this.cr_;
        c.turn = r['v'];
        if (!c.self() || !r['f']) {
          // 没轮到自己时，或者没花时，移除倒计时和鸣牌选项
          this.cd_.rm();
          this.rmcal();
        } else {
          // 轮到自己且有花，提示补花
          this.addcal([0x10000]);
          this.cd_.setup(this.cfg_['r12']);
        }
      }

      /**
       * 补花
       * @param {JSON} r 服务器传回的json
       */
      onrpflw(r) {
        let c = this.cr_, v = r['v'], h = r['h'], s = c.seat;
        c.turn = v;
        tz.play(!this.pls_[v]['g'] ? 'snd/12-flower-m.wav' : 'snd/13-flower-f.wav');

        let n = (v + 4 - s) & 3;
        this.caltxt(n, tz.ls('Flower'));
        ++this.ub_[n].flower;
        c.remain = h;

        if (v !== s) {
          // 别人补花，移除倒计时
          this.flw123(n);
          this.cd_.rm();
        } else {
          // 自己补花
          let t = r['t'];
          this.flw0(lobyte(t), hibyte(t));
          this.addcal(r['a']);
          this.cd_.setup(this.cfg_[this.phs_ ? 'r30' : 'r12']);
        }
      }

      /**
       * 开始出牌
       * @param {JSON} r 服务器传回的json
       */
      onstgchg(r) {
        this.phs_ = true;
        this.cr_.turn = 0;
        if (this.cr_.seat !== 0) {
          // 庄家是别人
          this.cd_.rm();
          this.rmcal();
        } else {
          // 庄家是自己
          this.cd_.setup(this.cfg_['r30']);
          this.addcal(r['a']);
        }
      }

      /**
       * 抓牌
       * @param {JSON} r 服务器传回的json
       */
      ondraw(r) {
        let v = r['v'], t = r['t'], c = this.cr_, s = c.seat;
        c.turn = v;
        c.remain = r['h'];
        this.draw((v + 4 - s) & 3, hibyte(t), lobyte(t));
        this.rmcal();
        if (s === v) {
          // 自己抓牌
          this.cd_.setup(this.cfg_['r30']);
          this.addcal(r['a']);
        }
      }

      /**
       * 出牌
       * @param {JSON} r 服务器传回的json
       */
      ondscd(r) {
        let v = r['v'], a = r['a'], c = this.cr_, s = c.seat;
        this.dscd((v + 4 - s) & 3, r['t'], r['h']);
        if (a && a.length > 0) {
          this.cd_.setup(this.cfg_[((c.turn + 1) & 3) === s ? 'r30' : 'r12']);
          this.addcal(a);
        }
      }

      /**
       * 吃牌
       * @param {JSON} r 服务器传回的json
       */
      onc(r) {
        let v = r['v'], p = r['p'], s = this.cr_.seat, n = (v + 4 - s) & 3;
        if (p) {
          this.c(n, p);
        } else {
          // 只知道有人要吃
          tz.play(!this.pls_[v]['g'] ? 'snd/14-chow-m.wav' : 'snd/15-chow-f.wav');
          this.caltxt(n, tz.ls('Chow'));
          let a = r['a'];
          if (a && a.length > 0) {
            this.cd_.setup(this.cfg_['r12']);
            this.addcal(a);
          }
        }
      }

      /**
       * 碰牌
       * @param {JSON} r 服务器传回的json
       */
      onp(r) {
        let v = r['v'], p = r['p'], s = this.cr_.seat, n = (v + 4 - s) & 3;
        if (p) {
          this.p(n, p);
        } else {
          // 只知道有人要碰
          tz.play(!this.pls_[v]['g'] ? 'snd/16-pung-m.wav' : 'snd/17-pung-f.wav');
          this.caltxt(n, tz.ls('Pung'));
          let a = r['a'];
          if (a && a.length > 0) {
            this.cd_.setup(this.cfg_['r12']);
            this.addcal(a);
          }
        }
      }

      /**
       * 明杠
       * @param {JSON} r 服务器传回的json
       */
      onmk(r) {
        let v = r['v'], p = r['p'], s = this.cr_.seat, n = (v + 4 - s) & 3;
        if (!p) {
          // 只知道有人要杠
          tz.play(!this.pls_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
          this.caltxt(n, tz.ls('Kong'));

          let a = r['a'];
          if (a && a.length > 0) {
            this.cd_.setup(this.cfg_['r12']);
            this.addcal(a);
          }
        } else {
          if (!pro_k(p)) {
            // 直杠
            this.dk(n, p);
          } else {
            // 加杠（并且可能的抢杠动作）
            tz.play(!this.pls_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
            this.caltxt(n, tz.ls('Kong'));
            this.pk(n, p);
            let a = r['a'];
            if (a && a.length > 0) {
              this.cd_.setup(this.cfg_['r12']);
              this.addcal(a);
            }
          }
        }
      }

      /**
       * 暗杠
       * @param {JSON} r 服务器传回的json
       */
      onck(r) {
        let v = r['v'], p = r['p'], s = this.cr_.seat, n = (v + 4 - s) & 3;
        tz.play(!this.pls_[v]['g'] ? 'snd/18-kong-m.wav' : 'snd/19-kong-f.wav');
        this.caltxt(n, tz.ls('Kong'));
        this.ck(n, p);
      }

      /**
       * 和牌
       * @param {JSON} r 服务器传回的json
       */
      onwin(r) {
        // 测试数据
        //r = {d:{f:11,n:[0,0,0,0],p:0,r:0,s:[57,-19,-19,-19],t:[57,-19,-19,-19],w:1},f:2,i:100,m:2,p:{56:4,66:2,70:1,75:1,76:1,81:257},r:12,t:[{s:[12,13,26,28,35,82,83,92,93,94,99,102,104]},{s:[5,21,38,56,58,66,67,79,80,96,119,129,132],{s:[11,22,27,34,45,53,88,90,109,117,121,135,141]},{s:[14,33,42,44,47,60,62,68,87,98,103,114,125]}],v:0,w:81};
        //{"i":111,"m":2,"r":12,"v":769,"w":62,"f":1,"d":{"r":1,"w":1,"f":21,"p":769,"t":[-8,-29,-8,45],"s":[-8,-29,-8,45],"n":[0,0,0,0]},"t":[{"s":[4,5,24,52,73,81,84,91,102,120,123,133,138]},{"s":[7,14,18,23,48,51,57,58,75,85,87,98,117]},{"s":[22,25,29,34,47,49,74,78,97,100,116,125,141]},{"p":[6221],"s":[0,3,11,13,16,37,43,46,64,70]}],"p":{"28":16,"63":2,"75":1,"77":1,"81":1}}
        let v = r['v'], s = this.cr_.seat, wp = hibyte(v), cp = lobyte(v), n = (wp + 4 - s) & 3;
        let d = r['d'];
        if (!d) {
          // 只知道有人要和
          tz.play(!this.pls_[wp]['g'] ? 'snd/20-win-m.wav' : 'snd/21-win-f.wav');
          this.caltxt(n, tz.ls('Hu'));
          let a = r['a'];
          if (a && a.length > 0) {
            this.cd_.setup(this.cfg_['r12']);
            this.addcal(a);
          }
        } else {
          let w = d['w'];
          let t = r['t'];
          this.shhd(t, w, wp, cp, r['w']);
          if (!w) {
            this.ub_[n].flswn = true;
            //pool.falseWin_[n] = true;
            console.log('错和');
            if (wp === s) {
              // 自己错和，给出死得瞑目界面
              this.fwtip(d['f'], r['p']);
            }
          } else {
            this.cd_.rm();
            this.rmcal();
            this.stl(t[wp], r['w'], r['p'], d);
          }
        }
      }

      /**
       * 荒庄
       * @param {JSON} r 服务器传回的json
       */
      ontie(r) {
        // 测试数据
        //{"m":2,"r":13,"d":{"r":0,"w":0,"t":[0,0,0,0],"n":[0,0,0,0]},"t":[{"s":[3,10,17,18,25,27,30,45,54,74,76,79,87]},{"s":[19,33,53,56,63,88,102,105,114,117,123,124,140]},{"s":[8,11,22,43,55,75,86,90,93,94,95,108,138]},{"s":[1,12,24,41,47,72,106,110,120,122,125,132,135]}]}
        let f = this.fly_;
        if (f && f.pnd_) {
          f.pnd_();
        }

        this.shhd(r['t'], true);
        this.stl(null, 0, null, r['d']);
      }

      /**
       * 换位
       * @param {JSON} r 服务器传回的json
       */
      onxchg(r) {
        let v = r['v'], p = r['p'];  // 自己座位（门风），玩家信息
        let s = [0, 0, 0, 0];
        p.forEach((e, i)=>{
          let k = (i + 4 - v) & 3, u = this.ub_[k];
          u.flswn = false;
          u.flower = 0;
          u.name = e['n'];
          u.conn = !e['o'];
          s[k] = e['s'];
        });
        this.cr_.setup(v, s);
        this.pls_ = p;
        this.stp_ = 1;

        // 结构
        // [{"n":"%s","l":%hhu,"s":%hd,"g":%hhu,"o":%d,"v":%d,"rs":[%hd*16],"rp":[%hd*16]}*4]"
      }

      /**
       * 游戏结束
       * @param {JSON} r 服务器传回的json
       */
      onrslt(r) {
        // 测试数据
        //r={"p":[{"n":"名字1afsdafsdfafdasafdsfadsfads","l":0,"s":100},{"n":"名字2","l":0,"s":50},{"n":"名字3","l":0,"s":-50},{"n":"名字4","l":0,"s":-100}],"t":0};
        //this.cfg_={"t":"测试标题"};

        let v = this.rslt_ = new Result(this.cfg_['t'], this.cr_.seat, r['p'], r['t'], v=>{
          v.dsty();
          this.rslt_ = null;
          this.tidy();

          // 请求大厅信息
          tz.ws.send('{"m":1,"r":2}');
          tz.game.visible = false;
          tz.lobby.visible = true;
        });

        // 插入到最开始，以便于有的人还能看计分板
        this.sc_.addChildAt(v, 0);
        v.visible = false;

        let l = this.lyt_;
        v.layt(l['x'], l['y'], l['w'], l['h']);

        // 停止一局的计时器
        this.hlp_.stop();
      }

      /**
       * 包序检测
       * @param {JSON} r 服务器传回的json
       */
      chkstp(r) {
        if (r['i'] !== ++this.stp_) {
          tz.reenter();
          throw `missing step ${this.stp_}`;
        }
      }

      /**
       * 消息响应
       * @param {JSON} r 服务器传回的json
       */
      onmsg(r) {
        //console.log(JSON.stringify(r));
        let m = r['r'];
        switch (m) {
        case 1:  // 初始化桌子
          this.onstart(r);
          break;
        case 2:  // 起手
          this.onsend(r);
          break;
        case 3:  // 询问补花
          this.chkstp(r);
          this.onask(r);
          break;
        case 4:  // 补花
          this.chkstp(r);
          this.onrpflw(r);
          break;
        case 5:  // 开始出牌
          this.chkstp(r);
          this.onstgchg(r);
          break;
        case 6:  // 抓牌
          this.chkstp(r);
          this.ondraw(r);
          break;
        case 7:  // 出牌
          this.chkstp(r);
          this.ondscd(r);
          break;
        case 8:  // 吃
          this.chkstp(r);
          this.onc(r);
          break;
        case 9:  // 碰
          this.chkstp(r);
          this.onp(r);
          break;
        case 10:  // 明杠
          this.chkstp(r);
          this.onmk(r);
          break;
        case 11:  // 暗杠
          this.chkstp(r);
          this.onck(r);
          break;
        case 12:  // 和
          this.chkstp(r);
          this.onwin(r);
          break;
        case 13:  // 荒庄
          this.ontie(r);
          break;
        case 14:  // 换位
          this.onxchg(r);
          break;
        case 15:  // 延时
          break;
        case 16:  // 准备
          this.rdyf_[(r['v'] + 4 - this.cr_.seat) & 3].visible = true;
          break;
        case 17:  // 对局结束
          this.onrslt(r);
          break;
        case 18:  // 玩家离线/上线
          this.ub_[(r['v'] + 4 - this.cr_.seat) & 3].conn = r['c'];
          break;
        case 19:  // 超时
          this.tmot_.visible = true;
          break;
        }
      }

      /**
       * 重联
       * @param {JSON} r 服务器传回的json
       */
      reconn(r) {
        // 测试数据
        //{"m":4,"v":0,"s":1598809929116,"g":{"t":"fds","n":4,"d":false,"i":500,"l":8,"b":8,"r12":10,"r30":15,"dt":0,"d12":false,"fa":false,"fc":true,"s":true,"o":false,"a":true,"r":false},"u":[{"n":"码龙","s":500,"l":0,"g":0,"o":true,"f":2,"w":false,"v":1,"rs":[],"rp":[]},{"n":"192.168.1.*","s":500,"l":0,"g":0,"o":false,"f":2,"w":false,"v":0,"rs":[],"rp":[]},{"n":"192.168.1.*","s":500,"l":0,"g":0,"o":true,"f":0,"w":false,"v":0,"rs":[],"rp":[]},{"n":"192.168.1.*","s":500,"l":0,"g":0,"o":true,"f":0,"w":false,"v":0,"rs":[],"rp":[]}],"i":{"e":true,"d":0,"s":128,"t":0,"w":{"f":105,"b":4,"d":22101},"p":[[109,76,78,134,90,28,128,133,62,75,29,135,126],[114,120,132,129,71,112,117,119,46,63,17,96,30,54],[44,22,47,64,116,102,73,131,3,34,33,142,118],[20,16,66,92,21,130,140,13,99,5,79,6]],"h":[{"p":[3456,3530],"s":[14,37,48,50,67,122,123,23]},{"p":[2458,26837],"s":[-1,-1,-1,-1,-1,-1,-1]},{"p":[],"s":[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]},{"p":[],"s":[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]}]},"b":[]}
        console.log(JSON.stringify(r));
        /*
        let pool = this.pool_;
        let cfg = pool.cfg_ = resp['g'];
        this.setTitle(cfg);
        pool.reconnect(resp);
        */
        this.visible = true;

        this.setup(r['g']);
        this.init();
        this.hlp_.strt(r['s']);

        // 基本信息
        (function(){
          // 这一段和换位时类似
          let v = r['v'], p = r['u'], s = [0, 0, 0, 0];
          p.forEach((e, i)=>{
            let k = (i + 4 - v) & 3, u = this.ub_[k];
            u.name = e['n'];
            u.flower = e['f'];
            u.conn = !e['o'];
            u.flswn = e['w'];
            s[k] = e['s'];
          });
          this.cr_.setup(v, s);
          this.pls_ = p;

          this.hst_.rcvr(p, r['b']);  // 历史和牌记录
        }.bind(this))();

        // 正在进行的一盘牌
        function rvt(d) {
          this.stp_ = d['s'];  // 包序

          let c = this.cr_;
          c.order(d['d']);
          c.turn = d['t'];
          this.phs_ = d['e'];  // 出牌阶段or配牌补花阶段

          // 牌池
          let s = c.seat, p = d['p'];
          this.pl_.forEach((e, i)=>{
            e.setup(p[i + s & 3]);
          });

          // 飞牌
          let a = d['at'];
          if (typeof a !== 'undefined') {
            let n = (c.turn + 4 - s) & 3;

            // 从牌池中找一个位置
            let o = this.pl_[n].pick();
            if (o) {
              o.updt(a);

              // 假装从手牌中打出
              let f = this.fly_ = this.ht_[n].fly(a, o);

              // 归位回调
              f.pnd_ = ()=>{
                this.fly_ = null;
                o.acpt_ = true;
                new TWEEN.Tween(f).to({x:o.x, y:o.y}, DRDT).onComplete(()=>{
                  o.visible = true;
                  f.dsty();
                }).start();
              };
            }
          }

          // 牌墙，骰子，首部，尾部
          let w = d['w'], dc = w['d'], f = w['f'], b = w['b'];
          let wa = this.wa_;
          wa.dice(s, [dc & 0xf, (dc >> 4) & 0xf, (dc >> 8) & 0xf, (dc >> 12) & 0xf]);
          c.remain = 144 - f - b;
          for (; f > 0; --f) {
            wa.front();
          }
          for (; b > 0; --b) {
            wa.back();
          }

          // 手牌
          this.ht_.forEach((e, i)=>{
            let h = d['h'][(s + i) & 3];
            e.setup(h['s'], h['p']);
          });

          // 动作
          this.addcal(d['a']);
        }

        let d = r['i'];
        if (d) {
          rvt.bind(this)(d);
        }
      }
    }

    /**
     * 游戏设置界面
     * @typedef {object} Setting2
     */
    class Setting2 extends AutoHide {
      constructor() {
        super();

        const w = Setting2.W, h = Setting2.H;

        //this.width = w;
        //this.height = h;

        let bg = this.ic_ = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w, h);
        bg.endFill();
        bg.interactive = true;

        // 标题
        let t = new PIXI.Text(tz.ls('GameSetting'), {
          fontFamily: FF,
          fontSize: 32,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = w * .5;
        t.y = 40;

        const bs =  {
          fontFamily: FF,
          fontSize: 24,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        };

        // 音量
        t = new PIXI.Text(tz.ls('Volume'), bs);
        bg.addChild(t);
        t.anchor.y = .5;
        t.x = 30;
        t.y = 110;

        let t0 = new PIXI.Text('100%', bs);
        bg.addChild(t0);
        t0.anchor.x = 1;
        t0.anchor.y = .5;
        t0.x = w - 145;
        t0.y = 110;

        let rb = new RngBr(t0.x - t0.width - t.x - t.width - 15, 30, 15, (v)=>{
          t0.text = Math.round(v) + '%';
        });
        bg.addChild(rb);
        rb.x = t.x + t.width + 10;
        rb.y = 95;
        let v = tz.cfg['volume'];
        v = (typeof v === 'number') ? Math.max(0, Math.min(100, v)) : 100;
        t0.text = Math.round(v) + '%';
        rb.val = v;

        this.ovrwrt_ = false;
        this.playing_ = false;
        let b = new TxtBtn(tz.ls('VolumeTest'), bs, 120, 50, ()=>{
          if (this.playing_) return;
          let v0 = PIXI.sound.volumeAll;
          PIXI.sound.volumeAll = rb.val / 100;
          try {
            this.playing_ = true;
            tz.res['snd/01-start.wav'].sound.play(()=>{
              if (!this.ovrwrt_) {
                PIXI.sound.volumeAll = v0;
              }
              this.playing_ = false;
            });
          }
          catch (e) {
            this.playing_ = false;
            console.log(e);
            PIXI.sound.volumeAll = v0;
          }
        });
        bg.addChild(b);
        b.x = w - 140;
        b.y = 80 + 5;

        // 倒计时音效
        t = new PIXI.Text(tz.ls('CountdownEffects'), bs);
        bg.addChild(t);
        t.anchor.y = .5;
        t.x = 30;
        t.y = 160;

        let cb1 = new ChkBox();
        bg.addChild(cb1);
        cb1.scale.set(.75);
        cb1.x = t.x + t.width + 40;
        cb1.y = t.y - 18;
        cb1.sel = !tz.cfg['mutecd'];

        // 鸣牌提示音效
        t = new PIXI.Text(tz.ls('CallHintEffects'), bs);
        bg.addChild(t);
        t.anchor.y = .5;
        t.x = 30;
        t.y = 210;

        let cb2 = new ChkBox();
        bg.addChild(cb2);
        cb2.scale.set(.75);
        cb2.x = t.x + t.width + 40;
        cb2.y = t.y - 18;
        cb2.sel = !tz.cfg['mutecall'];

        // 右键摸切
        let cb3;
        if (!tz.phn) {
          t = new PIXI.Text(tz.ls('RClickDiscard'), bs);
          bg.addChild(t);
          t.anchor.y = .5;
          t.x = 30;
          t.y = 260;

          cb3 = new ChkBox();
          bg.addChild(cb3);
          cb3.scale.set(.75);
          cb3.x = t.x + t.width + 40;
          cb3.y = t.y - 18;
          cb3.sel = tz.cfg['rightdiscard'];
        }

        // 确认和取消
        const w1 = 120, h1 = 50;
        b = new TxtBtn(tz.ls('Cancel'), bs, w1, h1, ()=>{
          this.dsty();
        });
        bg.addChild(b);
        b.x = w * .3 - w1;
        b.y = h - h1 - 20;

        b = new TxtBtn(tz.ls('Confirm'), bs, w1, h1, ()=>{
          let cfg = tz.cfg;
          let v = rb.val;
          cfg['volume'] = v;
          cfg['mutecd'] = cb1.sel ? 0 : 1;
          cfg['mutecall'] = cb2.sel ? 0 : 1;
          if (!tz.phn) {
            cfg['rightdiscard'] = cb3.sel ? 1 : 0;
          }
          tz.save();
          PIXI.sound.volumeAll = v / 100;
          this.ovrwrt_ = true;

          this.dsty();
        });
        bg.addChild(b);
        b.x = w * .7;
        b.y = h - h1 - 20;
      }

      /**
       * 点击外部
       */
      tapout() {
        console.log('Setting2 tapout');
        this.dsty();
      }

      /**
       * 适配
       * @param {number} x
       * @param {number} y
       * @param {number} w
       * @param {number} h
       */
      layt(x, y, w, h) {
        super.layt();
        const w0 = Setting2.W, h0 = Setting2.H, s0 = Setting2.S;
        let c = this.ic_, s = Math.min(w * s0 / w0, h * s0 / h0, 1);
        c.scale.set(s);
        c.x = x + (w - w0 * s) * .5;
        c.y = y + (h - h0 * s) * .5;
        console.log('layout scale Setting2 =', s);
      }
    }
    Setting2.W = 600;
    Setting2.H = 420;
    Setting2.S = .95;

    // =====================================================================================================

    const LBW = 680, LBH = 700;

    /**
     * 全局设置界面
     * @typedef {object} Setting
     */
    class Setting extends PIXI.Container {
      constructor() {
        super();

        let c = new PIXI.Sprite(PIXI.Texture.WHITE);
        c.tint = 0;
        c.alpha = .5;
        c.width = LBW;
        c.height = LBH;
        this.addChild(c);
        c.interactive = true;

        const w = 550, h = 560;

        let bg = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x060F16, .85);
        bg.drawRect(0, 0, w, h);
        bg.endFill();
        bg.interactive = true;

        bg.x = (LBW - w) * .5;
        bg.y = (LBH - h) * .5;

        // 标题
        let t = new PIXI.Text(tz.ls('Setting'), {
          fontFamily: FF,
          fontSize: 24,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = w * .5;
        t.y = 30;

        const bs =  {
          fontFamily: FF,
          fontSize: 18,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, bs1 = {
          fontFamily: FF,
          fontSize: 14,
          fill: '#ffffff',
          // stroke: '#0066ff',
          // strokeThickness: 2,
          //lineJoin: 'round',
          padding: 10
        };

        // 音量
        t = new PIXI.Text(tz.ls('Volume'), bs);
        bg.addChild(t);
        t.anchor.y = .5;
        t.x = 20;
        t.y = 80;

        let t0 = new PIXI.Text('100%', bs);
        bg.addChild(t0);
        t0.anchor.x = 1;
        t0.anchor.y = .5;
        t0.x = w - 110;
        t0.y = 80;

        let rb = new RngBr(t0.x - t0.width - t.x - t.width - 10, 20, 10, (v)=>{
          t0.text = Math.round(v) + '%';
        });
        bg.addChild(rb);
        rb.x = t.x + t.width + 5;
        rb.y = 70;
        let v = tz.cfg['volume'];
        v = (typeof v === 'number') ? Math.max(0, Math.min(100, v)) : 100;
        t0.text = Math.round(v) + '%';
        rb.val = v;

        this.ovrwrt_ = false;
        this.playing_ = false;
        let b = new TxtBtn(tz.ls('VolumeTest'), bs, 90, 35, ()=>{
          if (this.playing_) return;
          let v0 = PIXI.sound.volumeAll;
          PIXI.sound.volumeAll = rb.val / 100;
          try {
            this.playing_ = true;
            tz.res['snd/01-start.wav'].sound.play(()=>{
              if (!this.ovrwrt_) {
                PIXI.sound.volumeAll = v0;
              }
              this.playing_ = false;
            });
          }
          catch (e) {
            this.playing_ = false;
            console.log(e);
            PIXI.sound.volumeAll = v0;
          }
        });
        bg.addChild(b);
        b.x = w - 105;
        b.y = 80 - 17.5;

        t = new PIXI.Text(tz.ls('NeedRefreshHint'), bs);
        bg.addChild(t);
        bg.addChild(t);
        t.anchor.set(.5);
        scl_txt(t, 510);  // 550-20-20
        t.x = w * .5;
        t.y = 120;

        // 语言
        t = new PIXI.Text(tz.ls('Language'), bs);
        bg.addChild(t);
        bg.addChild(t);
        t.anchor.y = .5;
        t.x = 20;
        t.y = 160;

        let g = this.grp0_ = new RdoGrp();
        [tz.ls('Default'), '简', '繁', 'EN']
        .forEach((e, i)=>{
          let cb = new ChkBox(e, ()=>this.grp0_.idx = i);
          bg.addChild(cb);
          cb.scale.set(.6);
          cb.x = t.x + t.width + 10 + 100 * i;
          cb.y = t.y - 13.5;
          g.add(cb);
        });
        g.idx = tz.cfg['lang'] || 0;

        t = new PIXI.Text(tz.ls('DefaultLangHint'), bs1);
        bg.addChild(t);
        bg.addChild(t);
        t.anchor.y = .5;
        scl_txt(t, 480);  // 550-50-20
        t.x = 50;
        t.y = 190;

        // 牌面风格
        t = new PIXI.Text(tz.ls('TileStyle'), bs);
        bg.addChild(t);
        t.anchor.y = .5;
        t.x = 20;
        t.y = 230;

        g = this.grp1_ = new RdoGrp();

        let cb = new ChkBox(tz.ls('Default'), ()=>this.grp1_.idx = 0);
        bg.addChild(cb);
        cb.scale.set(.6);
        cb.x = 20;
        cb.y = 270;
        g.add(cb);

        cb = new ChkBox(undefined, ()=>this.grp1_.idx = 1);
        bg.addChild(cb);
        cb.scale.set(.6);
        cb.x = 120;
        cb.y = 270;
        g.add(cb);

        // 无上角标的示范
        let tmp = tz.tlscp;  // 保存原有设置，生成样例后恢复
        tz.tlscp = false;
        [16, 108, 130].forEach((e, i)=>{
          let p = new StTl(e);
          bg.addChild(p);
          p.x = 155 + W0 * i;
          p.y = 285 - H0F * .5;
        });
        tz.tlscp = tmp;

        cb = new ChkBox(undefined, ()=>this.grp1_.idx = 2);
        bg.addChild(cb);
        cb.scale.set(.6);
        cb.x = 320;
        cb.y = 270;
        g.add(cb);

        // 带上角标的示范
        tz.tlscp = true;
        [16, 108, 130].forEach((e, i)=>{
          let p = new StTl(e);
          bg.addChild(p);
          p.x = 355 + W0 * i;
          p.y = 285 - H0F * .5;
        });
        tz.tlscp = tmp;
        g.idx = tz.cfg['tilescript'] || 0;

        t = new PIXI.Text(tz.ls('DefaultTileStyleHint'), bs1);
        bg.addChild(t);
        bg.addChild(t);
        t.anchor.y = .5;
        scl_txt(t, 480);  // 550-50-20
        t.x = 50;
        t.y = 340;

        // 显示牌墙
        t = new PIXI.Text(tz.ls('ShowWall'), bs);
        bg.addChild(t);
        t.anchor.y = .5;
        t.x = 20;
        t.y = 380;

        g = this.grp2_ = new RdoGrp();
        ['Default', 'Yes', 'No']
        .forEach((e, i)=>{
          let cb = new ChkBox(tz.ls(e), ()=>this.grp2_.idx = i);
          bg.addChild(cb);
          cb.scale.set(.6);
          cb.x = t.x + t.width + 20 + 100 * i;
          cb.y = t.y - 13.5;
          g.add(cb);
        });
        g.idx = tz.cfg['wall'] || 0;

        t = new PIXI.Text(tz.ls('DefaultWallHint'), bs1);
        bg.addChild(t);
        bg.addChild(t);
        t.anchor.y = .5;
        scl_txt(t, 480);  // 550-50-20
        t.x = 50;
        t.y = 410;

        if (tz.phn) {
          // 钢琴键尺寸
          t = new PIXI.Text(tz.ls('PianoSize'), bs);
          bg.addChild(t);
          t.anchor.y = .5;
          t.x = 20;
          t.y = 450;

          g = this.grp3_ = new RdoGrp();
          ['Default', '3Tabs', '2Tabs']
          .forEach((e, i)=>{
            let cb = new ChkBox(tz.ls(e), ()=>this.grp3_.idx = i);
            bg.addChild(cb);
            cb.scale.set(.6);
            cb.x = t.x + t.width + 10 + 100 * i;
            cb.y = t.y - 13.5;
            g.add(cb);
          });
          g.idx = tz.cfg['piano'] || 0;

          t = new PIXI.Text(tz.ls('AutoPianoHint'), bs1);
          bg.addChild(t);
          bg.addChild(t);
          t.anchor.y = .5;
          scl_txt(t, 480);  // 550-50-20
          t.x = 50;
          t.y = 480;
        }

        const w1 = 90, h1 = 35;
        b = new TxtBtn(tz.ls('Cancel'), bs, w1, h1, ()=>{
          this.dsty();
        });
        bg.addChild(b);
        b.x = w * .25 - w1;
        b.y = h - h1 - 15;

        b = new TxtBtn(tz.ls('Confirm'), bs, w1, h1, ()=>{
          let cfg = tz.cfg;
          let v = rb.val;
          cfg['volume'] = v;
          //console.log('grp0', this.grp0_.idx);
          //console.log('grp1', this.grp1_.idx);
          //console.log('grp2', this.grp2_.idx);
          cfg['lang'] = this.grp0_.idx;
          cfg['superscript'] = this.grp1_.idx;
          cfg['wall'] = this.grp2_.idx;
          if (tz.phn) {
            cfg['piano'] = this.grp3_.idx;
          }
          tz.save();
          PIXI.sound.volumeAll = v / 100;
          this.ovrwrt_ = true;

          this.dsty();
        });
        bg.addChild(b);
        b.x = w * .75;
        b.y = h - h1 - 15;
      }
    }
    Setting.W = 450;
    Setting.H = 390;

    /**
     * 最顶层view
     * @typedef {object} TpMst
     */
    class TpMst extends PIXI.Container {
      constructor() {
        super();
      }

      /**
       * 适配
       * @param {number} w 宽度
       * @param {number} h 高度
       */
      layt(w, h) {
        //console.log('width, height', w, h);
        let s = Math.min(w / LBW, h / LBH);
        this.scale.set(s);
        let w0 = LBW * s;
        this.x = (w > w0) ? (w - w0) * .5 : 0;
      }

      /**
       * 提示错误
       * @param {string} s 文本
       * @param {boolean} r 一直保持不消失
       */
      err(s, r) {
        let c = new PIXI.Container();
        this.addChild(c);

        let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
        c.addChild(bg);

        let t = new PIXI.Text(s, {
          fontFamily: FF,
          fontSize: 32,
          fill: '#000000',
          padding: 10
        });
        c.addChild(t);
        t.x = 20;
        t.y = 20;
        scl_txt(t, LBW - 40);

        let w = t.width, h = t.height;
        bg.alpha = .9;
        bg.width = w + 40;
        bg.height = h + 40;
        c.x = (LBW - w) * .5 - 20;
        c.y = (LBH - h) * .5 - 20;

        if (!r) {
          (new TWEEN.Tween(c)).to({alpha:1}, 100).onComplete(()=>{
            (new TWEEN.Tween(c)).to({alpha:0}, 100).delay(1300).onComplete(()=>{ c.dsty(); }).start();
          }).start();
        }
      }
    }

    /**
     * 大厅
     * @typedef {object} Lobby
     */
    class Lobby extends PIXI.Container {
      constructor() {
        super();

        let ic = this.ic_ = new PIXI.Container();
        //ic.width = LBW;
        //ic.height = LBH;
        this.addChild(ic);

        let bg = new PIXI.Sprite(PIXI.Texture.WHITE);
        bg.tint = 0x89a4c7;
        bg.alpha = .5;
        bg.width = LBW;
        bg.height = LBH;
        ic.addChild(bg);

        //let r = {"m":1,"r":2,"t":{"i":10001,"t":1548852882425,"r":0,"u":false,"p":["游客10002","","",""],"g":{"t" : "45679","n":16,"d":false,"i":0,"l":8,"r12":3,"r30":10,"dt":255,"d12":false,"fa":true,"fc":false,"s":true,"o":false,"a":false,"r":true}}};
        //ic.addChild(new TableInfoView(r['t']));

        const w0 = 100, h0 = 40, bs = {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        };

        let b = this.nb_ = new TxtBtn(undefined, bs, w0, h0, ()=>{ tz.ws.send('{"m":1,"r":10}'); });
        ic.addChild(b);
        b.x = LBW - w0;

        b = new TxtBtn(tz.ls('Speed'), bs, 70, h0, ()=>{
          tz.ws.send(`{"m":5,"t":${new Date().getTime()}}`);
          this.sp_.ac_ = setTimeout(()=>{
            this.sp_.text = '-';
          }, 60000);
        });
        ic.addChild(b);
        b.x = LBW - w0 - 75;

        b = new TxtBtn(tz.ls('Home'), bs, 70, h0, ()=>{ window.open('/','_blank'); });
        ic.addChild(b);

        b = new TxtBtn(tz.ls('Setting'), bs, 70, h0, ()=>{
          let v = new Setting();
          this.ic_.addChild(v);
          v.x = (LBW - v.width) * .5;
          v.y = (LBH - v.height) * .5;
        });
        ic.addChild(b);
        b.x = 75;

        let t = this.sp_ = new PIXI.Text('-', {
          fontFamily: FF,
          fontSize: 16,
          fill: '#ffffff',
          padding: 10
        });
        ic.addChild(t);
        t.anchor.x = 1;
        t.anchor.y = .5;
        t.x = LBW - w0 - 80;
        t.y = 20;

        const tt = ['Free', 'Waiting', 'Playing', 'Offline'];
        let st = [null, null, null, null];
        for (let i = 0; i < 4; ++i) {
          t = new PIXI.Text(tz.ls(tt[i]), {
            fontFamily: FF,
            fontSize: 16,
            fill: '#ffffff',
            padding: 10
          });
          ic.addChild(t);
          t.anchor.y = .5;
          let x = t.x = 185 + (i & 1) * 140;
          let y = t.y = 12 + (i >> 1) * 20;

          x += t.width + 5;
          t = st[i] = new PIXI.Text('0', {
            fontFamily: FF,
            fontSize: 16,
            fill: '#cccccc',
            padding: 10
          });
          ic.addChild(t);
          t.anchor.y = .5;
          t.x = x;
          t.y = y;
        }
        this.st_ = st;

        t = new PIXI.Text(tz.ls('NoGambling'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          padding: 10
        });
        ic.addChild(t);
        t.anchor.set(.5);
        t.x = LBW * .5;
        t.y = LBH - h0 - 75;

        b = new TxtBtn(tz.ls('NewTable'), bs, w0, h0, ()=>this._newtbl());
        ic.addChild(b);
        b.x = (LBW - w0) * .5;
        b.y = LBH - h0 - 10;

        b = this.pv_ = new TxtBtn(tz.ls('Prev'), bs, w0, h0, ()=>this._prev());
        ic.addChild(b);
        b.x = LBW * .25 - w0 * .5;
        b.y = LBH - h0 - 60;

        b = this.nx_ = new TxtBtn(tz.ls('Next'), bs, w0, h0, ()=>this._next());
        ic.addChild(b);
        b.x = LBW * .75 - w0 * .5;
        b.y = LBH - h0 - 60;

        this.tb_ = [];  // 用来存放桌子的结点
        this.pg_ = 0;  // 页数

        t = this.pt_ = new PIXI.Text('1/1', bs);
        ic.addChild(t);
        t.anchor.set(.5);
        t.x = LBW * .5;
        t.y = LBH - h0 - 40;

        this._enable(this.pv_, false);
        this._enable(this.nx_, false);

        let ro = this.ro_ = new PIXI.Container();
        ic.addChild(ro);
      }

      /**
       * 启用/禁用上下一页按钮
       * @param {object} b 上下一页
       * @param {boolean} e 启用true；禁用false
       */
      _enable(b, e) {
        let s = b.fa_.style;
        if (e) {
          s.fill = '#ffffff';
          s.stroke = '#0066ff';
          b.interactive = true;
        }
        else {
          s.fill = '#cccccc';
          s.stroke = '#000000';
          b.interactive = false;
          b.fg_.visible = false;
        }
      }

      /**
       * 适配
       * @param {number} w 宽度
       * @param {number} h 高度
       */
      layt(w, h) {
        //console.log('width, height', w, h);
        let s = Math.min(w / LBW, h / LBH);
        this.ic_.scale.set(s);
        let w0 = LBW * s;
        this.ic_.x = w > w0 ? (w - w0) * .5 : 0;
      }

      /**
       * 测速
       * @param {JSON} r 服务器传回的json
       */
      echo(r) {
        this.sp_.text = `${new Date().getTime() - r['t']}ms`;
        clearTimeout(this.sp_.ac_);
      }

      onmsg(r) {
        switch(r['r']){
        case 1:{
          let tp = tz.tpvw;
          switch (r['e']) {
          default: tp.err(tz.ls('ErrorUnknownX', r['e'])); break;
          case 1: tp.err(tz.ls('ErrorUnknown')); break;
          case 1: tp.err(tz.ls('ErrorInTable')); break;
          case 2: tp.err(tz.ls('ErrorInGame')); break;
          case 3: tp.err(tz.ls('ErrorTableNotExist')); break;
          case 4: tp.err(tz.ls('ErrorWrongSeat')); break;
          case 5: tp.err(tz.ls('ErrorSeatOccupied')); break;
          case 6: tp.err(tz.ls('ErrorPassword')); break;
          case 7: tp.err(tz.ls('ErrorNotInTable')); break;
          case 8: tp.err(tz.ls('ErrorLoginElsewhere'), true); break;
          case 9: tp.err(tz.ls('ErrorTooLong')); break;
          case 10: tp.err(tz.ls('ErrorGuestEntry')); break;
          case 11: tp.err(tz.ls('ErrorSpecialChars')); break;
          case 12: tp.err(tz.ls('ErrorTimeSetting')); break;
          case 13: tp.err(tz.ls('ErrorNotMatch')); break;
          case 14: tp.err(tz.ls('ErrorVerifyExpired')); break;
          case 15: tp.err(tz.ls('ErrorVerifyAns')); break;
          case 17: tp.err(tz.ls('ErrorNotSupport')); break;
          case 18: tp.err(tz.ls('ErrorIP')); break;
          case 19: tp.err(tz.ls('ErrorNotActivated')); break;
          case 16: {
            document.cookie = '__p=;Path=/;Max-Age=0';
            let un, pw;
            // 使用token登录失败后，尝试用本地保存的账号密码登录
            // 如果本地无账号密码，提示手动登录
            if (this.tlr_ && (un = tz.cfg['username']) && (pw = tz.cfg['token'])) {
              this.tlr_ = false;
              tz.ws.send(`{"m":1,"r":12,"u":"${un}","p":"${pw}"}`);
            }
            else {
              tp.err('ErrorAutoLogin');
            }
            break;
          }
          }
          break;
        }
        case 2: {
          // 所有桌子
          let t = this.nb_.fa_;
          t.text = r['n'] || '';
          scl_txt(t, 95);

          let tv;
          while ((tv = this.tb_.pop())) {
            tv.dsty();
          }
          // 无需break，接着走case 3一样的逻辑
        }
        case 3: {
          // 创建桌子
          r['t'].forEach(t=>{
            let tv = new TblDtl(t, (id, s, p)=>this._cb(id, s, p));
            tv.x = 10;
            this.ro_.addChild(tv);
            this.tb_.push(tv);

            tv.rfsh(this.id_, this.se_);
          });
          this._rfsh();
          this._stat(r['s']);
          break;
        }
        case 4:
          // 坐下
          this._sit(r['t']);
          this._stand(r['f']);
          this._stat(r['s']);
          break;
        case 5:
          // 站起
          this._stand(r['t']);
          this._stat(r['s']);
          break;
        case 6:
          // 准备
          this._ready(r['t']);
          break;
        case 7:
          // 删除桌子
          this._delete(r['t']);
          this._stat(r['s']);
          break;
        case 8: {
          // 同步大厅信息
          let t = r['t'];
          if (t) {
            this.id_ = t['i'];
            this.se_ = t['s'];
          }
          this._stat(r['s']);
          break;
        }
        case 9: {
          // 登录
          let t = this.nb_.fa_;
          t.text = r['u'];
          scl_txt(t, 95);
          let k = r['t'];
          if (k) {
            let e = new Date();
            e.setTime(e.getTime() + 864000);
            document.cookie=`__p=${k};Path=/;Expires=${e.toGMTString()}`;
          }
          let p = r['p'];
          if (p) {
            tz.cfg['token'] = p;
            tz.save();
          }
          //if ((this.id_ = r['i'])) {
          //  this.se_ = r['s'];
          //  let i = this._find(this.id_);
          //  if (i != -1) {
          //    this.tb_[i].rfsh(this.id_, this.se_);
          //  }
          //}
          break;
        }
        case 10:
          // 验证码
          this._login(r['z']);
          break;
        case 13:
          // 桌子进度
          this._prog(r);
          break;
        }
      }

      /**
       * 刷新
       */
      _rfsh() {
        let tb = this.tb_;
        let mp = Math.ceil(tb.length / 4);
        if (mp === 0) {
          mp = 1;
        }

        let p = this.pg_;
        if (p >= mp) {
          p = mp - 1;
          this.pg_ = p;
        }

        let s = p * 4, e = s + 4;
        tb.sort((a, b)=>{ return b.t_ - a.t_; });
        tb.forEach((tv, k)=>{
          if (k < s || k >= e) {
            tv.visible = false;
          }
          else {
            tv.visible = true;
            tv.y = 50 + (tv.height + 5) * (k - s);
          }
        });

        this._enable(this.pv_, p > 0);
        this._enable(this.nx_, (p + 1) < mp);
        this.pt_.text = (p + 1) + '/' + mp;
      }

      /**
       * 上一页
       */
      _prev() {
        if (this.pg_ === 0) {
          return;
        }
        --this.pg_;
        this._rfsh();
      }

      /**
       * 下一页
       */
      _next() {
        if (this.pg_ >= Math.ceil(this.tb_.length / 4)) {
          return;
        }
        ++this.pg_;
        this._rfsh();
      }

      /**
       * 刷新大厅状态
       * @param {JSON} s 包含空闲、等待、对局、托管四种状态人数的json
       */
      _stat(s) {
        if (s) {
          this.st_[0].text = s['f'];
          this.st_[1].text = s['w'];
          this.st_[2].text = s['p'];
          this.st_[3].text = s['o'];
        }
      }

      /**
       * 搜索桌子
       * @param {number} i 桌ID
       */
      _find(i) {
        return this.tb_.findIndex(tb=>tb.id_ === i);
      }

      /**
       * 坐下
       * @param {JSON} t 包含桌ID、座位、名字的json
       */
      _sit(t) {
        let i = this._find(t['i']);
        if (i !== -1) {
          let tv = this.tb_[i];
          tv.sit(t['s'], t['n']);
          tv.rfsh(this.id_, this.se_);
        }
      }

      /**
       * 站起
       * @param {JSON} t 包含桌ID、座位的json
       */
      _stand(t) {
        if (typeof t === 'undefined') return;
        let i = this._find(t['i']);
        if (i !== -1) {
          let tv = this.tb_[i];
          tv.stand(t['s']);
          tv.rfsh(this.id_, this.se_);
        }
      }

      /**
       * 准备
       * @param {JSON} t 包含桌ID、座位、准备状态的json
       */
      _ready(t) {
        let i = this._find(t['i']);
        if (i !== -1) {
          let tv = this.tb_[i];
          tv.ready(t['s'], !!t['r'], this.id_);
        }
      }

      /**
       * 进度
       * @param {JSON} t 包含桌ID、进度、总盘数的json
       */
      _prog(t) {
        let i = this._find(t['i']);
        if (i !== -1) {
          let tv = this.tb_[i];
          tv.prog(t['p'], t['t']);
        }
      }

      /**
       * 删除桌子
       * @param {JSON} t 包含桌ID的json
       */
      _delete(t) {
        let i = this._find(t['i']);
        if (i !== -1) {
          let tb = this.tb_;
          let tv = tb[i];
          tb.splice(i, 1);
          tv.dsty();
          this._rfsh();
        }
      }

      /**
       * 显示登录界面
       * @param {string} z 验证码
       */
      _login(z) {
        if (this.lg_) {
          return;
        }

        let l = this.lg_ = new Login(z, (un, pw, s)=>{
          //console.log('un pw', un, pw);
          if (un && pw) {
            tz.ws.send(`{"m":1,"r":9,"u":"${un}","p":"${pw}","z":"${z}","s":"${s}"}`);
            tz.cfg['username'] = un;
            tz.save();
          }
          this.lg_.dsty();
          delete this.lg_;
        });
        this.ic_.addChild(l);
        l.x = (LBW - l.width) * .5;
        l.y = (LBH - l.height) * .5;
      }

      /**
       * 显示创建桌子界面
       */
      _newtbl() {
        if (this.nt_) {
          return;
        }

        let nt = this.nt_ = new NewTbl((g)=>{
          //console.log('cfg', g);
          if (g) {
            let bl = (function(s){
              let r = 0;
              for (let i = 0, l = s.length; i < l; ++i) {
                let c = s.charCodeAt(i);
                r += (c >= 0 && c < 256) ? 1 : 2;
              }
              return r;
            })(g['t']);
            let tp = tz.tpvw;
            if (bl === 0) {
              tp.err(tz.ls('ErrorEmptyTitle'));
              return;
            }
            if (bl > 40) {
              tp.err(tz.ls('ErrorTitleLength'));
              return;
            }
            let p = g['p'];
            if (p.length > 0 && !p.match('[0-9a-zA-Z]')) {
              tp.err(tz.ls('ErrorPasswordChar'));
              return;
            }
            if (p.length > 6) {
              tp.err(tz.ls('ErrorPasswordLength'));
              return;
            }
            tz.ws.send(JSON.stringify({'m':1,'r':3,'g':g}));
            //tz.ws.send(JSON.stringify({'m':1,'r':14,'g':g}));  // 试玩
          }

          this.nt_.dsty();
          delete this.nt_;
        });
        this.ic_.addChild(nt);
      }

      /**
       * 加入桌子回调
       * @param {number} id 桌ID
       * @param {number} s 座位
       * @param {string} p 密码
       */
      _cb(id, s, p) {
        //console.log(`{"m":1,"r":4,"v":${id},"s":${s}}`);
        if (s !== this.se_) {
          if (!p || this.id_ === id) {
            tz.ws.send(`{"m":1,"r":4,"v":${id},"s":${s}}`);
          }
          else {
            if (this.pi_) {
              return;
            }
            let pi = this.pi_ = new PswIpt((p)=>{
              if (p) {
                tz.ws.send(`{"m":1,"r":4,"v":${id},"s":${s},"p":"${p}"}`);
              }
              this.pi_.dsty();
              delete this.pi_;
            });
            this.ic_.addChild(pi);
          }
        }
        else {
          tz.ws.send('{"m":1,"r":5}');
        }
      }
    }

    /**
     * 桌子信息
     * @typedef {object} TblDtl
     */
    class TblDtl extends PIXI.Container {
      /**
       * @param {JSON} d 桌子信息
       * @param {function(number,number,boolean):void} cb 座位回调
       */
      constructor(d, cb) {
        super();

        this.id_ = d['i'];
        this.t_ = d['t'];
        this.pw_ = d['u'];

        const w0 = LBW - 20, h0 = 120, gap = 10;

        //this.width = w0;
        //this.height = h0;

        let bg = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x00FFFF, .25);
        bg.beginFill(0x043c6b, .85);
        bg.drawRect(0, 0, w0, h0);
        bg.endFill();

        let g = d['g'];
        this.an_ = g['a'];
        let r30 = g['r30'];

        let sp = new PIXI.Sprite(T64.CY);
        sp.width = sp.height = 25;
        sp.anchor.y = .5;
        sp.x = gap;
        sp.y = 25;
        sp.tint = (r30 === 5 ? 0xffffff : (r30 === 8 ? 0x00bfff : (r30 === 10 ? 0xff6a6a : 0x00cd66)));
        this.addChild(sp);

        if (this.pw_) {
          sp = new PIXI.Sprite(T64.LK);
          this.addChild(sp);
          sp.anchor.set(.5);
          sp.scale.set(.7);
          sp.x = gap + 40;
          sp.y = 25;
        }

        let t = new PIXI.Text(g['t'], {
          fontFamily: FF,
          fontSize: 26,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.y = .5;
        t.x = gap + 55;
        t.y = 25;
        this.addChild(t);
        scl_txt(t, w0 - 120 - gap * 3 - 55);

        this.pr_ = t = new PIXI.Text('', {
          fontFamily: FF,
          fontSize: 18,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        t.anchor.x = 1;
        t.anchor.y = .5;
        t.x = w0 - gap;
        t.y = 25;
        this.addChild(t);

        let rd = d['n'];
        if (rd) {
          t.text = `${rd}/${g['n']}`;
        }

        let b = new TxtBtn(tz.ls('Ready'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, 120, 40, ()=>{
          //console.log(`{"m":1,"r":6,"v":${this.rb_.value_}}`);
          tz.ws.send(`{"m":1,"r":6,"v":${this.rb_.value_}}`);
        });
        b.x = w0 - gap - 120;
        b.y = 5;
        this.addChild(b);
        b.value_ = 1;
        this.rb_ = b;

        let c = (function(fs, g) {
          let c = new PIXI.Container();
          let t, w = 0, gp = fs * .4;

          t = new PIXI.Text(`${tz.ls('XRounds', g['n'])} | ${tz.ls('XFans', g['l'])} (${g['b']})`, {
            fontFamily: FF,
            fontSize: fs,
            fill: '#ffd700',
            padding: 10
          });
          t.x = w;
          c.addChild(t);
          w += t.width + gp;

          t = new PIXI.Text(tz.ls('XSecond', `${g['r30']}/${g['r12']}`), {
            fontFamily: FF,
            fontSize: fs,
            fill: '#ff6a6a',
            padding: 10
          });
          t.x = w;
          c.addChild(t);
          w += t.width + gp;

          t = new PIXI.Text(`${tz.ls('Sabotage')}${g['s']?'\u2713':'\u2715'} | ${tz.ls('HandTiles')}${g['o']?'\u2713':'\u2715'}`, {
            fontFamily: FF,
            fontSize: fs,
            fill: '#00bfff',
            padding: 10
          });
          t.x = w;
          c.addChild(t);
          w += t.width + gp;

          t = new PIXI.Text(`${tz.ls('FalseHu')} ${tz.ls('Calls')}${g['fc']?'\u2713':'\u2715'}  ${g['fa']?'-30/+10':'-40/+0'} `, {
            fontFamily: FF,
            fontSize: fs,
            fill: '#cdcdcd',
            padding: 10
          });
          t.x = w;
          c.addChild(t);
          w += t.width;

          //c.height = t.height;
          //c.width = w;

          return c;
        })(18, g);

        c.x = gap;
        c.y = 70;
        c.pivot.y = c.height * .5;
        this.addChild(c);
        let xx = c.width;
        if (xx + gap * 2 > w0) {
          c.scale.set((w0 - 25 - gap * 2) / xx);
        }

        let na = new Array(4);
        let tk = new Array(4);

        let gapX = (w0 - gap * 2) * .25;
        let p = d['p'];  // 玩家
        let ready = d['r'];  // 准备
        let rm = g['r'];  // 随机
        for (let i = 0; i < 4; ++i) {
          let xx = gap + gapX * i;
          b = new EptBtn(gapX, 35, function(cb, i) { cb(this.id_, i, this.pw_); }.bind(this, cb, i));
          b.x = xx;
          b.y = 82;
          this.addChild(b);

          t = new PIXI.Text(rm ? (i + 1) : tz.ls(WIND[i]), {
            fontFamily: FF,
            fontSize: 22,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
          });
          t.anchor.y = .5;
          t.x = xx;
          t.y = 100;
          this.addChild(t);

          let sp = tk[i] = new PIXI.Sprite(T64.TK);
          sp.anchor.set(.5);
          sp.x = xx + 37;
          sp.y = 100;
          this.addChild(sp);
          sp.visible = (ready & (1 << i));

          t = na[i] = new PIXI.Text((!this.an_ || p[i].length === 0) ? p[i] : tz.ls('Anonymous'), {
            fontFamily: FF,
            fontSize: 20,
            fill: '#ffffff',
            //stroke: '#0066ff',
            //strokeThickness: 2,
            //lineJoin: 'round',
            padding: 10
          });
          t.anchor.y = .5;
          t.x = xx + 50;
          t.y = 100;
          this.addChild(t);
          t.w_ = gapX - 50;
          scl_txt(t, t.w_);
        }

        this.na_ = na;
        this.tk_ = tk;
      }

      /**
       * 刷新
       * @param {number} id 桌ID
       * @param {number} s 座位
       */
      rfsh(id, s) {
        let b = this.rb_;
        if (id === this.id_) {
          if (this.se_ !== s) {
            if (!this.tk_[s].visible) {
              b.fa_.text = tz.ls('Ready');
              b.value_ = 1;
            }
            else {
              b.fa_.text = tz.ls('CancelReady');
              b.value_ = 0;
            }
          }

          b.visible = true;
          this.se_ = s;

          //console.log('seat', seat);
          this.na_.forEach((n, i)=>(n.style.fill = (s !== i) ? '#ffffff' : '#5cdbd3'));
        }
        else {
          b.visible = false;
          delete this.se_;

          this.na_.forEach(n=>n.style.fill = '#ffffff');
        }
      }

      /**
       * 坐下
       * @param {number} s 座位
       * @param {string} n 用户名
       */
      sit(s, n) {
        let t = this.na_[s];
        t.text = !this.an_ ? n : tz.ls('Anonymous');
        scl_txt(t, t.w_);
      }

      /**
       * 站起
       * @param {number} s 座位
       */
      stand(s) {
        this.na_[s].text = '';
        this.tk_[s].visible = false;
      }

      /**
       * 准备
       * @param {number} s 座位
       * @param {boolean} r 准备状态
       * @param {number} id 桌ID
       */
      ready(s, r, id) {
        this.tk_[s].visible = r;
        if (id === this.id_ && s === this.se_) {
          let b = this.rb_;
          if (r) {
            b.fa_.text = tz.ls('CancelReady');
            b.value_ = 0;
          }
          else {
            b.fa_.text = tz.ls('Ready');
            b.value_ = 1;
          }
        }
      }

      /**
       * 进度
       * @param {number} p 当前盘
       * @param {number} r 总盘数
       */
      prog(p, r) {
        this.pr_.text = `${p}/${r}`;
      }
    }

    /**
     * 登录界面
     * @typedef {object} Login
     */
    class Login extends PIXI.Container {
      /**
       * @param {string} z 验证码
       * @param {function():void} cb 回调
       */
      constructor(z, cb) {
        super();

        const gap = 30, w0 = 450, h0 = z ? 420 : 320;

        //this.width = LBW;
        //this.height = LBH;

        let c = new PIXI.Sprite(PIXI.Texture.WHITE);
        c.tint = 0;
        c.alpha = .5;
        c.width = LBW;
        c.height = LBH;
        this.addChild(c);
        c.interactive = true;

        let bg = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x26608c, 1);
        bg.beginFill(0x0c1e2c, .85);
        bg.drawRect(0, 0, w0, h0);
        bg.endFill();

        bg.x = (LBW - w0) * .5;
        bg.y = (LBH - h0) * .5;

        let t = new PIXI.Text(tz.ls('Login'), {
          fontFamily: FF,
          fontSize: 28,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = w0 * .5;
        t.y = 40;

        const pf = ['Nickname', 'Password'];
        let tis = [null, null, null];
        let plh = [tz.cfg['username']];
        for (let i = 0; i < 2; ++i) {
          let yy = 90 + 80 * i;
          t = new PIXI.Text(tz.ls(pf[i]), {
            fontFamily: FF,
            fontSize: 18,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.y = .5;
          t.x = gap + 10;
          t.y = yy;

          let ti = tis[i] = new PIXI.TextInput({
            fontSize: '18px',
            width: '355px',
            height: '20px',
            padding: '6px',
            paddingLeft: '10px',
          });
          ti.x = gap + 10;
          ti.y = yy + 20;
          bg.addChild(ti);
          ti.text = plh[i] || '';
          ti.substituteText = false;
          ti.destroyBoxCache = ()=>{};
        }
        tis[1]._dom_input.setAttribute('type', 'password');
        if (z) {
          t = new PIXI.Text(tz.ls('VerifyQues', z), {
            fontFamily: FF,
            fontSize: 18,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            align: 'center',
            padding: 10
          });
          bg.addChild(t);
          t.anchor.x = .5;
          t.x = w0 * .5;
          t.y = 230;

          let ti = tis[2] = new PIXI.TextInput({
            fontSize: '18px',
            width: '355px',
            height: '20px',
            padding: '6px',
            paddingLeft: '10px',
          });
          ti.x = gap + 10;
          ti.y = 235 + t.height;
          bg.addChild(ti);
          ti.substituteText = false;
          ti.destroyBoxCache = ()=>{};
        }

        const w1 = 100, h1 = 40;
        let b = new TxtBtn(tz.ls('Cancel'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>{ cb(); });
        bg.addChild(b);
        b.x = gap;
        b.y = h0 - h1 - 20;

        let cfm = ()=>cb(tis[0].text.trim(), tis[1].text, z ? tis[2].text : '');

        b = new TxtBtn(tz.ls('Confirm'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, cfm);
        bg.addChild(b);
        b.x = w0 - w1 - gap;
        b.y = h0 - h1 - 20;

        this.on('removed', ()=>document.onkeyup = null);
        this.on('added', ()=> {
          document.onkeyup = (e)=>{
            if (e.keyCode === 13) {
              cfm();
            }
          };
        });
      }
    }


    /**
     * 创建桌子界面
     * @typedef {object} NewTbl
     */
    class NewTbl extends PIXI.Container {
      /**
       * @param {function(object):void} cb 回调
       */
      constructor(cb) {
        super();

        const gap = 30, offsetY = 80;

        //this.width = LBW;
        //this.height = LBH;
        this.interactive = true;

        let bg = new PIXI.Graphics();
        this.addChild(bg);

        bg.beginFill(0, .5);
        bg.drawRect(0, 0, LBW, LBH);
        bg.endFill();

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x0C1E2C, .85);
        bg.drawRect(5, 5, LBW - 10, LBH - 10);
        bg.endFill();

        let t = new PIXI.Text(tz.ls('NewTable'), {
          fontFamily: FF,
          fontSize: 28,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        this.addChild(t);
        t.anchor.set(.5);
        t.x = LBW * .5;
        t.y = 35;

        let cs = [];
        [
          {t:tz.ls('GameTitle')},
          {t:tz.ls('GameCategory'), o:[tz.ls('FullGame'), tz.ls('HalfGame'), tz.ls('EastGame')], s:95},
          {t:tz.ls('LimitedFan'), o:[tz.ls('FanPoint', 1), tz.ls('FanPoint', 8), tz.ls('FanPoint', 16), tz.ls('FanPoint', 24), tz.ls('FanPoint', 32)], s:95},
          {t:tz.ls('BaseScores'), o:['0', '8'], s:95},
          {t:tz.ls('PrimaryTime'), o:[tz.ls('XSecond', 5), tz.ls('XSecond', 8), tz.ls('XSecond', 10), tz.ls('XSecond', 15)], s:95},
          {t:tz.ls('SecondaryTime'), o:[tz.ls('XSecond', 3), tz.ls('XSecond', 5), tz.ls('XSecond', 8), tz.ls('XSecond', 10)], s:95},
          {t:tz.ls('Sabotage'), o:[tz.ls('Yes1'), tz.ls('No1')], s:95},
          {t:tz.ls('ShowRoundOver'), o:[tz.ls('Yes'), tz.ls('No')], s:95},
          {t:tz.ls('FalseHuPunishment'), o:['-30/+10', '-40/+0'], s:125},
          {t:tz.ls('FalseHuCallsAllowed'), o:[tz.ls('Yes'), tz.ls('No')], s:95},
          {t:tz.ls('InitialScores'), o:['0', '500'], s:95},
          {t:tz.ls('RandomSeat'), o:[tz.ls('Yes'), tz.ls('No')], s:95},
          {t:tz.ls('HideNickname'), o:[tz.ls('Yes'), tz.ls('No')], s:95},
          {t:tz.ls('GuestAllowed'), o:[tz.ls('Yes'), tz.ls('No')], s:95},
          {t:tz.ls('TablePassword')}
        ].forEach((e, i)=>{
          let yy = offsetY + 35 * i;
          t = new PIXI.Text(e['t'], {
            fontFamily: FF,
            fontSize: 18,
            fill: '#ffffff',
            stroke: '#0066ff',
            strokeThickness: 2,
            lineJoin: 'round',
            padding: 10
          });
          t.anchor.y = .5;
          t.x = gap;
          t.y = yy;
          this.addChild(t);

          let xx = Math.max(gap * 2 + t.width, 150);

          let o = e['o'];
          if (typeof o !== 'undefined') {
            let g = new RdoGrp();
            for (let k = 0, l = o.length; k < l; ++k) {
              let cb = new ChkBox(o[k], function(g, k) { g.idx = k; }.bind(this, g, k));
              this.addChild(cb);
              cb.scale.set(.66);
              cb.x = xx + e['s'] * k;
              cb.y = yy - cb.height * .5 + 3;
              g.add(cb);
            }
            cs.push(g);
          }
          else {
            let ti = new PIXI.TextInput({
              fontSize: '18px',
              width: (LBW - xx - gap * 2) + 'px',
              height: '18px',
              padding: '6px',
            });
            ti.x = xx;
            ti.y = yy - 15;
            ti.substituteText = false;
            ti.destroyBoxCache = ()=>{};
            this.addChild(ti);
            cs.push(ti);
          }
        });
        cs[14]._dom_input.setAttribute('type', 'password');
        this.cs_ = cs;

        let dg = tz.cfg['default'] || {};

        function dv(v, d) {
          if (typeof v !== 'undefined') return v;
          return d;
        }

        cs[0].text = dv(dg['t'], '');
        cs[1].idx = dv(dg['n'], 0);
        cs[2].idx = dv(dg['l'], 1);
        cs[3].idx = dv(dg['b'], 1);
        cs[4].idx = dv(dg['r30'], 2);
        cs[5].idx = dv(dg['r12'], 1);
        cs[6].idx = dv(dg['s'], 0);
        cs[7].idx = dv(dg['o'], 0);
        cs[8].idx = dv(dg['fa'], 0);
        cs[9].idx = dv(dg['fc'], 1);
        cs[10].idx = dv(dg['i'], 0);
        cs[11].idx = dv(dg['r'], 0);
        cs[12].idx = dv(dg['a'], 1);
        cs[13].idx = dv(dg['g'], 1);
        cs[14].text = dv(dg['p'], '');

        const w1 = 100, h1 = 40;
        let b = new TxtBtn(tz.ls('Cancel'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>{ cb(); });
        this.addChild(b);
        b.x = gap;
        b.y = LBH - h1 - 20;

        b = new TxtBtn(tz.ls('Confirm'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>{ cb(this._g()); });
        this.addChild(b);
        b.x = LBW - w1 - gap;
        b.y = LBH - h1 - 20;

        // 回车键
        this.on('removed', ()=>document.onkeyup = null);
        this.on('added', ()=> {
          document.onkeyup = (e)=>{
            if (e.keyCode === 13) {
              cb(this._g());
            }
          };
        });
      }

      /**
       * 获取设置
       */
      _g() {
        let cs = this.cs_;
        function rv(g, dv) {
          let i = g.idx;
          return (i !== -1 ? i : dv);
        }

        let g = {
          't':cs[0].text.trim(),
          'n':rv(cs[1], 0),
          'l':rv(cs[2], 1),
          'b':rv(cs[3], 1),
          'r30':rv(cs[4], 2),
          'r12':rv(cs[5], 1),
          's':rv(cs[6], 0),
          'o':rv(cs[7], 1),
          'fa':rv(cs[8], 0),
          'fc':rv(cs[9], 1),
          'i':rv(cs[10], 0),
          'r':rv(cs[11], 0),
          'a':rv(cs[12], 1),
          'g':rv(cs[13], 1),
          'p':cs[14].text
        };
        tz.cfg['default'] = g;
        tz.save();
        return g;
      }
    }

    /**
     * 密码输入界面
     * @typedef {object} PswIpt
     */
    class PswIpt extends PIXI.Container {
      /**
       * @param {function(string):void} cb 关闭回调
       */
      constructor(cb) {
        super();

        const gap = 30, w0 = 360, h0 = 240;

        //this.width = LBW;
        //this.height = LBH;
        let c = new PIXI.Sprite(PIXI.Texture.WHITE);
        c.tint = 0;
        c.alpha = .5;
        c.width = LBW;
        c.height = LBH;
        this.addChild(c);
        c.interactive = true;

        let bg = new PIXI.Graphics();
        this.addChild(bg);

        bg.lineStyle(2, 0x26608C, 1);
        bg.beginFill(0x0C1E2C, .85);
        bg.drawRect(0, 0, w0, h0);
        bg.endFill();

        bg.x = (LBW - w0) * .5;
        bg.y = (LBH - h0) * .5;

        let t = new PIXI.Text(tz.ls('InputPassword'), {
          fontFamily: FF,
          fontSize: 28,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        });
        bg.addChild(t);
        t.anchor.set(.5);
        t.x = w0 * .5;
        t.y = 40;

        let ti = new PIXI.TextInput({
          fontSize: '18px',
          width: '200px',
          height: '20px',
          padding: '6px',
          paddingLeft: '10px',
        });
        ti.x = 75;
        ti.y = 90;
        ti.substituteText = false;
        ti.destroyBoxCache = ()=>{};
        ti._dom_input.setAttribute('type', 'password');
        bg.addChild(ti);

        const w1 = 100, h1 = 40;
        let b = new TxtBtn(tz.ls('Cancel'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>{ cb(); });
        bg.addChild(b);
        b.x = gap;
        b.y = h0 - h1 - 20;

        b = new TxtBtn(tz.ls('Confirm'), {
          fontFamily: FF,
          fontSize: 20,
          fill: '#ffffff',
          stroke: '#0066ff',
          strokeThickness: 2,
          lineJoin: 'round',
          padding: 10
        }, w1, h1, ()=>{ cb(ti.text); });
        bg.addChild(b);
        b.x = w0 - w1 - gap;
        b.y = h0 - h1 - 20;

        // 回车键
        this.on('removed', ()=>document.onkeyup = null);
        this.on('added', ()=> {
          document.onkeyup = (e)=>{
            if (e.keyCode === 13) {
              cb(ti.text);
            }
          };
        });
      }
    }

    (function(){
      let app = tz.app = new PIXI.Application({
        width: window.innerWidth,
        height: window.innerHeight,
        view: document.querySelector('canvas')
      });

      //PIXI.SCALE_MODES.DEFAULT=PIXI.SCALE_MODES.NEAREST;

      app.renderer.view.style.display = 'block';
      window.onresize = ()=>{
        app.renderer.resize(window.innerWidth, window.innerHeight);
      };

      //function animate(time){
      //  window.requestAnimationFrame(animate);
      //  app.renderer.render(app.stage);
      //  TWEEN.update();
      //}
      //animate(performance.now());

      setInterval(()=>{
        app.renderer.render(app.stage);
        try {
          TWEEN.update();
        } catch (e) {
          console.log(e);
        }
      }, 33.333);

      (function(){
        // 屏蔽系统的右键
        document.oncontextmenu = ()=>false;

        tz.load();
        let s = tz.cfg['superscript'] || 0;
        let l = tz.cfg['lang'] || 0;
        if (l === 0) {
          l = (function(){
            let l = (new URL(location.href)).searchParams.get('lang');
            l = l ? l.toLowerCase() : (navigator.language || navigator.browserLanguage).toLowerCase();
            console.log('lang', l);
            switch (l) {
              default: return 1;
              case 'zh-tw':
              case 'zh-hk':
              case 'zh-mo':
              case 'zh-cht': return 2;
              case 'en':
              case 'en-au':
              case 'en-ca':
              case 'en-nz':
              case 'en-ph':
              case 'en-gb':
              case 'en-us': return 3;
            }
          })();
        }

        // 中文用户默认不显示上角标，其他语言默认显示
        // 即中文用户强制显示才显示，非中文用户强制不显示才不显示
        tz.tlscp = (l !== 3) ? (s === 2) : (s !== 1);

        switch (l) {
        default:
          tz.ltrl = {
            "HTMLTitle" : "雀渣——国标麻将",
            "BrowerNotSupport" : "你的浏览器不支持此游戏",
            "NotSynchronized" : "数据与服务器不同步，请刷新重试",
            "NetworkError" : "网络错误，请刷新重试",
            "NoGambling" : "文明游戏 禁止赌博",
            "GameSetting" : "游戏设置",
            "Speed" : "测速",
            "CallOpt" : "鸣牌设置",
            "History" : "计分表",
            "Chase" : "追分策略",
            "TimeoutHint" : "你已超时，服务器自动托管，刷新页面可解除",
            "HandTiles" : "手牌",
            "Calls" : "鸣牌",
            "Remains" : "牌墙剩余",
            "Sabotage" : "战术鸣牌",
            "Chow" : "吃",
            "Pung" : "碰",
            "Kong" : "杠",
            "Hu" : "和",
            "Flower" : "花",
            "Pass" : "过",
            "Waive" : "弃",
            "Shoot" : "点炮",
            "FalseHu" : "错和",
            "East" : "东",
            "South" : "南",
            "West" : "西",
            "North" : "北",
            "RoundEast" : "东风圈",
            "RoundSouth" : "南风圈",
            "RoundWest" : "西风圈",
            "RoundNorth" : "北风圈",
            "Order0" : "东风东",
            "Order1" : "东风南",
            "Order2" : "东风西",
            "Order3" : "东风北",
            "Order4" : "南风东",
            "Order5" : "南风南",
            "Order6" : "南风西",
            "Order7" : "南风北",
            "Order8" : "西风东",
            "Order9" : "西风南",
            "Order10" : "西风西",
            "Order11" : "西风北",
            "Order12" : "北风东",
            "Order13" : "北风南",
            "Order14" : "北风西",
            "Order15" : "北风北",
            "FanName0" : "无",
            "FanName1" : "大四喜",
            "FanName2" : "大三元",
            "FanName3" : "绿一色",
            "FanName4" : "九莲宝灯",
            "FanName5" : "四杠",
            "FanName6" : "连七对",
            "FanName7" : "十三幺",
            "FanName8" : "清幺九",
            "FanName9" : "小四喜",
            "FanName10" : "小三元",
            "FanName11" : "字一色",
            "FanName12" : "四暗刻",
            "FanName13" : "一色双龙会",
            "FanName14" : "一色四同顺",
            "FanName15" : "一色四节高",
            "FanName16" : "一色四步高",
            "FanName17" : "三杠",
            "FanName18" : "混幺九",
            "FanName19" : "七对",
            "FanName20" : "七星不靠",
            "FanName21" : "全双刻",
            "FanName22" : "清一色",
            "FanName23" : "一色三同顺",
            "FanName24" : "一色三节高",
            "FanName25" : "全大",
            "FanName26" : "全中",
            "FanName27" : "全小",
            "FanName28" : "清龙",
            "FanName29" : "三色双龙会",
            "FanName30" : "一色三步高",
            "FanName31" : "全带五",
            "FanName32" : "三同刻",
            "FanName33" : "三暗刻",
            "FanName34" : "全不靠",
            "FanName35" : "组合龙",
            "FanName36" : "大于五",
            "FanName37" : "小于五",
            "FanName38" : "三风刻",
            "FanName39" : "花龙",
            "FanName40" : "推不倒",
            "FanName41" : "三色三同顺",
            "FanName42" : "三色三节高",
            "FanName43" : "无番和",
            "FanName44" : "妙手回春",
            "FanName45" : "海底捞月",
            "FanName46" : "杠上开花",
            "FanName47" : "抢杠和",
            "FanName48" : "碰碰和",
            "FanName49" : "混一色",
            "FanName50" : "三色三步高",
            "FanName51" : "五门齐",
            "FanName52" : "全求人",
            "FanName53" : "双暗杠",
            "FanName54" : "双箭刻",
            "FanName55" : "全带幺",
            "FanName56" : "不求人",
            "FanName57" : "双明杠",
            "FanName58" : "和绝张",
            "FanName59" : "箭刻",
            "FanName60" : "圈风刻",
            "FanName61" : "门风刻",
            "FanName62" : "门前清",
            "FanName63" : "平和",
            "FanName64" : "四归一",
            "FanName65" : "双同刻",
            "FanName66" : "双暗刻",
            "FanName67" : "暗杠",
            "FanName68" : "断幺",
            "FanName69" : "一般高",
            "FanName70" : "喜相逢",
            "FanName71" : "连六",
            "FanName72" : "老少副",
            "FanName73" : "幺九刻",
            "FanName74" : "明杠",
            "FanName75" : "缺一门",
            "FanName76" : "无字",
            "FanName77" : "边张",
            "FanName78" : "嵌张",
            "FanName79" : "单钓将",
            "FanName80" : "自摸",
            "FanName81" : "花牌",
            "FanName82" : "明暗杠",
            "AutoFlower" : "自动补花",
            "NoChow" : "不 吃",
            "NoPung" : "不 碰",
            "NoKong" : "不 杠",
            "SelfDrawnOnly" : "只和自摸",
            "AutoHu" : "自动和牌",
            "AutoDiscard" : "自动摸打",
            "LoseConnect" : "掉线",
            "FanPoint" : "{1}番",
            "Tie" : "荒庄",
            "ShootBrief" : "「{1}」和牌 「{2}」点炮  {3}番",
            "SelfDrawnBrief" : "「{1}」自摸  {2}番",
            "CT" : "本盘",
            "ST" : "累计",
            "FalseWinTitle" : "{1}番错和",
            "FalseWinHint" : "你已错和，本盘失去和牌权",
            "TotalFans" : "合计: {1} 番",
            "GameResult" : "对战结果",
            "Rank" : "名次",
            "Nickname" : "昵称",
            "Scores" : "分数",
            "ScoreTable" : "计分表",
            "Order" : "盘序",
            "GT" : "累计",
            "ChaseStrategy" : "追分策略",
            "Chaser" : "追者",
            "Chasee" : "被追",
            "Diff" : "分差",
            "S-D" : "自摸",
            "D-S" : "对点",
            "O-S" : "旁点",
            "ChaseHint" : "自摸：(分差-32) / 4\n对点：(分差-32) / 2\n旁点：(分差-32)",
            "CallOptions" : "鸣牌设置",
            "NoPrompt" : "不询问以下选中的牌：",
            "AllCharacters" : "所有万子",
            "AllBamboos" : "所有条子",
            "AllDots" : "所有饼子",
            "AllHonors" : "所有字牌",
            "NoPromptEvenSD" : "自摸也不询问",
            "RClickWaive" : "鼠标右键=弃",
            "CalOptNote" : "注意：此处的设置优先生效。每盘开始前会重置。",
            "Cancel" : "取消",
            "Confirm" : "确定",
            "Volume" : "音量",
            "VolumeTest" : "试听",
            "CountdownEffects" : "倒计时音效",
            "CallHintEffects" : "鸣牌提示音效",
            "RClickDiscard" : "鼠标右键摸切",
            "NeedRefreshHint" : "以下设置需要刷新生效",
            "Language" : "语言",
            "Default": "默认",
            "DefaultLangHint" : "默认语言取决于你的浏览器和操作系统",
            "TileStyle" : "牌面样式",
            "DefaultTileStyleHint" : "非中文用户默认显示上角标",
            "ShowWall" : "牌墙显示",
            "DefaultWallHint" : "PC和平板上默认显示牌墙，手机上默认不显示牌墙",
            "PianoSize" : "钢琴键尺寸",
            "3Tabs" : "三格",
            "2Tabs" : "两格",
            "AutoPianoHint" : "默认根据手机的屏幕剩余空间调整",
            "Home" : "主页",
            "Setting" : "设置",
            "Free" : "空闲:",
            "Waiting" : "等待:",
            "Playing" : "对局:",
            "Offline" : "托管:",
            "NewTable" : "创建牌桌",
            "Prev" : "上一页",
            "Next" : "下一页",
            "ErrorUnknown" : "未知错误",
            "ErrorUnknownX" : "未知错误 {1}",
            "ErrorInTable" : "你已经在牌桌上",
            "ErrorInGame" : "你已经在对局中",
            "ErrorTableNotExist" : "牌桌不存在",
            "ErrorWrongSeat" : "不正确的位置",
            "ErrorSeatOccupied" : "这个位置已经有人了",
            "ErrorPassword" : "密码错误",
            "ErrorNotInTable" : "你不在牌桌上",
            "ErrorLoginElsewhere" : "你已在别处登录",
            "ErrorTooLong" : "用户名或密码过长",
            "ErrorGuestEntry" : "该牌桌不允许游客账号加入",
            "ErrorSpecialChars" : "不允许使用特殊字符",
            "ErrorTimeSetting" : "次要时限不能超过首要时限",
            "ErrorNotMatch" : "账号和密码不匹配",
            "ErrorVerifyExpired" : "验证码已过期",
            "ErrorVerifyAns" : "验证码错误",
            "ErrorNotSupport" : "不支持的牌桌配置",
            "ErrorIP" : "IP限制",
            "ErrorNotActivated" : "账号未激活",
            "ErrorAutoLogin" : "自动登录失败，请手动登录",
            "ErrorEmptyTitle" : "对局名称不能为空",
            "ErrorTitleLength" : "对局名称最多40个字符",
            "ErrorPasswordChar" : "密码只允许数字和字母",
            "ErrorPasswordLength" : "密码最长6位",
            "Yes" : "是",
            "No" : "否",
            "Yes1" : "有",
            "No1" : "无",
            "GameTitle" : "对局名称",
            "GameCategory" : "类型",
            "FullGame" : "全庄",
            "HalfGame" : "半庄",
            "EastGame" : "东风",
            "LimitedFan" : "起和番",
            "BaseScores" : "底分",
            "PrimaryTime" : "首要时限",
            "SecondaryTime" : "次要时限",
            "ShowRoundOver" : "盘末显示手牌",
            "FalseHuPunishment" : "错和处罚策略",
            "FalseHuCallsAllowed" : "错和后允许鸣牌",
            "InitialScores" : "对局初始分",
            "RandomSeat" : "随机分配初始座位",
            "HideNickname" : "对外隐藏玩家昵称",
            "GuestAllowed" : "允许游客加入",
            "TablePassword" : "密码（可选）",
            "XSecond" : "{1}秒",
            "XRounds" : "{1}盘",
            "XFans" : "{1}番",
            "Ready" : "准备",
            "CancelReady" : "取消准备",
            "Anonymous" : "匿名用户",
            "InputPassword" : "请输入密码",
            "Login" : "登录",
            "Password" : "密码",
            "VerifyQues" : "验证问题：清一色{1}，\n听牌为（包括已经出现4枚的）"
          };
          break;
        case 2:
          tz.ltrl = {
            "HTMLTitle" : "雀渣——國標麻雀",
            "BrowerNotSupport" : "你的瀏覽器不支持此遊戲",
            "NotSynchronized" : "數據與伺服器不同步，請重繪重試",
            "NetworkError" : "網絡錯誤，請重繪重試",
            "NoGambling" : "文明遊戲 禁止賭博",
            "GameSetting" : "遊戲設定",
            "Speed" : "測速",
            "CallOpt" : "鳴牌設定",
            "History" : "計分表",
            "Chase" : "追分策略",
            "TimeoutHint" : "你已超時，伺服器自動託管，重繪頁面可解除",
            "HandTiles" : "手牌",
            "Calls" : "鳴牌",
            "Remains" : "牌墻剩餘",
            "Sabotage" : "戰術鳴牌",
            "Chow" : "吃",
            "Pung" : "碰",
            "Kong" : "槓",
            "Hu" : "和",
            "Flower" : "花",
            "Pass" : "過",
            "Waive" : "棄",
            "Shoot" : "放銃",
            "FalseHu" : "錯和",
            "East" : "東",
            "South" : "南",
            "West" : "西",
            "North" : "北",
            "RoundEast" : "東風圈",
            "RoundSouth" : "南風圈",
            "RoundWest" : "西風圈",
            "RoundNorth" : "北風圈",
            "Order0" : "東風東",
            "Order1" : "東風南",
            "Order2" : "東風西",
            "Order3" : "東風北",
            "Order4" : "南風東",
            "Order5" : "南風南",
            "Order6" : "南風西",
            "Order7" : "南風北",
            "Order8" : "西風東",
            "Order9" : "西風南",
            "Order10" : "西風西",
            "Order11" : "西風北",
            "Order12" : "北風東",
            "Order13" : "北風南",
            "Order14" : "北風西",
            "Order15" : "北風北",
            "FanName0" : "無",
            "FanName1" : "大四喜",
            "FanName2" : "大三元",
            "FanName3" : "綠一色",
            "FanName4" : "九蓮寶燈",
            "FanName5" : "四槓",
            "FanName6" : "連七對",
            "FanName7" : "十三幺",
            "FanName8" : "清幺九",
            "FanName9" : "小四喜",
            "FanName10" : "小三元",
            "FanName11" : "字一色",
            "FanName12" : "四暗刻",
            "FanName13" : "一色雙龍會",
            "FanName14" : "一色四同順",
            "FanName15" : "一色四節高",
            "FanName16" : "一色四步高",
            "FanName17" : "三槓",
            "FanName18" : "混幺九",
            "FanName19" : "七對",
            "FanName20" : "七星不靠",
            "FanName21" : "全雙刻",
            "FanName22" : "清一色",
            "FanName23" : "一色三同順",
            "FanName24" : "一色三節高",
            "FanName25" : "全大",
            "FanName26" : "全中",
            "FanName27" : "全小",
            "FanName28" : "清龍",
            "FanName29" : "三色雙龍會",
            "FanName30" : "一色三步高",
            "FanName31" : "全帶五",
            "FanName32" : "三同刻",
            "FanName33" : "三暗刻",
            "FanName34" : "全不靠",
            "FanName35" : "組合龍",
            "FanName36" : "大於五",
            "FanName37" : "小於五",
            "FanName38" : "三風刻",
            "FanName39" : "花龍",
            "FanName40" : "推不倒",
            "FanName41" : "三色三同順",
            "FanName42" : "三色三節高",
            "FanName43" : "無番和",
            "FanName44" : "妙手回春",
            "FanName45" : "海底撈月",
            "FanName46" : "槓上開花",
            "FanName47" : "搶槓和",
            "FanName48" : "碰碰和",
            "FanName49" : "混一色",
            "FanName50" : "三色三步高",
            "FanName51" : "五門齊",
            "FanName52" : "全求人",
            "FanName53" : "雙暗槓",
            "FanName54" : "雙箭刻",
            "FanName55" : "全帶幺",
            "FanName56" : "不求人",
            "FanName57" : "雙明槓",
            "FanName58" : "和絕張",
            "FanName59" : "箭刻",
            "FanName60" : "圈風刻",
            "FanName61" : "門風刻",
            "FanName62" : "門前清",
            "FanName63" : "平和",
            "FanName64" : "四歸一",
            "FanName65" : "雙同刻",
            "FanName66" : "雙暗刻",
            "FanName67" : "暗槓",
            "FanName68" : "斷幺",
            "FanName69" : "一般高",
            "FanName70" : "喜相逢",
            "FanName71" : "連六",
            "FanName72" : "老少副",
            "FanName73" : "幺九刻",
            "FanName74" : "明槓",
            "FanName75" : "缺一門",
            "FanName76" : "無字",
            "FanName77" : "邊張",
            "FanName78" : "嵌張",
            "FanName79" : "單釣將",
            "FanName80" : "自摸",
            "FanName81" : "花牌",
            "FanName82" : "明暗槓",
            "AutoFlower" : "自動補花",
            "NoChow" : "不 吃",
            "NoPung" : "不 碰",
            "NoKong" : "不 槓",
            "SelfDrawnOnly" : "只和自摸",
            "AutoHu" : "自動和牌",
            "AutoDiscard" : "自動摸打",
            "LoseConnect" : "掉線",
            "FanPoint" : "{1}番",
            "Tie" : "流局",
            "ShootBrief" : "「{1}」和牌 「{2}」放銃  {3}番",
            "SelfDrawnBrief" : "「{1}」自摸  {2}番",
            "CT" : "本盤",
            "ST" : "累計",
            "FalseWinTitle" : "{1}番錯和",
            "FalseWinHint" : "你已錯和，本盤失去和牌權",
            "TotalFans" : "合計: {1} 番",
            "GameResult" : "對戰結果",
            "Rank" : "名次",
            "Nickname" : "昵稱",
            "Scores" : "分數",
            "ScoreTable" : "計分表",
            "Order" : "盤序",
            "GT" : "合計",
            "ChaseStrategy" : "追分策略",
            "Chaser" : "追者",
            "Chasee" : "被追",
            "Diff" : "分差",
            "S-D" : "自摸",
            "D-S" : "對銃",
            "O-S" : "閒銃",
            "ChaseHint" : "自摸：(分差-32) / 4\n對銃：(分差-32) / 2\n閒銃：(分差-32)",
            "CallOptions" : "鳴牌設定",
            "NoPrompt" : "不詢問以下選中的牌：",
            "AllCharacters" : "所有萬子",
            "AllBamboos" : "所有索子",
            "AllDots" : "所有筒子",
            "AllHonors" : "所有字牌",
            "NoPromptEvenSD" : "自摸也不詢問",
            "RClickWaive" : "鼠標右鍵=棄",
            "CalOptNote" : "註意：此處的設定優先起效。每盤開始前會重置。",
            "Cancel" : "取消",
            "Confirm" : "確認",
            "Volume" : "音量",
            "VolumeTest" : "試聽",
            "CountdownEffects" : "倒計時音效",
            "CallHintEffects" : "鳴牌提示音效",
            "RClickDiscard" : "鼠標右鍵摸切",
            "NeedRefreshHint" : "以下設定需要重繪生效",
            "Language" : "語言",
            "Default": "默認",
            "DefaultLangHint" : "默認語言取決於你的瀏覽器和作業系統",
            "TileStyle" : "牌面樣式",
            "DefaultTileStyleHint" : "非中文用戶默認顯示上角標",
            "ShowWall" : "牌墙顯示",
            "DefaultWallHint" : "PC和平板上默認顯示牌牆，手機上默認不顯示牌牆",
            "PianoSize" : "鋼琴鍵尺寸",
            "3Tabs" : "三格",
            "2Tabs" : "兩格",
            "AutoPianoHint" : "默認根據手機的荧幕剩餘空間調整",
            "Home" : "主頁",
            "Setting" : "設定",
            "Free" : "空閑:",
            "Waiting" : "等待:",
            "Playing" : "對局:",
            "Offline" : "託管:",
            "NewTable" : "創建牌桌",
            "Prev" : "上一頁",
            "Next" : "下一頁",
            "ErrorUnknown" : "未知錯誤",
            "ErrorUnknownX" : "未知錯誤 {1}",
            "ErrorInTable" : "你已經在牌桌上",
            "ErrorInGame" : "你已經在對局中",
            "ErrorTableNotExist" : "牌桌不存在",
            "ErrorWrongSeat" : "不正確的位置",
            "ErrorSeatOccupied" : "這個位置已經有人了",
            "ErrorPassword" : "密碼錯誤",
            "ErrorNotInTable" : "你不在牌桌上",
            "ErrorLoginElsewhere" : "你已在別處登入",
            "ErrorTooLong" : "用戶名或密碼過長",
            "ErrorGuestEntry" : "該牌桌不允許遊客賬號加入",
            "ErrorSpecialChars" : "不允許使用特殊字符",
            "ErrorTimeSetting" : "次要時限不能超過首要時限",
            "ErrorNotMatch" : "賬號和密碼不匹配",
            "ErrorVerifyExpired" : "驗證碼已過期",
            "ErrorVerifyAns" : "驗證碼錯誤",
            "ErrorNotSupport" : "不支持的牌桌配寘",
            "ErrorIP" : "IP限制",
            "ErrorNotActivated" : "賬號未激活",
            "ErrorAutoLogin" : "自動登入失敗，請手動登入",
            "ErrorEmptyTitle" : "對局名稱不能為空",
            "ErrorTitleLength" : "對局名稱最多40個字符",
            "ErrorPasswordChar" : "密碼只允許數字和字母",
            "ErrorPasswordLength" : "密碼最長6位",
            "Yes" : "是",
            "No" : "否",
            "Yes1" : "有",
            "No1" : "無",
            "GameTitle" : "對局名稱",
            "GameCategory" : "類型",
            "FullGame" : "全莊",
            "HalfGame" : "半莊",
            "EastGame" : "東風",
            "LimitedFan" : "起和番",
            "BaseScores" : "底分",
            "PrimaryTime" : "首要時限",
            "SecondaryTime" : "次要時限",
            "ShowRoundOver" : "盤末顯示手牌",
            "FalseHuPunishment" : "錯和處罰策略",
            "FalseHuCallsAllowed" : "錯和後允許鳴牌",
            "InitialScores" : "對局初始分",
            "RandomSeat" : "隨機分配初始座位",
            "HideNickname" : "對外隱藏玩家昵稱",
            "GuestAllowed" : "允許遊客加入",
            "TablePassword" : "密碼（可選）",
            "XSecond" : "{1}秒",
            "XRounds" : "{1}盤",
            "XFans" : "{1}番",
            "Ready" : "準備",
            "CancelReady" : "取消準備",
            "Anonymous" : "匿名用戶",
            "InputPassword" : "請輸入密碼",
            "Login" : "登入",
            "Password" : "密碼",
            "VerifyQues" : "驗證問題：清一色{1}，\n聽牌為（包括已經出現4枚的）"
          };
          break;
        case 3:
          tz.ffs = 20;
          tz.ltrl = {
            "HTMLTitle" : "Tziakcha-Chinese Official Mahjong",
            "BrowerNotSupport" : "Your browser does not support this game",
            "NotSynchronized" : "Data not synchronized, please refresh and try again",
            "NetworkError" : "Network error, please refresh and try again",
            "NoGambling" : "Civilized Game & No Gambling",
            "GameSetting" : "Setting",
            "Speed" : "Speed",
            "CallOpt" : "Call Opt",
            "History" : "History",
            "Chase" : "Chase",
            "TimeoutHint" : "Timeout, auto discarding. Refresh to continue",
            "HandTiles" : "Hand tiles",
            "Calls" : "Calls",
            "Remains" : "Remains",
            "Sabotage" : "Sabotage",
            "Chow" : "Chow",
            "Pung" : "Pung",
            "Kong" : "Kong",
            "Hu" : "Hu",
            "Flower" : "Flower",
            "Pass" : "Pass",
            "Waive" : "Waive",
            "Shoot" : "Shoot",
            "FalseHu" : "False Hu",
            "East" : "E",
            "South" : "S",
            "West" : "W",
            "North" : "N",
            "RoundEast" : "East",
            "RoundSouth" : "South",
            "RoundWest" : "West",
            "RoundNorth" : "North",
            "Order0" : "E-E",
            "Order1" : "E-S",
            "Order2" : "E-W",
            "Order3" : "E-N",
            "Order4" : "S-E",
            "Order5" : "S-S",
            "Order6" : "S-W",
            "Order7" : "S-N",
            "Order8" : "W-E",
            "Order9" : "W-S",
            "Order10" : "W-W",
            "Order11" : "W-N",
            "Order12" : "N-E",
            "Order13" : "N-S",
            "Order14" : "N-W",
            "Order15" : "N-N",
            "FanName0" : "None",
            "FanName1" : "Big Four Winds",
            "FanName2" : "Big Three Dragons",
            "FanName3" : "All Green",
            "FanName4" : "Nine Gates",
            "FanName5" : "Four Kongs",
            "FanName6" : "Seven Shifted Pairs",
            "FanName7" : "Thirteen Orphans",
            "FanName8" : "All Terminals",
            "FanName9" : "Little Four Winds",
            "FanName10" : "Little Three Dragons",
            "FanName11" : "All Honors",
            "FanName12" : "Four Concealed Pungs",
            "FanName13" : "Pure Terminal Chows",
            "FanName14" : "Quadruple Chow",
            "FanName15" : "Four Pure Shifted Pungs",
            "FanName16" : "Four Pure Shifted Chows",
            "FanName17" : "Three Kongs",
            "FanName18" : "All Terminals and Honors",
            "FanName19" : "Seven Pairs",
            "FanName20" : "Greater Honors and Knitted Tiles",
            "FanName21" : "All Even Pungs",
            "FanName22" : "Full Flush",
            "FanName23" : "Pure Triple Chow",
            "FanName24" : "Pure Shifted Pungs",
            "FanName25" : "Upper Tiles",
            "FanName26" : "Middle Tiles",
            "FanName27" : "Lower Tiles",
            "FanName28" : "Pure Straight",
            "FanName29" : "Three-Suited Terminal Chows",
            "FanName30" : "Pure Shifted Chows",
            "FanName31" : "All Five",
            "FanName32" : "Triple Pung",
            "FanName33" : "Three Concealed Pungs",
            "FanName34" : "Lesser Honors and Knitted Tiles",
            "FanName35" : "Knitted Straight",
            "FanName36" : "Upper Four",
            "FanName37" : "Lower Four",
            "FanName38" : "Big Three Winds",
            "FanName39" : "Mixed Straight",
            "FanName40" : "Reversible Tiles",
            "FanName41" : "Mixed Triple Chow",
            "FanName42" : "Mixed Shifted Pungs",
            "FanName43" : "Chicken Hand",
            "FanName44" : "Last Tile Draw",
            "FanName45" : "Last Tile Claim",
            "FanName46" : "Out with Replacement Tile",
            "FanName47" : "Robbing The Kong",
            "FanName48" : "All Pungs",
            "FanName49" : "Half Flush",
            "FanName50" : "Mixed Shifted Chows",
            "FanName51" : "All Types",
            "FanName52" : "Melded Hand",
            "FanName53" : "Two Concealed Kongs",
            "FanName54" : "Two Dragons Pungs",
            "FanName55" : "Outside Hand",
            "FanName56" : "Fully Concealed Hand",
            "FanName57" : "Two Melded Kongs",
            "FanName58" : "Last Tile",
            "FanName59" : "Dragon Pung",
            "FanName60" : "Prevalent Wind",
            "FanName61" : "Seat Wind",
            "FanName62" : "Concealed Hand",
            "FanName63" : "All Chows",
            "FanName64" : "Tile Hog",
            "FanName65" : "Double Pung",
            "FanName66" : "Two Concealed Pungs",
            "FanName67" : "Concealed Kong",
            "FanName68" : "All Simples",
            "FanName69" : "Pure Double Chow",
            "FanName70" : "Mixed Double Chow",
            "FanName71" : "Short Straight",
            "FanName72" : "Two Terminal Chows",
            "FanName73" : "Pung of Terminals or Honors",
            "FanName74" : "Melded Kong",
            "FanName75" : "One Voided Suit",
            "FanName76" : "No Honors",
            "FanName77" : "Edge Wait",
            "FanName78" : "Closed Wait",
            "FanName79" : "Single Wait",
            "FanName80" : "Self-Drawn",
            "FanName81" : "Flower Tiles",
            "FanName82" : "Concealed Kong and Melded Kong",
            "AutoFlower" : "Auto\nFlower",
            "NoChow" : "No\nChow",
            "NoPung" : "No\nPung",
            "NoKong" : "No\nKong",
            "SelfDrawnOnly" : "Self-Drawn\nOnly",
            "AutoHu" : "Auto\nHu",
            "AutoDiscard" : "Auto\nDiscard",
            "LoseConnect" : "Offline",
            "FanPoint" : "{1}",
            "Tie" : "Tie",
            "ShootBrief" : "「{1}」Hu 「{2}」Shoot  {3} Fan(s)",
            "SelfDrawnBrief" : "「{1}」Self-Drawn  {2} Fan(s)",
            "CT" : "CT",
            "ST" : "ST",
            "FalseWinTitle" : "{1} Fan(s) False Hu",
            "FalseWinHint" : "You\'ve False Hu-ed, cannot Hu during current hand",
            "TotalFans" : "Total: {1} Fan(s)",
            "GameResult" : "Game Result",
            "Rank" : "Rank",
            "Nickname" : "Nickname",
            "Scores" : "Scores",
            "ScoreTable" : "Score Table",
            "Order" : "Order",
            "GT" : "GT",
            "ChaseStrategy" : "Chase Strategy",
            "Chaser" : "Chaser",
            "Chasee" : "Chasee",
            "Diff" : "Diff",
            "S-D" : "S-D",
            "D-S" : "D-S",
            "O-S" : "O-S",
            "ChaseHint" : "Self-Drawn: (Diff-32) / 4\nDirect Shoot: (Diff-32) / 2\nOther Shoot: (Diff-32)",
            "CallOptions" : "Call Options",
            "NoPrompt" : "No prompt calls for the selected tiles below:",
            "AllCharacters" : "All Characters",
            "AllBamboos" : "All Bamboos",
            "AllDots" : "All Dots",
            "AllHonors" : "All Honors",
            "NoPromptEvenSD" : "No prompt even Self-Drawn",
            "RClickWaive" : "Right-click for Waiving",
            "CalOptNote" : "Note：Options here have the highest priority.\nThese options will be reset before the start of each hand",
            "Cancel" : "Cancel",
            "Confirm" : "Confirm",
            "Volume" : "Volume",
            "VolumeTest" : "Test",
            "CountdownEffects" : "Countdown Effects",
            "CallHintEffects" : "Call Hint Effects",
            "RClickDiscard" : "Right-click for discarding drawing tile",
            "NeedRefreshHint" : "The following settings need to be refreshed to take effect",
            "Language" : "Language",
            "Default": "Default",
            "DefaultLangHint" : "The default language depends on your browser and operating system",
            "TileStyle" : "Tile Style",
            "DefaultTileStyleHint" : "Non Chinese users will display the superscript by default",
            "ShowWall" : "Show Wall",
            "DefaultWallHint" : "Tile walls will display on PC and tablet by default, and not on mobile phone",
            "PianoSize" : "Piano Size",
            "3Tabs" : "3 Tabs",
            "2Tabs" : "2 Tabs",
            "AutoPianoHint" : "The default display is based on the remaining screen space of the phone",
            "Home" : "Home",
            "Setting" : "Setting",
            "Free" : "Free:",
            "Waiting" : "Waiting:",
            "Playing" : "Playing:",
            "Offline" : "Offline:",
            "NewTable" : "New Table",
            "Prev" : "PREV",
            "Next" : "NEXT",
            "ErrorUnknown" : "Unknown error",
            "ErrorUnknownX" : "Unknown error {1}",
            "ErrorInTable" : "You are in table",
            "ErrorInGame" : "You are in game",
            "ErrorTableNotExist" : "Table is not exist",
            "ErrorWrongSeat" : "Wrong seat",
            "ErrorSeatOccupied" : "This seat is already occupied",
            "ErrorPassword" : "Incorrect password",
            "ErrorNotInTable" : "You are not in table",
            "ErrorLoginElsewhere" : "You have already logged in elsewhere",
            "ErrorTooLong" : "Username or password too long",
            "ErrorGuestEntry" : "No entry for guest",
            "ErrorSpecialChars" : "Special Characters not allowed",
            "ErrorTimeSetting" : "Secondary time should less than primary time",
            "ErrorNotMatch" : "Account and Password not match",
            "ErrorVerifyExpired" : "Verification Code Expired",
            "ErrorVerifyAns" : "Incorrect Verification Code",
            "ErrorNotSupport" : "Config is not supported",
            "ErrorIP" : "IP restrictions",
            "ErrorNotActivated" : "User account is not activated",
            "ErrorAutoLogin" : "Auto login failed, Please login manually",
            "ErrorEmptyTitle" : "Title should not be empty",
            "ErrorTitleLength" : "Title should be less than 40 characters",
            "ErrorPasswordChar" : "Password only allow numbers and letters",
            "ErrorPasswordLength" : "Passwords should be less than 6 characters",
            "Yes" : "Yes",
            "No" : "No",
            "Yes1" : "Yes",
            "No1" : "No",
            "GameTitle" : "New Table",
            "GameCategory" : "Category",
            "FullGame" : "16RDs",
            "HalfGame" : "8RDs",
            "EastGame" : "4RDs",
            "LimitedFan" : "Limited Fan(s)",
            "BaseScores" : "Base scores",
            "PrimaryTime" : "Primary Time",
            "SecondaryTime" : "Secondary Time",
            "ShowRoundOver" : "Show hand tiles after round over",
            "FalseHuPunishment" : "False Hu punishment",
            "FalseHuCallsAllowed" : "False Hu calls allowed",
            "InitialScores" : "Initial scores",
            "RandomSeat" : "Random seat",
            "HideNickname" : "Hide nickname",
            "GuestAllowed" : "Guest allowed",
            "TablePassword" : "Password (optional)",
            "XSecond" : "{1}s",
            "XRounds" : "{1} RDs",
            "XFans" : "{1} Fan(s)",
            "Ready" : "Ready",
            "CancelReady" : "Cancel Ready",
            "Anonymous" : "Anonymous",
            "InputPassword" : "Input Password",
            "Login" : "Login",
            "Password" : "Password",
            "VerifyQues" : "Q: What does '{1}' wait?"
          };
          break;
        }
      })();

      document.title = tz.ls('HTMLTitle');
      document.getElementsByTagName('canvas')[0].innerText = tz.ls('BrowerNotSupport');
      tz.strt_load();
    })();
  </script>
</body>
</html>
